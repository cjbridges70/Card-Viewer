<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Card Viewer (Thin + Front Holo + Height Map + Permanent Back)</title>
  <style>
    html, body { margin: 0; height: 100%; overflow: hidden; background: #0b0f14; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; }
    canvas { display: block; }
    #ui {
      position: fixed; top: 12px; left: 12px; z-index: 10;
      background: rgba(0,0,0,.6); color: #fff; padding: 12px; border-radius: 12px;
      backdrop-filter: blur(8px);
      display: grid; gap: 10px; min-width: 320px; max-width: min(92vw, 440px);
      box-shadow: 0 10px 30px rgba(0,0,0,.35);
    }
    #ui label { font-size: 12px; opacity: .95; display: grid; gap: 6px; }
    #ui small { opacity: .75; line-height: 1.25; }
    #status {
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      font-size: 11px;
      white-space: pre-wrap;
      background: rgba(255,255,255,.06);
      border: 1px solid rgba(255,255,255,.08);
      padding: 8px 10px;
      border-radius: 10px;
      max-height: 170px;
      overflow: auto;
      line-height: 1.25;
    }
    .row { display: grid; grid-template-columns: 1fr auto; gap: 10px; align-items: center; }
    input[type="range"] { width: 190px; }
    button {
      appearance: none;
      border: 1px solid rgba(255,255,255,.16);
      background: rgba(255,255,255,.08);
      color: #fff;
      padding: 8px 10px;
      border-radius: 10px;
      cursor: pointer;
      font-size: 12px;
    }
    button:active { transform: translateY(1px); }
    .pill {
      font-size: 11px; opacity: .9;
      background: rgba(255,255,255,.08);
      border: 1px solid rgba(255,255,255,.10);
      padding: 4px 8px; border-radius: 999px;
    }
  </style>

  <script type="importmap">
    {
      "imports": {
        "three": "./libs/three.module.js",
        "three/addons/": "./libs/examples/jsm/"
      }
    }
  </script>
</head>

<body>
  <div id="ui">
    <div id="status">Loading…</div>

    <label>Front image (JPG/PNG)
      <input id="frontInput" type="file" accept="image/jpeg,image/png" />
    </label>

    <div class="row">
      <button id="genHeightBtn">Generate height from front</button>
      <span class="pill">Fast (no ML)</span>
    </div>

    <label>Height map (optional override, grayscale JPG/PNG)
      <input id="heightInput" type="file" accept="image/jpeg,image/png" />
    </label>

    <div class="row">
      <label style="margin:0;">Relief (bump)</label>
      <input id="bumpSlider" type="range" min="0" max="0.08" step="0.001" value="0.02" />
    </div>

    <div class="row">
      <label style="margin:0;">Holo strength</label>
      <input id="holoSlider" type="range" min="0" max="1" step="0.01" value="0.55" />
    </div>

    <div class="row">
      <label style="margin:0;">Holo reacts to height</label>
      <input id="holoReliefSlider" type="range" min="0" max="2" step="0.01" value="0.90" />
    </div>

    <small>
      Back is permanent: <span class="pill">assets/pokemon-back.jpg</span><br/>
      Drag to rotate • Scroll to zoom • Right-drag to pan
    </small>
  </div>

  <script type="module">
    import * as THREE from "three";
    import { OrbitControls } from "three/addons/controls/OrbitControls.js";

    const statusEl = document.getElementById("status");
    const log = (m) => statusEl.textContent = m + "\n" + statusEl.textContent;

    window.addEventListener("error", (e) => log("JS ERROR ❌ " + (e.message || e.error || e)));
    window.addEventListener("unhandledrejection", (e) => log("PROMISE ERROR ❌ " + (e.reason?.message || e.reason || e)));

    // WebGL check
    {
      const c = document.createElement("canvas");
      const gl = c.getContext("webgl") || c.getContext("experimental-webgl");
      if (!gl) { log("WebGL not available ❌"); throw new Error("WebGL not available"); }
      log("WebGL: available ✅");
    }

    // Renderer
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    document.body.appendChild(renderer.domElement);

    // Scene / camera
    const scene = new THREE.Scene();
    scene.fog = new THREE.Fog(0x0b0f14, 2.5, 10);

    const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.01, 100);
    camera.position.set(0, 0.35, 1.35);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.06;
    controls.minDistance = 0.6;
    controls.maxDistance = 3.0;
    controls.target.set(0, 0.05, 0);

    // Lights
    scene.add(new THREE.AmbientLight(0xffffff, 0.55));
    const key = new THREE.DirectionalLight(0xffffff, 1.3); key.position.set(1.5, 2.0, 1.2); scene.add(key);
    const fill = new THREE.DirectionalLight(0xffffff, 0.7); fill.position.set(-1.8, 1.2, 1.6); scene.add(fill);
    const rim  = new THREE.DirectionalLight(0x9bd5ff, 0.6); rim.position.set(0.0, 1.8, -2.0); scene.add(rim);

    // Card dimensions (thin, no bevel)
    const cardWidth = 0.63;
    const cardHeight = 0.88;
    const thickness = 0.004;
    const cornerRadius = 0.045;

    function roundedRectShape(w, h, r) {
      const x = -w/2, y = -h/2;
      const s = new THREE.Shape();
      const rr = Math.min(r, w/2, h/2);
      s.moveTo(x + rr, y);
      s.lineTo(x + w - rr, y); s.quadraticCurveTo(x + w, y, x + w, y + rr);
      s.lineTo(x + w, y + h - rr); s.quadraticCurveTo(x + w, y + h, x + w - rr, y + h);
      s.lineTo(x + rr, y + h); s.quadraticCurveTo(x, y + h, x, y + h - rr);
      s.lineTo(x, y + rr); s.quadraticCurveTo(x, y, x + rr, y);
      return s;
    }

    // Extrude edge, remove caps (no bevel)
    function extrudeSidesOnly(shape) {
      const full = new THREE.ExtrudeGeometry(shape, {
        depth: thickness,
        bevelEnabled: false,
        curveSegments: 24
      });
      full.translate(0, 0, -thickness/2);
      full.computeVertexNormals();

      const g = full.toNonIndexed();
      const pos = g.attributes.position;
      const nor = g.attributes.normal;

      const keptPos = [];
      const keptNor = [];

      for (let i = 0; i < pos.count; i += 3) {
        const nz = (nor.getZ(i) + nor.getZ(i+1) + nor.getZ(i+2)) / 3;
        if (Math.abs(nz) > 0.6) continue; // remove front/back caps
        for (let k = 0; k < 3; k++) {
          keptPos.push(pos.getX(i+k), pos.getY(i+k), pos.getZ(i+k));
          keptNor.push(nor.getX(i+k), nor.getY(i+k), nor.getZ(i+k));
        }
      }

      const out = new THREE.BufferGeometry();
      out.setAttribute("position", new THREE.Float32BufferAttribute(keptPos, 3));
      out.setAttribute("normal", new THREE.Float32BufferAttribute(keptNor, 3));
      return out;
    }

    // Rounded face geometry (higher detail for bump/foil)
    function makeRoundedFaceGeometry() {
      const shape = roundedRectShape(cardWidth, cardHeight, cornerRadius);
      const g = new THREE.ShapeGeometry(shape, 64);

      // UVs from XY bounds
      g.computeBoundingBox();
      const bb = g.boundingBox;
      const size = new THREE.Vector3();
      bb.getSize(size);

      const pos = g.attributes.position;
      const uv = [];
      for (let i = 0; i < pos.count; i++) {
        const x = pos.getX(i);
        const y = pos.getY(i);
        uv.push((x - bb.min.x) / size.x, (y - bb.min.y) / size.y);
      }
      g.setAttribute("uv", new THREE.Float32BufferAttribute(uv, 2));
      g.computeVertexNormals();
      return g;
    }

    const shape = roundedRectShape(cardWidth, cardHeight, cornerRadius);
    const sideGeom = extrudeSidesOnly(shape);
    const faceGeom = makeRoundedFaceGeometry();

    // Materials
    const edgeMat = new THREE.MeshStandardMaterial({
      color: 0x2a2f38,
      roughness: 0.95,
      metalness: 0.0
    });

    const loader = new THREE.TextureLoader();

    // Permanent back texture from repo
    const permanentBack = loader.load(
      "./assets/pokemon-back.jpg",
      () => log("Back texture loaded ✅"),
      undefined,
      () => log("Back texture failed ❌ Check assets/pokemon-back.jpg (case sensitive)")
    );
    permanentBack.colorSpace = THREE.SRGBColorSpace;
    permanentBack.anisotropy = 8;
    permanentBack.flipY = true; // if back is upside down, change to false

    // Default front placeholder
    const defaultFront = loader.load(
      "https://threejs.org/examples/textures/uv_grid_opengl.jpg",
      () => log("Default front loaded ✅")
    );
    defaultFront.colorSpace = THREE.SRGBColorSpace;
    defaultFront.anisotropy = 8;
    defaultFront.flipY = false;

    // Default 1x1 mid-gray height texture
    const defaultHeight = new THREE.DataTexture(new Uint8Array([128]), 1, 1, THREE.RedFormat);
    defaultHeight.colorSpace = THREE.NoColorSpace;
    defaultHeight.flipY = true;
    defaultHeight.needsUpdate = true;

    const frontMat = new THREE.MeshStandardMaterial({
      map: defaultFront,
      roughness: 0.55,
      metalness: 0.05,
      bumpMap: defaultHeight,
      bumpScale: 0.02
    });

    const backMat = new THREE.MeshStandardMaterial({
      map: permanentBack,
      roughness: 0.65,
      metalness: 0.02
    });

    // Card group
    const cardGroup = new THREE.Group();
    scene.add(cardGroup);

    cardGroup.add(new THREE.Mesh(sideGeom, edgeMat));

    const Z_FACE = thickness/2 + 0.0007;
    const Z_FILM = thickness/2 + 0.0010;

    const frontMesh = new THREE.Mesh(faceGeom, frontMat);
    frontMesh.position.z = Z_FACE;
    cardGroup.add(frontMesh);

    const backMesh = new THREE.Mesh(faceGeom, backMat);
    backMesh.rotation.y = Math.PI;
    backMesh.position.z = -Z_FACE;
    cardGroup.add(backMesh);

    cardGroup.rotation.x = -0.08;
    cardGroup.rotation.y = 0.55;

    // Ground
    const ground = new THREE.Mesh(
      new THREE.PlaneGeometry(6, 6),
      new THREE.MeshStandardMaterial({ color: 0x0b0f14, roughness: 1, metalness: 0 })
    );
    ground.rotation.x = -Math.PI/2;
    ground.position.y = -0.55;
    scene.add(ground);

    // ---- FRONT-ONLY HOLO FILM (reacts to height map) ----
    function makeHoloFilmMaterial(heightTex) {
      return new THREE.ShaderMaterial({
        transparent: true,
        depthWrite: false,
        blending: THREE.AdditiveBlending,
        uniforms: {
          uTime: { value: 0.0 },
          uStrength: { value: 0.55 },
          uHeight: { value: heightTex },
          uRelief: { value: 0.90 }
        },
        vertexShader: `
          varying vec2 vUv;
          varying vec3 vN;
          varying vec3 vV;
          varying vec3 vTx;
          varying vec3 vTy;
          void main() {
            vUv = uv;
            vec4 mv = modelViewMatrix * vec4(position, 1.0);
            vV = -mv.xyz;
            vN = normalize(normalMatrix * normal);
            vTx = normalize(normalMatrix * vec3(1.0, 0.0, 0.0));
            vTy = normalize(normalMatrix * vec3(0.0, 1.0, 0.0));
            gl_Position = projectionMatrix * mv;
          }
        `,
        fragmentShader: `
          precision highp float;
          varying vec2 vUv;
          varying vec3 vN;
          varying vec3 vV;
          varying vec3 vTx;
          varying vec3 vTy;

          uniform float uTime;
          uniform float uStrength;
          uniform sampler2D uHeight;
          uniform float uRelief;

          float hash21(vec2 p){
            p = fract(p*vec2(123.34, 456.21));
            p += dot(p, p+45.32);
            return fract(p.x*p.y);
          }

          void main() {
            float eps = 0.0015;
            float hC = texture2D(uHeight, vUv).r;
            float hX1 = texture2D(uHeight, vUv + vec2(eps, 0.0)).r;
            float hX0 = texture2D(uHeight, vUv - vec2(eps, 0.0)).r;
            float hY1 = texture2D(uHeight, vUv + vec2(0.0, eps)).r;
            float hY0 = texture2D(uHeight, vUv - vec2(0.0, eps)).r;

            float dx = (hX1 - hX0);
            float dy = (hY1 - hY0);

            vec3 N = normalize(vN + (-dx * uRelief) * vTx + (-dy * uRelief) * vTy);
            vec3 V = normalize(vV);

            float fres = pow(1.0 - max(dot(N, V), 0.0), 2.2);

            float bands = sin(vUv.y*70.0 + vUv.x*18.0 + uTime*1.6 + hC*6.0) * 0.5 + 0.5;
            float diag  = sin(vUv.x*90.0 + vUv.y*55.0 + uTime*0.9 + hC*4.0) * 0.5 + 0.5;

            float sparkle = step(0.987, hash21(vUv*vec2(1100.0,900.0) + uTime*0.2 + hC*2.0)) * 0.7;

            vec3 rainbow = 0.55 + 0.45*cos(6.28318*(vec3(0.0,0.33,0.67) + bands));
            vec3 film = rainbow*(0.08 + 0.92*fres) + rainbow*(diag*0.07) + sparkle;

            float ridge = smoothstep(0.45, 0.75, hC);
            float a = clamp((0.10 + 0.9*fres) * uStrength * (0.85 + 0.35*ridge), 0.0, 1.0);

            gl_FragColor = vec4(film * a, a);
          }
        `
      });
    }

    const frontFilmMat = makeHoloFilmMaterial(defaultHeight);
    frontFilmMat.polygonOffset = true;
    frontFilmMat.polygonOffsetFactor = -1;
    frontFilmMat.polygonOffsetUnits = -1;

    const frontFilm = new THREE.Mesh(faceGeom, frontFilmMat);
    frontFilm.position.z = Z_FILM;
    cardGroup.add(frontFilm);

    // ---- iOS-safe file loading ----
    let lastFrontImage = null; // used for Generate Height

    function downscaleImageToMax(img, maxSize) {
      const w0 = img.naturalWidth || img.width, h0 = img.naturalHeight || img.height;
      const largest = Math.max(w0, h0);
      if (largest <= maxSize) return img;
      const s = maxSize / largest;
      const w = Math.max(1, Math.round(w0*s));
      const h = Math.max(1, Math.round(h0*s));
      const c = document.createElement("canvas");
      c.width = w; c.height = h;
      c.getContext("2d").drawImage(img, 0, 0, w, h);
      const out = new Image();
      out.src = c.toDataURL("image/jpeg", 0.92);
      return out;
    }

    async function decodeImageFromFile(file) {
      const dataURL = await new Promise((resolve, reject) => {
        const r = new FileReader();
        r.onerror = () => reject(new Error("FileReader failed"));
        r.onload = () => resolve(r.result);
        r.readAsDataURL(file);
      });

      const img = await new Promise((resolve, reject) => {
        const im = new Image();
        im.onload = () => resolve(im);
        im.onerror = () => reject(new Error("Image decode failed"));
        im.src = dataURL;
      });

      return img;
    }

    function imageToTexture(img, { isData=false } = {}) {
      const tex = new THREE.Texture(img);
      tex.anisotropy = 8;
      tex.flipY = true; // matches your working upload orientation
      tex.colorSpace = isData ? THREE.NoColorSpace : THREE.SRGBColorSpace;
      tex.needsUpdate = true;
      return tex;
    }

    // ---- Option A: Generate height from front (fast, no ML) ----
    function generateHeightFromImage(img, maxSize = 1024) {
      const w0 = img.naturalWidth || img.width;
      const h0 = img.naturalHeight || img.height;
      const s = Math.min(1, maxSize / Math.max(w0, h0));
      const w = Math.max(1, Math.round(w0 * s));
      const h = Math.max(1, Math.round(h0 * s));

      const c = document.createElement("canvas");
      c.width = w; c.height = h;
      const ctx = c.getContext("2d", { willReadFrequently: true });
      ctx.drawImage(img, 0, 0, w, h);

      const im = ctx.getImageData(0, 0, w, h);
      const d = im.data;

      // 1) luminance
      const lum = new Float32Array(w * h);
      for (let i = 0, p = 0; p < lum.length; p++, i += 4) {
        const r = d[i] / 255, g = d[i+1] / 255, b = d[i+2] / 255;
        lum[p] = 0.2126*r + 0.7152*g + 0.0722*b;
      }

      // 2) blur (3x3 box)
      function blur3x3(src) {
        const out = new Float32Array(src.length);
        for (let y = 0; y < h; y++) {
          for (let x = 0; x < w; x++) {
            let sum = 0, count = 0;
            for (let oy = -1; oy <= 1; oy++) {
              for (let ox = -1; ox <= 1; ox++) {
                const xx = x + ox, yy = y + oy;
                if (xx < 0 || xx >= w || yy < 0 || yy >= h) continue;
                sum += src[yy*w + xx];
                count++;
              }
            }
            out[y*w + x] = sum / count;
          }
        }
        return out;
      }
      const base = blur3x3(lum);

      // 3) edge magnitude (Sobel-ish)
      const edge = new Float32Array(w * h);
      for (let y = 1; y < h-1; y++) {
        for (let x = 1; x < w-1; x++) {
          const i = y*w + x;
          const gx =
            -base[i - w - 1] - 2*base[i - 1] - base[i + w - 1] +
             base[i - w + 1] + 2*base[i + 1] + base[i + w + 1];
          const gy =
            -base[i - w - 1] - 2*base[i - w] - base[i - w + 1] +
             base[i + w - 1] + 2*base[i + w] + base[i + w + 1];
          edge[i] = Math.min(1.0, Math.sqrt(gx*gx + gy*gy));
        }
      }

      // 4) combine + normalize
      const height = new Float32Array(w * h);
      let mn = 1e9, mx = -1e9;
      for (let i = 0; i < height.length; i++) {
        const v = base[i] * 0.85 + edge[i] * 0.60;
        height[i] = v;
        mn = Math.min(mn, v);
        mx = Math.max(mx, v);
      }
      const range = Math.max(1e-6, mx - mn);
      for (let i = 0; i < height.length; i++) height[i] = (height[i] - mn) / range;

      const out = ctx.createImageData(w, h);
      for (let i = 0, p = 0; p < height.length; p++, i += 4) {
        const v = Math.round(height[p] * 255);
        out.data[i] = v; out.data[i+1] = v; out.data[i+2] = v; out.data[i+3] = 255;
      }
      ctx.putImageData(out, 0, 0);
      return c;
    }

    function canvasToHeightTexture(canvas) {
      const tex = new THREE.CanvasTexture(canvas);
      tex.colorSpace = THREE.NoColorSpace;
      tex.anisotropy = 8;
      tex.flipY = true; // match our shader/bump expectations
      tex.needsUpdate = true;
      return tex;
    }

    // ---- UI Wiring ----
    const bumpSlider = document.getElementById("bumpSlider");
    const holoSlider = document.getElementById("holoSlider");
    const holoReliefSlider = document.getElementById("holoReliefSlider");

    bumpSlider.addEventListener("input", () => {
      frontMat.bumpScale = parseFloat(bumpSlider.value);
      frontMat.needsUpdate = true;
    });

    holoSlider.addEventListener("input", () => {
      frontFilmMat.uniforms.uStrength.value = parseFloat(holoSlider.value);
    });

    holoReliefSlider.addEventListener("input", () => {
      frontFilmMat.uniforms.uRelief.value = parseFloat(holoReliefSlider.value);
    });

    document.getElementById("frontInput").addEventListener("change", async (e) => {
      const file = e.target.files?.[0];
      if (!file) return;

      try {
        log(`Front picked: ${file.name} (${(file.size/1024/1024).toFixed(2)} MB)`);
        const img0 = await decodeImageFromFile(file);
        const img = downscaleImageToMax(img0, 2048);

        // Wait if downscaled
        const finalImg = await new Promise((resolve, reject) => {
          if (img === img0) return resolve(img0);
          img.onload = () => resolve(img);
          img.onerror = () => reject(new Error("Downscaled image decode failed"));
        });

        lastFrontImage = finalImg;

        const tex = imageToTexture(finalImg, { isData:false });
        if (frontMat.map) frontMat.map.dispose();
        frontMat.map = tex;
        frontMat.needsUpdate = true;

        log(`Front applied ✅ ${finalImg.naturalWidth}x${finalImg.naturalHeight}`);
      } catch (err) {
        log("Front failed ❌ " + err.message);
        alert("Front failed: " + err.message);
      }
    });

    document.getElementById("heightInput").addEventListener("change", async (e) => {
      const file = e.target.files?.[0];
      if (!file) return;

      try {
        log(`Height picked: ${file.name} (${(file.size/1024/1024).toFixed(2)} MB)`);
        const img0 = await decodeImageFromFile(file);
        const img = downscaleImageToMax(img0, 2048);

        const finalImg = await new Promise((resolve, reject) => {
          if (img === img0) return resolve(img0);
          img.onload = () => resolve(img);
          img.onerror = () => reject(new Error("Downscaled image decode failed"));
        });

        const tex = imageToTexture(finalImg, { isData:true });

        if (frontMat.bumpMap && frontMat.bumpMap !== defaultHeight) frontMat.bumpMap.dispose();
        frontMat.bumpMap = tex;
        frontMat.bumpScale = parseFloat(bumpSlider.value);
        frontMat.needsUpdate = true;

        frontFilmMat.uniforms.uHeight.value = tex;

        log(`Height applied ✅ ${finalImg.naturalWidth}x${finalImg.naturalHeight}`);
      } catch (err) {
        log("Height failed ❌ " + err.message);
        alert("Height failed: " + err.message);
      }
    });

    document.getElementById("genHeightBtn").addEventListener("click", () => {
      if (!lastFrontImage) {
        alert("Upload a front image first.");
        return;
      }
      log("Generating height from front…");

      const c = generateHeightFromImage(lastFrontImage, 1024);
      const heightTex = canvasToHeightTexture(c);

      if (frontMat.bumpMap && frontMat.bumpMap !== defaultHeight) frontMat.bumpMap.dispose();
      frontMat.bumpMap = heightTex;
      frontMat.bumpScale = parseFloat(bumpSlider.value);
      frontMat.needsUpdate = true;

      frontFilmMat.uniforms.uHeight.value = heightTex;

      log("Generated height applied ✅");
    });

    // Resize + animate
    window.addEventListener("resize", () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    const clock = new THREE.Clock();
    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      frontFilmMat.uniforms.uTime.value = clock.getElapsedTime();
      renderer.render(scene, camera);
    }
    animate();

    log("Viewer ready ✅");
  </script>
</body>
</html>
