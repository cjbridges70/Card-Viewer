<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Card Viewer</title>
  <style>
    :root{
      --bg:#050607;
      --panel: rgba(20,22,26,.72);
      --stroke: rgba(255,255,255,.10);
      --text: rgba(255,255,255,.92);
      --muted: rgba(255,255,255,.62);
      --btn: rgba(255,255,255,.08);
      --btn2: rgba(255,255,255,.12);
      --shadow: 0 18px 60px rgba(0,0,0,.55);
      --r: 14px;
    }
    html,body{ height:100%; margin:0; background:var(--bg); overflow:hidden; font-family: ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial; }
    #c{ position:fixed; inset:0; width:100%; height:100%; display:block; }

    .topbar{
      position: fixed;
      left: max(10px, env(safe-area-inset-left));
      right: max(10px, env(safe-area-inset-right));
      top: max(10px, env(safe-area-inset-top));
      display:flex;
      gap:10px;
      align-items:center;
      padding:10px;
      border-radius: 999px;
      background: linear-gradient(180deg, rgba(35,38,44,.78), rgba(18,20,24,.68));
      border: 1px solid var(--stroke);
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      z-index:10;
    }
    .pill{
      display:flex; align-items:center; gap:10px;
      min-width:0; flex: 1;
      padding: 10px 12px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.08);
      background: rgba(0,0,0,.18);
    }
    .statusDot{
      width:10px; height:10px; border-radius: 999px;
      background: rgba(255,255,255,.28);
      box-shadow: 0 0 0 2px rgba(0,0,0,.15) inset;
      flex: 0 0 auto;
    }
    .statusText{
      color: var(--muted);
      font-size: 13px;
      white-space: nowrap;
      overflow:hidden;
      text-overflow: ellipsis;
      min-width:0;
    }
    button{
      appearance:none;
      border: 1px solid rgba(255,255,255,.10);
      background: var(--btn);
      color: var(--text);
      border-radius: 999px;
      padding: 10px 14px;
      font-size: 13px;
      cursor: pointer;
      box-shadow: 0 10px 30px rgba(0,0,0,.25);
    }
    button:hover{ background: var(--btn2); }
    button:active{ transform: translateY(1px); }
    .iconBtn{
      width: 42px; height: 42px;
      display:grid; place-items:center;
      padding:0;
      font-size: 18px;
      line-height: 0;
      flex: 0 0 auto;
    }

    .panel{
      position: fixed;
      right: max(10px, env(safe-area-inset-right));
      top: calc(max(10px, env(safe-area-inset-top)) + 74px);
      width: min(360px, calc(100vw - 20px));
      border-radius: var(--r);
      background: var(--panel);
      border: 1px solid var(--stroke);
      box-shadow: var(--shadow);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      padding: 12px;
      z-index: 10;
      transform-origin: top right;
      transition: opacity .18s ease, transform .18s ease;
    }
    .panel.hidden{
      opacity: 0;
      transform: translateY(-6px) scale(.98);
      pointer-events:none;
    }
    .label{ color: var(--muted); font-size: 12px; margin-top: 8px; }
    input[type="file"]{ width:100%; color: var(--muted); font-size: 13px; }
    .toggle{
      display:flex; align-items:center; gap:10px;
      padding: 10px 10px;
      border-radius: 12px;
      background: rgba(0,0,0,.18);
      border: 1px solid rgba(255,255,255,.08);
    }
    .toggle b{ color: var(--text); font-size: 13px; font-weight: 600; }
    .toggle small{ color: var(--muted); display:block; margin-top:2px; font-size: 12px; }
    .divider{ height:1px; background: rgba(255,255,255,.10); margin: 10px 0; }

    .btnRow{ display:flex; gap:10px; flex-wrap:wrap; }
    .btnRow button{ flex: 1 1 auto; min-width: 140px; }

    .hint{
      position: fixed;
      right: max(10px, env(safe-area-inset-right));
      top: calc(max(10px, env(safe-area-inset-top)) + 74px);
      transform: translateY(220px);
      padding: 10px 12px;
      border-radius: 999px;
      background: rgba(0,0,0,.25);
      border: 1px solid rgba(255,255,255,.08);
      color: rgba(255,255,255,.60);
      font-size: 12px;
      box-shadow: 0 10px 30px rgba(0,0,0,.25);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      z-index: 9;
      pointer-events:none;
      max-width: min(520px, calc(100vw - 20px));
      white-space: nowrap;
      overflow:hidden;
      text-overflow: ellipsis;
    }

    @media (max-width: 520px){
      .panel{
        right: max(10px, env(safe-area-inset-right));
        left: max(10px, env(safe-area-inset-left));
        width: auto;
        top: calc(max(10px, env(safe-area-inset-top)) + 74px);
      }
      .hint{ left: max(10px, env(safe-area-inset-left)); right: max(10px, env(safe-area-inset-right)); }
      .btnRow button{ min-width: 120px; }
    }
  </style>
</head>

<body>
  <canvas id="c"></canvas>

  <div class="topbar">
    <button id="menuBtn" class="iconBtn" title="Menu">≡</button>
    <div class="pill" title="Status">
      <div id="dot" class="statusDot"></div>
      <div id="status" class="statusText">Ready</div>
    </div>
    <button id="presetsBtn">Presets…</button>
    <button id="resetBtn">Reset</button>
  </div>

  <div id="panel" class="panel hidden">
    <div class="label">Front image (base color)</div>
    <input id="frontFile" type="file" accept="image/*" />

    <div class="label">Optional: Height map (grayscale)</div>
    <input id="heightFile" type="file" accept="image/*" />

    <div class="divider"></div>

    <div class="toggle">
      <input id="holoToggle" type="checkbox" checked />
      <div>
        <b>Holographic (front only)</b>
        <small>Wide bands + foil grain (extreme)</small>
      </div>
    </div>

    <div class="toggle" style="margin-top:10px;">
      <input id="autoHeightToggle" type="checkbox" checked />
      <div>
        <b>Auto Height</b>
        <small>Image-guided relief + non-tiling micro-emboss</small>
      </div>
    </div>

    <div class="divider"></div>

    <div class="btnRow">
      <button id="exportHeightBtn">Export Height</button>
      <button id="exportFoilMaskBtn">Export Foil Mask</button>
    </div>

    <div class="label" style="margin-top:10px; color:rgba(255,255,255,.55);">
      GitHub Pages is case-sensitive. “.JPG” ≠ “.jpg”.
    </div>
  </div>

  <div class="hint">Drag to rotate • Pinch/scroll to zoom</div>

<script type="module">
  // ✅ LOCAL LIBS (MATCHES YOUR REPO)
  import * as THREE from "./libs/three.module.js";
  import { OrbitControls } from "./libs/examples/jsm/controls/OrbitControls.js";

  // -------------------------
  // Presets (base names; we auto-try extensions)
  // -------------------------
  const PRESETS = [
    { name: "Mega Rayquaza", frontBase: "assets/presets/mega-rayquaza-front" },
    { name: "Mega Blastoise", frontBase: "assets/presets/mega-blastoise-front" },
  ];

  // Permanent back texture (your screenshot shows it at assets/pokemon-back.jpg)
  const BACK_BASE = "assets/pokemon-back";

  // -------------------------
  // UI helpers
  // -------------------------
  const $ = (id) => document.getElementById(id);
  const panel = $("panel");
  const statusEl = $("status");
  const dot = $("dot");

  function setStatus(text, ok=true){
    statusEl.textContent = text;
    dot.style.background = ok ? "rgba(66, 223, 138, .85)" : "rgba(255, 90, 90, .9)";
  }
  function setInfo(text){
    statusEl.textContent = text;
    dot.style.background = "rgba(255,255,255,.28)";
  }

  $("menuBtn").addEventListener("click", () => panel.classList.toggle("hidden"));
  $("presetsBtn").addEventListener("click", () => { panel.classList.remove("hidden"); showPresetsMenu(); });
  $("resetBtn").addEventListener("click", () => resetAll());

  // -------------------------
  // Three.js scene
  // -------------------------
  const canvas = $("c");
  const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: false, powerPreference:"high-performance" });
  renderer.setClearColor(0x000000, 1);
  renderer.outputColorSpace = THREE.SRGBColorSpace;
  renderer.toneMapping = THREE.ACESFilmicToneMapping;
  renderer.toneMappingExposure = 1.08;

  const scene = new THREE.Scene();

  const camera = new THREE.PerspectiveCamera(35, 1, 0.01, 50);
  camera.position.set(0, 0.05, 2.25);

  const controls = new OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;
  controls.enablePan = true;
  controls.dampingFactor = 0.08;
  controls.minDistance = 0.9;
  controls.maxDistance = 6.0;

  // Lighting tuned for foil
  scene.add(new THREE.AmbientLight(0xffffff, 0.55));
  const key = new THREE.DirectionalLight(0xffffff, 1.35);
  key.position.set(2.2, 2.1, 2.0);
  scene.add(key);
  const rim = new THREE.DirectionalLight(0xffffff, 0.55);
  rim.position.set(-2.2, 0.2, -1.8);
  scene.add(rim);

  // Simple stage
  const floor = new THREE.Mesh(
    new THREE.CircleGeometry(10, 64),
    new THREE.MeshStandardMaterial({ color: 0x15171a, roughness: 0.95, metalness: 0.0 })
  );
  floor.rotation.x = -Math.PI/2;
  floor.position.y = -1.25;
  scene.add(floor);

  // -------------------------
  // Helpers: robust texture loading (tries .jpg/.JPG/.png/etc)
  // -------------------------
  const textureLoader = new THREE.TextureLoader();
  textureLoader.crossOrigin = "anonymous";

  const EXT_TRIES = [".jpg",".JPG",".jpeg",".JPEG",".png",".PNG",".webp",".WEBP"];

  function loadTextureTry(basePath){
    if (/\.(jpg|jpeg|png|webp)$/i.test(basePath)){
      return new Promise((resolve, reject) => {
        textureLoader.load(basePath, t => resolve(t), undefined, e => reject(e));
      });
    }
    let i = 0;
    return new Promise((resolve, reject) => {
      const tryNext = () => {
        if (i >= EXT_TRIES.length) return reject(new Error("Missing: " + basePath + ".[jpg/JPG/png/etc]"));
        const url = basePath + EXT_TRIES[i++];
        textureLoader.load(url, t => resolve(t), undefined, () => tryNext());
      };
      tryNext();
    });
  }

  function configureTexture(tex){
    tex.colorSpace = THREE.SRGBColorSpace;
    tex.wrapS = tex.wrapT = THREE.ClampToEdgeWrapping;
    tex.anisotropy = Math.min(8, renderer.capabilities.getMaxAnisotropy());
    tex.flipY = false;
    tex.needsUpdate = true;
    return tex;
  }

  function configureHeightTexture(tex){
    tex.colorSpace = THREE.NoColorSpace;
    tex.wrapS = tex.wrapT = THREE.ClampToEdgeWrapping;
    tex.anisotropy = 1;
    tex.flipY = false;
    tex.needsUpdate = true;
    return tex;
  }

  // -------------------------
  // Auto height + foil mask (image-guided)
  // -------------------------
  function imageToCanvas(img, maxSize=2048){
    const w = img.width, h = img.height;
    const s = Math.min(1, maxSize / Math.max(w,h));
    const cw = Math.max(1, Math.round(w*s));
    const ch = Math.max(1, Math.round(h*s));
    const c = document.createElement("canvas");
    c.width = cw; c.height = ch;
    const ctx = c.getContext("2d", { willReadFrequently: true });
    ctx.drawImage(img, 0, 0, cw, ch);
    return { c, ctx, cw, ch };
  }

  function clamp01(x){ return Math.max(0, Math.min(1, x)); }
  function fract(x){ return x - Math.floor(x); }

  // IMPORTANT: this generator outputs height/foil in "front image orientation"
  // and the shaders sample them with the SAME UVs as the front image -> no upside-down.
  function generateHeightAndFoilFromFront(frontImg, outSize=1024){
    const { c } = imageToCanvas(frontImg, Math.max(outSize, 1024));

    const oc = document.createElement("canvas");
    oc.width = outSize;
    oc.height = Math.round(outSize * (c.height / c.width));
    const octx = oc.getContext("2d", { willReadFrequently: true });

    // Draw with Y-flip so generated maps match the way we sample uvFront in shader
    // (shader uses uvFront = vec2(vUv.x, 1.0 - vUv.y))
    octx.save();
    octx.translate(0, oc.height);
    octx.scale(1, -1);
    octx.drawImage(c, 0, 0, oc.width, oc.height);
    octx.restore();

    const w = oc.width, h = oc.height;
    const img = octx.getImageData(0,0,w,h);
    const d = img.data;

    const lum = new Float32Array(w*h);
    for (let i=0, p=0; i<w*h; i++, p+=4){
      const r=d[p]/255, g=d[p+1]/255, b=d[p+2]/255;
      lum[i] = 0.2126*r + 0.7152*g + 0.0722*b;
    }

    const edge = new Float32Array(w*h);
    const idx = (x,y)=> y*w+x;
    for (let y=1;y<h-1;y++){
      for (let x=1;x<w-1;x++){
        const gx =
          -lum[idx(x-1,y-1)] -2*lum[idx(x-1,y)] -lum[idx(x-1,y+1)]
          +lum[idx(x+1,y-1)] +2*lum[idx(x+1,y)] +lum[idx(x+1,y+1)];
        const gy =
          -lum[idx(x-1,y-1)] -2*lum[idx(x,y-1)] -lum[idx(x+1,y-1)]
          +lum[idx(x-1,y+1)] +2*lum[idx(x,y+1)] +lum[idx(x+1,y+1)];
        edge[idx(x,y)] = Math.sqrt(gx*gx + gy*gy);
      }
    }
    let eMax=1e-6;
    for (let i=0;i<edge.length;i++) eMax = Math.max(eMax, edge[i]);
    for (let i=0;i<edge.length;i++) edge[i] = edge[i]/eMax;

    const detail = new Float32Array(w*h);
    for (let y=1;y<h-1;y++){
      for (let x=1;x<w-1;x++){
        const i = idx(x,y);
        const l = lum[i];
        const avg =
          (lum[idx(x-1,y)] + lum[idx(x+1,y)] + lum[idx(x,y-1)] + lum[idx(x,y+1)] + l) / 5;
        const contrast = Math.abs(l-avg);
        detail[i] = clamp01(0.85*edge[i] + 1.35*contrast);
      }
    }

    // Foil mask: favor detailed areas (background/linework), suppress smooth character
    const foilMask = new Float32Array(w*h);
    for (let i=0;i<w*h;i++){
      const m = (detail[i] - 0.10) / (0.28 - 0.10);
      foilMask[i] = clamp01(m);
    }

    const height = new Float32Array(w*h);
    for (let y=0;y<h;y++){
      for (let x=0;x<w;x++){
        const i = idx(x,y);
        const l = lum[i];
        const e = edge[i];

        const nx = x/(w-1), ny = y/(h-1);
        const n = fract(Math.sin((nx*127.1 + ny*311.7)*43758.5453) * 143758.5453);
        const grain = (n - 0.5);

        const base = 0.22*(1.0-l) + 0.85*e;
        const micro = grain * (0.22 + 0.78*foilMask[i]);

        height[i] = clamp01(base + 0.18*micro);
      }
    }

    const outH = octx.createImageData(w,h);
    for (let i=0, p=0; i<w*h; i++, p+=4){
      const v = Math.round(height[i]*255);
      outH.data[p]=v; outH.data[p+1]=v; outH.data[p+2]=v; outH.data[p+3]=255;
    }
    const outF = octx.createImageData(w,h);
    for (let i=0, p=0; i<w*h; i++, p+=4){
      const v = Math.round(foilMask[i]*255);
      outF.data[p]=v; outF.data[p+1]=v; outF.data[p+2]=v; outF.data[p+3]=255;
    }

    const heightCanvas = document.createElement("canvas");
    heightCanvas.width = w; heightCanvas.height = h;
    heightCanvas.getContext("2d").putImageData(outH,0,0);

    const foilCanvas = document.createElement("canvas");
    foilCanvas.width = w; foilCanvas.height = h;
    foilCanvas.getContext("2d").putImageData(outF,0,0);

    return { heightCanvas, foilCanvas };
  }

  // -------------------------
  // Card material (front/back in one shader)
  // Rounded corners in shader
  // Displacement fades near edges (prevents border bevel)
  // Holo + texture extend to border (until rounded corner discard)
  // -------------------------
  const uniforms = {
    uFrontMap: { value: null },
    uBackMap:  { value: null },
    uHeightMap:{ value: null },
    uFoilMask: { value: null },
    uHasHeight:{ value: 0 },
    uHasFoil:  { value: 0 },
    uTime:     { value: 0 },
    uHolo:     { value: 1 },
    uAutoHeight:{ value: 1 },
    uDisp:     { value: 0.030 }, // strong, but edge-faded
    uCorner:   { value: 0.060 },
    uEdgeFade: { value: 0.040 },
    uBandFreq: { value: 3.2 },   // wide holo bands
  };

  const vert = /*glsl*/`
    varying vec2 vUv;
    varying vec3 vN;
    varying vec3 vV;

    uniform sampler2D uHeightMap;
    uniform float uHasHeight;
    uniform float uDisp;
    uniform float uCorner;
    uniform float uEdgeFade;

    float roundRectMask(vec2 uv, float r){
      vec2 p = uv*2.0 - 1.0;
      vec2 b = vec2(1.0 - r*2.0);
      vec2 q = abs(p) - b;
      float outside = length(max(q, 0.0)) - r*2.0;
      return 1.0 - smoothstep(0.0, 0.01, outside);
    }

    void main(){
      vUv = uv;
      vec3 pos = position;

      float m = roundRectMask(uv, uCorner);

      float edge = min(min(uv.x, 1.0-uv.x), min(uv.y, 1.0-uv.y));
      float fade = smoothstep(0.0, uEdgeFade, edge);
      float dispMask = m * fade;

      if(uHasHeight > 0.5){
        // Sample height using SAME uvFront as fragment (uvFront = (x, 1-y))
        vec2 huv = vec2(uv.x, 1.0 - uv.y);
        float h = texture2D(uHeightMap, huv).r;
        h = (h - 0.5);
        pos += normal * (h * uDisp * dispMask);
      }

      vec4 worldPos = modelMatrix * vec4(pos, 1.0);
      vN = normalize(mat3(modelMatrix) * normal);
      vV = normalize(cameraPosition - worldPos.xyz);
      gl_Position = projectionMatrix * viewMatrix * worldPos;
    }
  `;

  const frag = /*glsl*/`
    precision highp float;
    varying vec2 vUv;
    varying vec3 vN;
    varying vec3 vV;

    uniform sampler2D uFrontMap;
    uniform sampler2D uBackMap;
    uniform sampler2D uFoilMask;
    uniform float uHasFoil;
    uniform float uTime;
    uniform float uHolo;
    uniform float uCorner;
    uniform float uBandFreq;

    float roundRectMask(vec2 uv, float r){
      vec2 p = uv*2.0 - 1.0;
      vec2 b = vec2(1.0 - r*2.0);
      vec2 q = abs(p) - b;
      float outside = length(max(q, 0.0)) - r*2.0;
      return 1.0 - smoothstep(0.0, 0.006, outside);
    }

    vec3 hsv2rgb(vec3 c){
      vec4 K = vec4(1., 2./3., 1./3., 3.);
      vec3 p = abs(fract(c.xxx + K.xyz) * 6. - K.www);
      return c.z * mix(K.xxx, clamp(p - K.xxx, 0., 1.), c.y);
    }

    float sat(vec3 c){
      float mx = max(max(c.r,c.g),c.b);
      float mn = min(min(c.r,c.g),c.b);
      return mx - mn;
    }

    void main(){
      float mask = roundRectMask(vUv, uCorner);
      if(mask < 0.001) discard;

      vec2 uvFront = vec2(vUv.x, 1.0 - vUv.y);
      // Back fix: flip to match correct orientation
      vec2 uvBack  = vec2(vUv.x, 1.0 - vUv.y);

      bool frontFacing = gl_FrontFacing;
      vec4 base = frontFacing ? texture2D(uFrontMap, uvFront) : texture2D(uBackMap, uvBack);

      vec3 N = normalize(vN);
      vec3 V = normalize(vV);
      float ndv = clamp(dot(N,V), 0.0, 1.0);

      vec3 col = base.rgb;

      if(frontFacing && uHolo > 0.5){
        float fm = 1.0;
        if(uHasFoil > 0.5){
          fm = texture2D(uFoilMask, uvFront).r;
        }

        float band = sin((uvFront.x + uvFront.y*0.55) * uBandFreq + uTime*0.20);
        band = smoothstep(-0.2, 0.9, band);

        float fres = pow(1.0 - ndv, 2.2);
        float hue = fract(0.12 + 0.85*(uvFront.x*0.25 + uvFront.y*0.18) + fres*0.75 + band*0.35);
        vec3 rainbow = hsv2rgb(vec3(hue, 0.95, 1.0));

        float s = sat(base.rgb);
        float grain = fract(sin(dot(uvFront*vec2(1200.0, 900.0), vec2(12.9898,78.233))) * 43758.5453);
        grain = smoothstep(0.86, 1.0, grain);

        vec3 foil = rainbow * (0.55 + 0.85*band) * (0.20 + 1.45*fres);
        foil += rainbow * grain * 1.35;

        float apply = clamp(0.15 + 0.95*fm, 0.0, 1.0);
        col = mix(col, clamp(col + foil, 0.0, 1.0), apply);
      }

      float v = smoothstep(0.0, 0.9, mask);
      col *= (0.88 + 0.12*v);

      gl_FragColor = vec4(col, 1.0);
    }
  `;

  const CARD_W = 2.5;
  const CARD_H = CARD_W * (3.5/2.5);
  const SUBDIV = 220;

  const geom = new THREE.PlaneGeometry(CARD_W, CARD_H, SUBDIV, Math.round(SUBDIV * (CARD_H/CARD_W)));

  const mat = new THREE.ShaderMaterial({
    uniforms,
    vertexShader: vert,
    fragmentShader: frag,
    side: THREE.DoubleSide
  });

  const card = new THREE.Mesh(geom, mat);
  scene.add(card);

  function makeSolidTexture(hex){
    const c = document.createElement("canvas");
    c.width = c.height = 2;
    const ctx = c.getContext("2d");
    ctx.fillStyle = "#" + hex.toString(16).padStart(6,"0");
    ctx.fillRect(0,0,2,2);
    const t = new THREE.CanvasTexture(c);
    t.colorSpace = THREE.SRGBColorSpace;
    t.flipY = false;
    return t;
  }

  const fallbackFront = makeSolidTexture(0x777777);
  const fallbackBack  = makeSolidTexture(0x222222);

  uniforms.uFrontMap.value = fallbackFront;
  uniforms.uBackMap.value = fallbackBack;

  async function loadBack(){
    try{
      const t = configureTexture(await loadTextureTry(BACK_BASE));
      uniforms.uBackMap.value = t;
      setStatus("Back loaded ✅", true);
    }catch(e){
      setInfo(String(e.message || e));
    }
  }

  $("frontFile").addEventListener("change", async (ev) => {
    const f = ev.target.files?.[0];
    if(!f) return;
    await setFrontFromFile(f);
  });

  $("heightFile").addEventListener("change", async (ev) => {
    const f = ev.target.files?.[0];
    if(!f) return;
    await setHeightFromFile(f);
  });

  $("holoToggle").addEventListener("change", () => {
    uniforms.uHolo.value = $("holoToggle").checked ? 1 : 0;
  });

  $("autoHeightToggle").addEventListener("change", async () => {
    uniforms.uAutoHeight.value = $("autoHeightToggle").checked ? 1 : 0;
    if(uniforms.uFrontMap.value && uniforms.uFrontMap.value.image && uniforms.uAutoHeight.value > 0.5){
      await regenerateAutoMaps();
    }
  });

  $("exportHeightBtn").addEventListener("click", () => exportCanvasTexture(uniforms.uHeightMap.value, "height-map.png"));
  $("exportFoilMaskBtn").addEventListener("click", () => exportCanvasTexture(uniforms.uFoilMask.value, "foil-mask.png"));

  function exportCanvasTexture(tex, filename){
    if(!tex || !tex.image) return;
    const img = tex.image;
    const a = document.createElement("a");
    if(img instanceof HTMLCanvasElement){
      a.href = img.toDataURL("image/png");
    }else{
      const c = document.createElement("canvas");
      c.width = img.width; c.height = img.height;
      c.getContext("2d").drawImage(img,0,0);
      a.href = c.toDataURL("image/png");
    }
    a.download = filename;
    a.click();
  }

  async function setFrontFromFile(file){
    setInfo("Loading front…");
    const url = URL.createObjectURL(file);
    try{
      const tex = configureTexture(await loadTextureTry(url));
      uniforms.uFrontMap.value = tex;
      setStatus(file.name, true);

      if($("autoHeightToggle").checked){
        await regenerateAutoMaps();
      }
    }catch(e){
      setStatus("Front failed ❌ " + (e.message||e), false);
    }finally{
      URL.revokeObjectURL(url);
    }
  }

  async function setHeightFromFile(file){
    setInfo("Loading height…");
    const url = URL.createObjectURL(file);
    try{
      const tex = configureHeightTexture(await loadTextureTry(url));
      uniforms.uHeightMap.value = tex;
      uniforms.uHasHeight.value = 1;

      if(!$("autoHeightToggle").checked){
        uniforms.uHasFoil.value = 0;
        uniforms.uFoilMask.value = null;
      }
      setStatus("Height loaded ✅", true);
    }catch(e){
      setStatus("Height failed ❌ " + (e.message||e), false);
    }finally{
      URL.revokeObjectURL(url);
    }
  }

  async function regenerateAutoMaps(){
    const frontTex = uniforms.uFrontMap.value;
    if(!frontTex || !frontTex.image) return;

    setInfo("Auto height…");
    let source = frontTex.image;

    if(source instanceof ImageBitmap){
      const c = document.createElement("canvas");
      c.width = source.width; c.height = source.height;
      c.getContext("2d").drawImage(source,0,0);
      source = c;
    }

    const { heightCanvas, foilCanvas } = generateHeightAndFoilFromFront(source, 1024);

    const hTex = new THREE.CanvasTexture(heightCanvas);
    configureHeightTexture(hTex);

    const fTex = new THREE.CanvasTexture(foilCanvas);
    configureHeightTexture(fTex);

    uniforms.uHeightMap.value = hTex;
    uniforms.uFoilMask.value = fTex;
    uniforms.uHasHeight.value = 1;
    uniforms.uHasFoil.value = 1;

    uniforms.uDisp.value = 0.030;
    uniforms.uBandFreq.value = 3.2;

    setStatus("Auto maps ✅", true);
  }

  async function showPresetsMenu(){
    const names = PRESETS.map((p,i)=> `${i+1}) ${p.name}`).join("\n");
    const choice = prompt(`Choose preset:\n\n${names}\n\nEnter 1-${PRESETS.length}`, "1");
    if(!choice) return;
    const idx = parseInt(choice,10)-1;
    if(idx < 0 || idx >= PRESETS.length) return;
    await applyPreset(PRESETS[idx]);
  }

  async function applyPreset(p){
    try{
      setInfo("Loading preset… " + p.name);
      const front = configureTexture(await loadTextureTry(p.frontBase));
      uniforms.uFrontMap.value = front;
      setStatus("Preset: " + p.name, true);
      if($("autoHeightToggle").checked){
        await regenerateAutoMaps();
      }
    }catch(e){
      setStatus("Preset failed ❌ " + (e.message||e), false);
    }
  }

  function resetAll(){
    $("frontFile").value = "";
    $("heightFile").value = "";
    uniforms.uFrontMap.value = fallbackFront;
    uniforms.uHeightMap.value = null;
    uniforms.uFoilMask.value = null;
    uniforms.uHasHeight.value = 0;
    uniforms.uHasFoil.value = 0;
    setStatus("Reset ✅", true);
  }

  function resize(){
    const w = window.innerWidth;
    const h = window.innerHeight;
    renderer.setSize(w, h, false);
    camera.aspect = w/h;
    camera.updateProjectionMatrix();
  }
  window.addEventListener("resize", resize, { passive:true });
  resize();

  const clock = new THREE.Clock();
  function tick(){
    uniforms.uTime.value = clock.getElapsedTime();
    controls.update();
    renderer.render(scene, camera);
    requestAnimationFrame(tick);
  }
  tick();

  (async function init(){
    setInfo("Loading back…");
    await loadBack();
    setStatus("Ready", true);
  })();
</script>
</body>
</html>
