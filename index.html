<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Card Viewer</title>
  <style>
    :root{
      --bg:#07080a;
      --panel: rgba(18,20,24,.78);
      --panel2: rgba(10,12,14,.60);
      --text:#e9eef7;
      --muted:#b4bccb;
      --stroke: rgba(255,255,255,.12);
      --radius:14px;
      --pad:12px;
      --shadow: 0 10px 30px rgba(0,0,0,.45);
    }
    html,body{height:100%; margin:0; background:var(--bg); color:var(--text); font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;}
    #c{display:block; width:100vw; height:100vh;}
    .topbar{
      position:fixed;
      left:12px; right:12px;
      top: max(12px, env(safe-area-inset-top));
      z-index:10;
      display:flex;
      gap:10px;
      align-items:center;
      flex-wrap:wrap;
      padding:10px;
      border:1px solid var(--stroke);
      background:var(--panel);
      border-radius:999px;
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
    }
    .chip, .btn, select{
      appearance:none;
      border:1px solid var(--stroke);
      background:rgba(255,255,255,.06);
      color:var(--text);
      border-radius:999px;
      padding:10px 12px;
      font-size:14px;
      line-height:1;
      display:inline-flex;
      align-items:center;
      gap:8px;
      max-width: 100%;
    }
    .btn{cursor:pointer}
    .btn:active{transform:translateY(1px)}
    .btn.primary{background:rgba(255,255,255,.08)}
    .titlechip{
      flex:1 1 auto;
      min-width: 180px;
      overflow:hidden;
      text-overflow:ellipsis;
      white-space:nowrap;
      max-width: 100%;
    }
    .burger{width:44px; justify-content:center; padding:10px;}
    .drawer{
      position:fixed;
      top: calc(max(12px, env(safe-area-inset-top)) + 70px);
      right:12px;
      width:min(360px, calc(100vw - 24px));
      max-height: calc(100vh - 140px);
      overflow:auto;
      border:1px solid var(--stroke);
      background:var(--panel);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
      padding: var(--pad);
      z-index:11;
      display:none;
    }
    .drawer.open{display:block;}
    .row{display:flex; gap:10px; align-items:center; flex-wrap:wrap}
    .row + .row{margin-top:10px}
    label{font-size:12px; color:var(--muted)}
    input[type="file"]{width:100%}
    .small{font-size:12px; color:var(--muted)}
    .toggle{
      display:flex; align-items:center; gap:10px;
      border:1px solid var(--stroke);
      background:rgba(255,255,255,.05);
      padding:10px 12px;
      border-radius: 12px;
      width:100%;
      box-sizing:border-box;
    }
    .toggle input{transform:scale(1.2)}
    .divider{height:1px; background:var(--stroke); margin:12px 0;}
    .footerhint{
      position:fixed;
      right:12px;
      top: calc(max(12px, env(safe-area-inset-top)) + 84px);
      z-index:9;
      opacity:.6;
      background:var(--panel2);
      border:1px solid var(--stroke);
      border-radius:999px;
      padding:10px 12px;
      font-size:12px;
      backdrop-filter: blur(10px);
      display:none;
    }
    @media (max-width: 520px){ .footerhint{display:block;} }
  </style>

  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
    }
  }
  </script>
</head>
<body>
  <canvas id="c"></canvas>

  <div class="topbar">
    <button class="btn burger" id="btnMenu" title="Menu">☰</button>
    <div class="chip titlechip" id="chipTitle">Starting…</div>
    <select id="preset" class="chip" title="Presets">
      <option value="">Presets…</option>
      <option value="rayquaza">Mega Rayquaza</option>
      <option value="blastoise">Mega Blastoise</option>
    </select>
    <button class="btn primary" id="btnReset">Reset</button>
  </div>

  <div class="footerhint">Drag to rotate · Pinch/scroll to zoom</div>

  <div class="drawer" id="drawer">
    <div class="row">
      <div style="flex:1 1 100%">
        <label>Front image (base color)</label>
        <input type="file" id="frontFile" accept="image/*" />
      </div>
    </div>

    <div class="row">
      <div style="flex:1 1 100%">
        <label>Optional: Height map (grayscale)</label>
        <input type="file" id="heightFile" accept="image/*" />
        <div class="small">If omitted, a height map is auto-generated from the front image.</div>
      </div>
    </div>

    <div class="row">
      <div class="toggle">
        <input type="checkbox" id="holoOn" checked />
        <div>
          <div><b>Holographic</b> (front only)</div>
          <div class="small">Wide bands + foil grain</div>
        </div>
      </div>
    </div>

    <div class="row">
      <div class="toggle">
        <input type="checkbox" id="autoHeight" checked />
        <div>
          <div><b>Auto Height</b></div>
          <div class="small">Image-guided relief + non-tiling micro-emboss</div>
        </div>
      </div>
    </div>

    <div class="divider"></div>

    <div class="row">
      <button class="btn" id="btnExportHeight" style="flex:1">Export Height</button>
      <button class="btn" id="btnExportFoil" style="flex:1">Export Foil Mask</button>
    </div>

    <div class="divider"></div>

    <div class="small">
      If it says “Missing: …” in the top bar, that file path is wrong or not committed.
    </div>
  </div>

<script type="module">
import * as THREE from "three";
import { OrbitControls } from "three/addons/controls/OrbitControls.js";

/* -----------------------------
   PATHS (MAKE SURE THESE FILES EXIST IN YOUR REPO)
----------------------------- */
const PATHS = {
  backDefault: "assets/pokemon_back.jpg",
  presets: {
    rayquaza: "assets/presets/mega-rayquaza-front.jpg",
    blastoise: "assets/presets/mega-blastoise-front.jpg"
  }
};

/* -----------------------------
   SETTINGS
----------------------------- */
const CARD = { width: 2.5, height: 3.5, radius: 0.14, thickness: 0.030, segments: 160 };
const FOIL = { strength: 1.25, bandWidth: 0.25, bandAngle: 0.68, flake: 0.65, grain: 1.0 };
const DISPLACE = { scale: 0.090, edgePin: 0.10, edgeSoft: 0.05 };
const AUTOH = { maxSize: 2048 };

const app = {};
const canvas = document.getElementById("c");

function setTitle(t){ document.getElementById("chipTitle").textContent = t; }
function clamp01(x){ return Math.max(0, Math.min(1, x)); }
function smoothstep(a,b,x){ const t=clamp01((x-a)/(b-a)); return t*t*(3-2*t); }
function lerp(a,b,t){ return a+(b-a)*t; }
function fade(t){ return t*t*(3-2*t); }

/* -----------------------------
   THREE
----------------------------- */
const renderer = new THREE.WebGLRenderer({ canvas, antialias:true });
renderer.setPixelRatio(Math.min(2, window.devicePixelRatio || 1));
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.outputColorSpace = THREE.SRGBColorSpace;

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x07080a);

const camera = new THREE.PerspectiveCamera(35, window.innerWidth/window.innerHeight, 0.1, 100);
camera.position.set(0, 0.15, 6.0);

const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.dampingFactor = 0.06;
controls.minDistance = 3.2;
controls.maxDistance = 10.0;
controls.target.set(0, 0, 0);

scene.add(new THREE.AmbientLight(0xffffff, 0.22));
const key = new THREE.DirectionalLight(0xffffff, 1.05); key.position.set(3,4,5); scene.add(key);
const fill = new THREE.DirectionalLight(0xbfd7ff, 0.45); fill.position.set(-4,1.5,3); scene.add(fill);
const rim = new THREE.DirectionalLight(0xffffff, 0.55); rim.position.set(-2,4,-6); scene.add(rim);

const floor = new THREE.Mesh(
  new THREE.PlaneGeometry(40,40),
  new THREE.MeshStandardMaterial({ color:0x0b0c0f, roughness:1, metalness:0 })
);
floor.rotation.x = -Math.PI/2;
floor.position.y = -2.5;
scene.add(floor);

/* -----------------------------
   GEOMETRY
----------------------------- */
function roundedRectShape(w,h,r){
  const s=new THREE.Shape();
  const x=-w/2,y=-h/2;
  s.moveTo(x+r,y);
  s.lineTo(x+w-r,y);
  s.quadraticCurveTo(x+w,y,x+w,y+r);
  s.lineTo(x+w,y+h-r);
  s.quadraticCurveTo(x+w,y+h,x+w-r,y+h);
  s.lineTo(x+r,y+h);
  s.quadraticCurveTo(x,y+h,x,y+h-r);
  s.lineTo(x,y+r);
  s.quadraticCurveTo(x,y,x+r,y);
  return s;
}
function makeRoundedPlaneGeometry(w,h,r,seg){
  const shape=roundedRectShape(w,h,r);
  const geom=new THREE.ShapeGeometry(shape, seg);
  geom.computeBoundingBox();
  const bb=geom.boundingBox;
  const size=new THREE.Vector2(bb.max.x-bb.min.x, bb.max.y-bb.min.y);
  const uv=[];
  const pos=geom.attributes.position;
  for(let i=0;i<pos.count;i++){
    const x=pos.getX(i), y=pos.getY(i);
    uv.push((x-bb.min.x)/size.x, (y-bb.min.y)/size.y);
  }
  geom.setAttribute("uv", new THREE.Float32BufferAttribute(uv,2));
  geom.computeVertexNormals();
  return geom;
}
function flipGeometryU(geom){
  const uv=geom.attributes.uv;
  for(let i=0;i<uv.count;i++) uv.setX(i, 1.0-uv.getX(i));
  uv.needsUpdate = true;
}

/* -----------------------------
   TEXTURES
----------------------------- */
function texFromImage(img,{srgb=true}={}){
  const tex=new THREE.Texture(img);
  tex.needsUpdate=true;
  tex.wrapS=tex.wrapT=THREE.ClampToEdgeWrapping;
  tex.generateMipmaps=true;
  tex.minFilter=THREE.LinearMipmapLinearFilter;
  tex.magFilter=THREE.LinearFilter;
  if (srgb) tex.colorSpace=THREE.SRGBColorSpace;
  return tex;
}
function texFromCanvas(c){
  const tex=new THREE.CanvasTexture(c);
  tex.needsUpdate=true;
  tex.wrapS=tex.wrapT=THREE.ClampToEdgeWrapping;
  tex.generateMipmaps=false;
  tex.minFilter=THREE.LinearFilter;
  tex.magFilter=THREE.LinearFilter;
  tex.colorSpace=THREE.NoColorSpace;
  tex.flipY=false; // important for height/mask alignment
  return tex;
}

async function loadImageURL(url){
  // HEAD check so we can report missing file paths clearly
  try{
    const res = await fetch(url, { method:"HEAD", cache:"no-store" });
    if(!res.ok) throw new Error(String(res.status));
  }catch(e){
    throw new Error("Missing: " + url);
  }
  return new Promise((resolve,reject)=>{
    const img=new Image();
    img.crossOrigin="anonymous";
    img.onload=()=>resolve(img);
    img.onerror=()=>reject(new Error("Failed image decode: " + url));
    img.src=url;
  });
}
async function loadImageFromFile(file){
  return new Promise((resolve,reject)=>{
    const url=URL.createObjectURL(file);
    const img=new Image();
    img.onload=()=>{ URL.revokeObjectURL(url); resolve(img); };
    img.onerror=(e)=>{ URL.revokeObjectURL(url); reject(e); };
    img.src=url;
  });
}

/* -----------------------------
   HEIGHT / FOIL GENERATION (same as before, trimmed)
----------------------------- */
function blurNFloat(src,w,h,r){
  let a=new Float32Array(src);
  let b=new Float32Array(src.length);
  const rad=2;
  for(let it=0;it<r;it++){
    for(let y=0;y<h;y++){
      for(let x=0;x<w;x++){
        let sum=0,c=0;
        for(let k=-rad;k<=rad;k++){
          const xx=Math.max(0,Math.min(w-1,x+k));
          sum+=a[y*w+xx]; c++;
        }
        b[y*w+x]=sum/c;
      }
    }
    for(let y=0;y<h;y++){
      for(let x=0;x<w;x++){
        let sum=0,c=0;
        for(let k=-rad;k<=rad;k++){
          const yy=Math.max(0,Math.min(h-1,y+k));
          sum+=b[yy*w+x]; c++;
        }
        a[y*w+x]=sum/c;
      }
    }
  }
  return a;
}
function sobelEdgeFloat(lum,w,h){
  const out=new Float32Array(w*h);
  for(let y=1;y<h-1;y++) for(let x=1;x<w-1;x++){
    const i=y*w+x;
    const a00=lum[(y-1)*w+(x-1)], a01=lum[(y-1)*w+x], a02=lum[(y-1)*w+(x+1)];
    const a10=lum[y*w+(x-1)],     a12=lum[y*w+(x+1)];
    const a20=lum[(y+1)*w+(x-1)], a21=lum[(y+1)*w+x], a22=lum[(y+1)*w+(x+1)];
    const gx=-a00-2*a10-a20 + a02+2*a12+a22;
    const gy=-a00-2*a01-a02 + a20+2*a21+a22;
    out[i]=clamp01(Math.sqrt(gx*gx+gy*gy));
  }
  let mx=1e-6; for(let i=0;i<out.length;i++) mx=Math.max(mx,out[i]);
  for(let i=0;i<out.length;i++) out[i]=out[i]/mx;
  return out;
}
function hash2(x,y){
  let n=x*374761393 + y*668265263;
  n=(n^(n>>13))*1274126177;
  return ((n^(n>>16))>>>0)/4294967295;
}
function valueNoise2D(x,y){
  const xi=Math.floor(x), yi=Math.floor(y);
  const xf=x-xi, yf=y-yi;
  const u=fade(xf), v=fade(yf);
  const a=hash2(xi,yi), b=hash2(xi+1,yi), c=hash2(xi,yi+1), d=hash2(xi+1,yi+1);
  return lerp(lerp(a,b,u), lerp(c,d,u), v);
}
function fbm2D(x,y,oct=5){
  let amp=0.5,f=1,sum=0;
  for(let i=0;i<oct;i++){ sum+=amp*valueNoise2D(x*f,y*f); f*=2; amp*=0.5; }
  return sum;
}
function ridgedFbm2D(x,y,oct=5){
  let amp=0.6,f=1,sum=0;
  for(let i=0;i<oct;i++){
    let n=valueNoise2D(x*f,y*f);
    n=1.0-Math.abs(n*2.0-1.0);
    sum+=amp*n;
    f*=2; amp*=0.5;
  }
  return sum;
}
function normalizeCanvasGrayscale(c, lo=0.02, hi=0.98){
  const ctx=c.getContext("2d",{willReadFrequently:true});
  const im=ctx.getImageData(0,0,c.width,c.height);
  const d=im.data;
  let mn=1e9,mx=-1e9;
  for(let i=0;i<d.length;i+=4){ const v=d[i]/255; mn=Math.min(mn,v); mx=Math.max(mx,v); }
  const a=mn+(mx-mn)*lo, b=mn+(mx-mn)*hi;
  const inv=1/Math.max(1e-6,(b-a));
  for(let i=0;i<d.length;i+=4){
    let v=d[i]/255;
    v=clamp01((v-a)*inv);
    const q=(v*255)|0;
    d[i]=d[i+1]=d[i+2]=q;
  }
  ctx.putImageData(im,0,0);
}
function generateHeightFromFront(img){
  const w0=img.naturalWidth||img.width, h0=img.naturalHeight||img.height;
  const s=Math.min(1, AUTOH.maxSize/Math.max(w0,h0));
  const w=Math.max(1, Math.round(w0*s)), h=Math.max(1, Math.round(h0*s));
  const c=document.createElement("canvas"); c.width=w; c.height=h;
  const ctx=c.getContext("2d",{willReadFrequently:true});
  ctx.drawImage(img,0,0,w,h);
  const im=ctx.getImageData(0,0,w,h); const d=im.data;

  const lum=new Float32Array(w*h), sat=new Float32Array(w*h);
  for(let i=0,p=0;p<lum.length;p++,i+=4){
    const r=d[i]/255,g=d[i+1]/255,b=d[i+2]/255;
    const mx=Math.max(r,g,b), mn=Math.min(r,g,b);
    lum[p]=0.2126*r+0.7152*g+0.0722*b;
    sat[p]=(mx-mn)/(mx+1e-6);
  }

  const base=blurNFloat(lum,w,h,12);
  const edge=sobelEdgeFloat(blurNFloat(lum,w,h,2), w,h);

  const terrain=new Float32Array(w*h);
  for(let i=0;i<terrain.length;i++){
    terrain[i]=clamp01(base[i]*0.85 + edge[i]*0.95 + sat[i]*0.25);
  }

  const gx=new Float32Array(w*h), gy=new Float32Array(w*h);
  for(let y=1;y<h-1;y++) for(let x=1;x<w-1;x++){
    const i=y*w+x;
    gx[i]=(terrain[i+1]-terrain[i-1])*0.5;
    gy[i]=(terrain[i+w]-terrain[i-w])*0.5;
  }

  const out=ctx.createImageData(w,h);

  const MICRO_SCALE=220.0, MICRO_STRENGTH=0.55, MACRO_STRENGTH=0.95;
  const RIDGE=0.75, EDGE_BOOST=0.55;

  for(let y=0;y<h;y++) for(let x=0;x<w;x++){
    const i=y*w+x;
    const gxn=gx[i], gyn=gy[i];
    const len=Math.max(1e-6, Math.sqrt(gxn*gxn+gyn*gyn));
    const px=-gyn/len, py=gxn/len;

    const nx=x/MICRO_SCALE, ny=y/MICRO_SCALE;
    const warp1=fbm2D(nx*1.2, ny*1.2, 4)-0.5;
    const warp2=fbm2D(nx*2.1+7.1, ny*2.1+3.7, 4)-0.5;
    const wx=nx+(warp1*0.55+warp2*0.35)+px*(edge[i]*0.020);
    const wy=ny+(warp2*0.55+warp1*0.35)+py*(edge[i]*0.020);

    const micro=ridgedFbm2D(wx*3.0, wy*3.0, 5);
    const macro=terrain[i];
    const crinkle=ridgedFbm2D(wx*0.9+macro*0.8, wy*0.9+macro*0.8, 4);

    let hgt = MACRO_STRENGTH*macro + MICRO_STRENGTH*(micro*0.85 + crinkle*RIDGE*0.35) + edge[i]*EDGE_BOOST;
    hgt=clamp01(hgt);

    const detail=clamp01(edge[i]*1.25 + sat[i]*0.35);
    hgt=clamp01((hgt*0.75 + hgt*hgt*0.35) - detail*0.08);

    const v=(hgt*255)|0;
    const o=i*4;
    out.data[o]=out.data[o+1]=out.data[o+2]=v;
    out.data[o+3]=255;
  }

  ctx.putImageData(out,0,0);
  normalizeCanvasGrayscale(c,0.02,0.98);
  return c;
}
function generateFoilMask(img){
  const w0=img.naturalWidth||img.width, h0=img.naturalHeight||img.height;
  const s=Math.min(1, AUTOH.maxSize/Math.max(w0,h0));
  const w=Math.max(1, Math.round(w0*s)), h=Math.max(1, Math.round(h0*s));
  const c=document.createElement("canvas"); c.width=w; c.height=h;
  const ctx=c.getContext("2d",{willReadFrequently:true});
  ctx.drawImage(img,0,0,w,h);
  const im=ctx.getImageData(0,0,w,h); const d=im.data;

  const lum=new Float32Array(w*h), sat=new Float32Array(w*h);
  for(let i=0,p=0;p<lum.length;p++,i+=4){
    const r=d[i]/255,g=d[i+1]/255,b=d[i+2]/255;
    const mx=Math.max(r,g,b), mn=Math.min(r,g,b);
    lum[p]=0.2126*r+0.7152*g+0.0722*b;
    sat[p]=(mx-mn)/(mx+1e-6);
  }
  const edge=sobelEdgeFloat(blurNFloat(lum,w,h,2), w,h);
  const smooth=blurNFloat(lum,w,h,10);

  const out=ctx.createImageData(w,h);
  for(let y=0;y<h;y++) for(let x=0;x<w;x++){
    const i=y*w+x;
    let m=0.55*(1.0-Math.abs(smooth[i]-0.55)) + 0.65*edge[i] + 0.50*sat[i];
    m=clamp01((m-0.45)*1.9);
    const v=(m*255)|0;
    const o=i*4;
    out.data[o]=out.data[o+1]=out.data[o+2]=v;
    out.data[o+3]=255;
  }
  ctx.putImageData(out,0,0);
  normalizeCanvasGrayscale(c,0.05,0.98);
  return c;
}

/* -----------------------------
   HOLO MATERIAL
----------------------------- */
function makeHoloFilmMaterial(baseTex, heightTex, maskTex){
  const uniforms={
    uBase:{value:baseTex},
    uHeight:{value:heightTex},
    uMask:{value:maskTex},
    uStrength:{value:FOIL.strength},
    uBandWidth:{value:FOIL.bandWidth},
    uBandAngle:{value:FOIL.bandAngle},
    uFlake:{value:FOIL.flake},
    uGrain:{value:FOIL.grain},
    uDispScale:{value:DISPLACE.scale},
    uEdgePin:{value:DISPLACE.edgePin},
    uEdgeSoft:{value:DISPLACE.edgeSoft},
    uTime:{value:0}
  };

  const vtx=`
    varying vec2 vUv;
    varying vec3 vN;
    varying vec3 vV;
    uniform sampler2D uHeight;
    uniform float uDispScale;
    uniform float uEdgePin;
    uniform float uEdgeSoft;
    void main(){
      vUv=uv;
      vec3 n=normalize(normalMatrix*normal);
      vN=n;
      float e=min(min(vUv.x,1.0-vUv.x), min(vUv.y,1.0-vUv.y));
      float pin=smoothstep(uEdgePin, uEdgePin+uEdgeSoft, e);
      float h=texture2D(uHeight, vUv).r;
      vec3 displaced = position + normal * ((h*pin)*uDispScale);
      vec4 mv=modelViewMatrix*vec4(displaced,1.0);
      vV=normalize(-mv.xyz);
      gl_Position=projectionMatrix*mv;
    }
  `;

  const frag=`
    varying vec2 vUv;
    varying vec3 vN;
    varying vec3 vV;
    uniform sampler2D uBase;
    uniform sampler2D uHeight;
    uniform sampler2D uMask;
    uniform float uStrength;
    uniform float uBandWidth;
    uniform float uBandAngle;
    uniform float uFlake;
    uniform float uGrain;
    uniform float uTime;
    float hash(vec2 p){
      p=fract(p*vec2(123.34,456.21));
      p+=dot(p,p+45.32);
      return fract(p.x*p.y);
    }
    float flake(vec2 uv){
      vec2 g=uv*420.0;
      vec2 id=floor(g);
      vec2 f=fract(g);
      float h=hash(id);
      float d=length(f-0.5);
      float s=smoothstep(0.22,0.0,d);
      return s*step(0.75,h);
    }
    void main(){
      vec3 base=texture2D(uBase, vUv).rgb;
      float h=texture2D(uHeight, vUv).r;
      float m=texture2D(uMask, vUv).r;
      float ridge=smoothstep(0.35,0.92,h);

      float ndv=clamp(dot(normalize(vN), normalize(vV)), 0.0, 1.0);
      float fres=pow(1.0-ndv, 2.0);

      vec2 uv=vUv;
      float ang=uBandAngle;
      mat2 R=mat2(cos(ang),-sin(ang), sin(ang),cos(ang));
      vec2 tuv=R*(uv-0.5);

      float band = sin((tuv.x+tuv.y)*(6.2831853/max(1e-4,uBandWidth)) + uTime*0.25);
      band=0.5+0.5*band;

      vec3 spectrum=vec3(
        0.55+0.45*sin(6.2831853*(band+fres*0.20)),
        0.55+0.45*sin(6.2831853*(band+fres*0.20+0.33)),
        0.55+0.45*sin(6.2831853*(band+fres*0.20+0.66))
      );

      float grain=(h*0.6 + ridge*0.4);
      float sparkle=flake(uv + h*0.02 + uTime*0.01)*uFlake;

      float a=clamp((0.20+0.95*fres)*uStrength*(0.70+0.55*ridge)*m, 0.0, 1.0);
      vec3 film=spectrum*(0.55+0.65*grain*uGrain) + sparkle;

      vec3 outc=1.0 - (1.0-base)*(1.0-film*a);
      gl_FragColor=vec4(outc,1.0);
    }
  `;

  return new THREE.ShaderMaterial({ uniforms, vertexShader:vtx, fragmentShader:frag });
}

/* -----------------------------
   BUILD CARD
----------------------------- */
function buildCard(frontTex, backTex, heightTex, foilTex){
  if (app.cardGroup){
    scene.remove(app.cardGroup);
    app.cardGroup.traverse(o=>{
      if(o.geometry) o.geometry.dispose();
      if(o.material){
        if(Array.isArray(o.material)) o.material.forEach(m=>m.dispose());
        else o.material.dispose();
      }
    });
  }

  const g=new THREE.Group();
  app.cardGroup=g;

  const frontGeo=makeRoundedPlaneGeometry(CARD.width,CARD.height,CARD.radius,CARD.segments);
  const backGeo=makeRoundedPlaneGeometry(CARD.width,CARD.height,CARD.radius,CARD.segments);
  flipGeometryU(backGeo);

  const frontMat=new THREE.MeshStandardMaterial({ map:frontTex, roughness:0.46, metalness:0.10 });
  const backMat =new THREE.MeshStandardMaterial({ map:backTex,  roughness:0.62, metalness:0.02 });

  const front=new THREE.Mesh(frontGeo, frontMat);
  const back =new THREE.Mesh(backGeo,  backMat);

  front.position.z = CARD.thickness/2;
  back.position.z  = -CARD.thickness/2;
  back.rotation.y = Math.PI;

  const edge=new THREE.Mesh(
    new THREE.BoxGeometry(CARD.width,CARD.height,CARD.thickness),
    new THREE.MeshStandardMaterial({ color:0x1a1c21, roughness:0.95, metalness:0.0 })
  );

  g.add(front); g.add(back); g.add(edge);

  const film=new THREE.Mesh(frontGeo.clone(), makeHoloFilmMaterial(frontTex,heightTex,foilTex));
  film.position.z = CARD.thickness/2 + 0.0008;
  film.renderOrder = 10;
  film.visible = document.getElementById("holoOn").checked;
  g.add(film);

  app.front=front; app.back=back; app.film=film;
  scene.add(g);
}

/* -----------------------------
   PLACEHOLDER SO WE ALWAYS RENDER
----------------------------- */
function makePlaceholderCanvas(w=1024,h=1434,text="Upload a front image"){
  const c=document.createElement("canvas"); c.width=w; c.height=h;
  const ctx=c.getContext("2d");
  ctx.fillStyle="#6b6f78"; ctx.fillRect(0,0,w,h);
  ctx.fillStyle="rgba(0,0,0,.25)"; ctx.fillRect(0,0,w,120);
  ctx.fillStyle="#fff"; ctx.font="bold 48px system-ui";
  ctx.fillText("Card Viewer", 36, 78);
  ctx.font="28px system-ui";
  ctx.fillText(text, 36, 160);
  return c;
}
function downloadCanvas(canvas, filename){
  canvas.toBlob((blob)=>{
    const a=document.createElement("a");
    a.href=URL.createObjectURL(blob);
    a.download=filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    setTimeout(()=>URL.revokeObjectURL(a.href), 1000);
  }, "image/png");
}

/* -----------------------------
   UI
----------------------------- */
const drawer=document.getElementById("drawer");
document.getElementById("btnMenu").addEventListener("click", ()=>drawer.classList.toggle("open"));

document.getElementById("holoOn").addEventListener("change", (e)=>{
  if(app.film) app.film.visible = e.target.checked;
});

document.getElementById("autoHeight").addEventListener("change", ()=>{
  if(app.frontImg && document.getElementById("autoHeight").checked){
    setTitle("Auto height…");
    app.heightCanvas=generateHeightFromFront(app.frontImg);
    app.heightTex=texFromCanvas(app.heightCanvas);
    app.foilCanvas=generateFoilMask(app.frontImg);
    app.foilTex=texFromCanvas(app.foilCanvas);
    buildCard(app.frontTex, app.backTex, app.heightTex, app.foilTex);
    setTitle("Ready");
  }
});

document.getElementById("frontFile").addEventListener("change", async (e)=>{
  const f=e.target.files?.[0]; if(!f) return;
  setTitle("Loading front…");
  const img=await loadImageFromFile(f);
  app.frontImg=img;
  app.frontTex=texFromImage(img,{srgb:true});
  app.frontTex.flipY=true;

  if(document.getElementById("autoHeight").checked){
    setTitle("Auto height…");
    app.heightCanvas=generateHeightFromFront(img);
    app.heightTex=texFromCanvas(app.heightCanvas);
    app.foilCanvas=generateFoilMask(img);
    app.foilTex=texFromCanvas(app.foilCanvas);
  } else if(!app.heightTex){
    app.heightCanvas=generateHeightFromFront(img);
    app.heightTex=texFromCanvas(app.heightCanvas);
    app.foilCanvas=generateFoilMask(img);
    app.foilTex=texFromCanvas(app.foilCanvas);
  }

  buildCard(app.frontTex, app.backTex, app.heightTex, app.foilTex);
  setTitle(f.name);
});

document.getElementById("heightFile").addEventListener("change", async (e)=>{
  const f=e.target.files?.[0]; if(!f) return;
  setTitle("Loading height…");
  const img=await loadImageFromFile(f);

  const c=document.createElement("canvas");
  const w0=img.naturalWidth||img.width, h0=img.naturalHeight||img.height;
  const s=Math.min(1, AUTOH.maxSize/Math.max(w0,h0));
  c.width=Math.round(w0*s); c.height=Math.round(h0*s);
  const ctx=c.getContext("2d",{willReadFrequently:true});
  ctx.drawImage(img,0,0,c.width,c.height);

  const im=ctx.getImageData(0,0,c.width,c.height);
  const d=im.data;
  for(let i=0;i<d.length;i+=4){
    const v=(0.2126*d[i]+0.7152*d[i+1]+0.0722*d[i+2])|0;
    d[i]=d[i+1]=d[i+2]=v;
  }
  ctx.putImageData(im,0,0);
  normalizeCanvasGrayscale(c,0.02,0.98);

  app.heightCanvas=c;
  app.heightTex=texFromCanvas(c);

  if(app.frontImg){
    app.foilCanvas=generateFoilMask(app.frontImg);
    app.foilTex=texFromCanvas(app.foilCanvas);
  }
  buildCard(app.frontTex, app.backTex, app.heightTex, app.foilTex);
  setTitle("Height loaded");
});

document.getElementById("btnExportHeight").addEventListener("click", ()=>{
  if(app.heightCanvas) downloadCanvas(app.heightCanvas, "height.png");
});
document.getElementById("btnExportFoil").addEventListener("click", ()=>{
  if(app.foilCanvas) downloadCanvas(app.foilCanvas, "foil-mask.png");
});

document.getElementById("preset").addEventListener("change", async (e)=>{
  const v=e.target.value; if(!v) return;
  try{
    setTitle("Loading preset…");
    const img=await loadImageURL(PATHS.presets[v]);
    app.frontImg=img;
    app.frontTex=texFromImage(img,{srgb:true}); app.frontTex.flipY=true;
    app.heightCanvas=generateHeightFromFront(img);
    app.heightTex=texFromCanvas(app.heightCanvas);
    app.foilCanvas=generateFoilMask(img);
    app.foilTex=texFromCanvas(app.foilCanvas);
    buildCard(app.frontTex, app.backTex, app.heightTex, app.foilTex);
    setTitle(v==="rayquaza" ? "Mega Rayquaza" : "Mega Blastoise");
  }catch(err){
    setTitle(String(err.message || err));
  } finally {
    e.target.value="";
  }
});

document.getElementById("btnReset").addEventListener("click", ()=>{
  startDefaultLoad();
  drawer.classList.remove("open");
});

/* -----------------------------
   DEFAULT LOAD (NON-BLOCKING)
----------------------------- */
function startDefaultLoad(){
  // Always render immediately with placeholder (so you never see a blank screen)
  const ph = makePlaceholderCanvas();
  app.frontImg = ph;
  app.frontTex = texFromCanvas(ph); app.frontTex.colorSpace = THREE.SRGBColorSpace; app.frontTex.flipY = false;
  app.heightCanvas = ph;
  app.heightTex = texFromCanvas(ph);
  app.foilCanvas = ph;
  app.foilTex = texFromCanvas(ph);

  // Temporary back if missing
  const backPh = makePlaceholderCanvas(1024,1434,"Back");
  app.backTex = texFromCanvas(backPh); app.backTex.colorSpace = THREE.SRGBColorSpace; app.backTex.flipY=false;

  buildCard(app.frontTex, app.backTex, app.heightTex, app.foilTex);
  setTitle("Loading…");

  // Now load real back and preset asynchronously
  (async ()=>{
    try{
      const backImg = await loadImageURL(PATHS.backDefault);
      app.backTex = texFromImage(backImg,{srgb:true}); app.backTex.flipY=true;
      buildCard(app.frontTex, app.backTex, app.heightTex, app.foilTex);
    }catch(err){
      setTitle(String(err.message || err));
      // keep placeholder back
    }
  })();

  (async ()=>{
    try{
      const img = await loadImageURL(PATHS.presets.rayquaza);
      app.frontImg=img;
      app.frontTex=texFromImage(img,{srgb:true}); app.frontTex.flipY=true;
      app.heightCanvas=generateHeightFromFront(img);
      app.heightTex=texFromCanvas(app.heightCanvas);
      app.foilCanvas=generateFoilMask(img);
      app.foilTex=texFromCanvas(app.foilCanvas);
      buildCard(app.frontTex, app.backTex, app.heightTex, app.foilTex);
      setTitle("Mega Rayquaza");
    }catch(err){
      // If preset missing, don't stall; show helpful error
      setTitle(String(err.message || err));
    }
  })();
}

startDefaultLoad();

/* -----------------------------
   LOOP
----------------------------- */
let t0=performance.now();
function animate(){
  requestAnimationFrame(animate);
  const t=(performance.now()-t0)/1000;
  controls.update();
  if(app.film?.material?.uniforms?.uTime) app.film.material.uniforms.uTime.value=t;
  renderer.render(scene,camera);
}
animate();

window.addEventListener("resize", ()=>{
  renderer.setSize(window.innerWidth, window.innerHeight);
  camera.aspect=window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
});
</script>
</body>
</html>
