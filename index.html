<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Card Viewer — Realistic Foil + Contour Height</title>

  <style>
    :root { color-scheme: dark; }
    html, body { margin: 0; height: 100%; overflow: hidden; background: #070a10; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; }
    canvas { display: block; }

    :root{
      --sat: env(safe-area-inset-top);
      --sar: env(safe-area-inset-right);
      --sab: env(safe-area-inset-bottom);
      --sal: env(safe-area-inset-left);
    }

    #ui {
      position: fixed;
      top: calc(10px + var(--sat));
      left: calc(10px + var(--sal));
      z-index: 10;

      color: #fff;
      background: rgba(0,0,0,.55);
      border: 1px solid rgba(255,255,255,.10);
      padding: 10px;
      border-radius: 14px;
      backdrop-filter: blur(10px);
      box-shadow: 0 10px 30px rgba(0,0,0,.35);

      width: min(460px, calc(100vw - 20px - var(--sal) - var(--sar)));
      max-height: calc(100vh - 20px - var(--sat) - var(--sab));
    }

    #uiHeader { display:flex; align-items:center; justify-content:space-between; gap:10px; }
    #uiTitle { display:flex; align-items:center; gap:10px; min-width:0; }
    #uiTitle .pill { max-width: 270px; overflow:hidden; text-overflow: ellipsis; white-space: nowrap; }
    #uiBody {
      margin-top: 10px;
      display: grid;
      gap: 10px;
      overflow: auto;
      -webkit-overflow-scrolling: touch;
      padding-right: 4px;
      max-height: calc(100vh - 90px - var(--sat) - var(--sab));
    }
    #ui.collapsed #uiBody { display:none; }

    label { font-size: 12px; opacity: .95; display:grid; gap:6px; }
    small { opacity:.75; line-height:1.25; }

    input[type="file"], select {
      width: 100%;
      padding: 8px 10px;
      border-radius: 10px;
      background: rgba(255,255,255,.06);
      border: 1px solid rgba(255,255,255,.12);
      color: #fff;
      font-size: 12px;
    }

    input[type="range"] { width: 210px; }

    .row { display:grid; grid-template-columns: 1fr auto; gap:10px; align-items:center; }
    .row3 { display:grid; grid-template-columns: 1fr 1fr 1fr; gap:10px; }

    button {
      appearance:none;
      border: 1px solid rgba(255,255,255,.16);
      background: rgba(255,255,255,.08);
      color: #fff;
      padding: 8px 10px;
      border-radius: 10px;
      cursor:pointer;
      font-size: 12px;
      white-space: nowrap;
    }
    button:active { transform: translateY(1px); }
    button.secondary { background: rgba(255,255,255,.05); }
    button.danger { border-color: rgba(255,80,80,.30); }

    .pill {
      font-size: 11px; opacity: .9;
      background: rgba(255,255,255,.08);
      border: 1px solid rgba(255,255,255,.10);
      padding: 4px 8px; border-radius: 999px;
    }

    #status {
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      font-size: 11px;
      white-space: pre-wrap;
      background: rgba(255,255,255,.06);
      border: 1px solid rgba(255,255,255,.08);
      padding: 8px 10px;
      border-radius: 10px;
      max-height: 120px;
      overflow: auto;
      line-height: 1.25;
    }

    #presetThumbs { display:flex; gap:8px; flex-wrap:wrap; }
    .thumbBtn {
      width: 56px; height: 80px;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      overflow:hidden;
      padding:0;
      position:relative;
    }
    .thumbBtn img { width:100%; height:100%; object-fit:cover; display:block; }
    .thumbBtn span {
      position:absolute;
      bottom:4px; left:4px; right:4px;
      font-size:10px;
      padding:2px 6px;
      border-radius:999px;
      background: rgba(0,0,0,.55);
      border: 1px solid rgba(255,255,255,.10);
      overflow:hidden; text-overflow:ellipsis; white-space:nowrap;
      opacity:.95;
    }

    #hint { display:flex; gap:10px; flex-wrap:wrap; align-items:center; }
  </style>

  <script type="importmap">
    {
      "imports": {
        "three": "./libs/three.module.js",
        "three/addons/": "./libs/examples/jsm/"
      }
    }
  </script>
</head>

<body>
  <div id="ui" class="collapsed">
    <div id="uiHeader">
      <div id="uiTitle">
        <button id="toggleUiBtn" title="Toggle UI">☰</button>
        <span class="pill" id="titlePill">Card Viewer</span>
      </div>
      <div style="display:flex; gap:8px;">
        <button id="exportBtn" class="secondary">Export</button>
        <button id="resetBtn" class="secondary">Reset</button>
      </div>
    </div>

    <div id="uiBody">
      <div id="status">Loading…</div>

      <label>Preset cards (assets/cards/)
        <select id="presetSelect"></select>
      </label>
      <div id="presetThumbs"></div>

      <label>Front image (JPG/PNG)
        <input id="frontInput" type="file" accept="image/jpeg,image/png" />
      </label>

      <div class="row3">
        <button id="regenAllBtn">Regen height+foil</button>
        <button id="regenFoilBtn" class="secondary">Regen foil mask</button>
        <button id="clearMapsBtn" class="danger">Clear maps</button>
      </div>

      <label>Height map override (optional grayscale JPG/PNG)
        <input id="heightInput" type="file" accept="image/jpeg,image/png" />
      </label>

      <label>Foil mask override (optional, white=foil black=no-foil)
        <input id="maskInput" type="file" accept="image/jpeg,image/png" />
      </label>

      <div class="row">
        <label style="margin:0;">Relief (bump)</label>
        <input id="bumpSlider" type="range" min="0" max="0.12" step="0.001" value="0.095" />
      </div>

      <div class="row">
        <label style="margin:0;">Holo strength</label>
        <input id="holoSlider" type="range" min="0" max="1.6" step="0.01" value="1.15" />
      </div>

      <div class="row">
        <label style="margin:0;">Holo reacts to height</label>
        <input id="holoReliefSlider" type="range" min="0" max="3.5" step="0.01" value="2.60" />
      </div>

      <div class="row">
        <label style="margin:0;">Holo band width (wider)</label>
        <!-- lower range = wider bands -->
        <input id="bandSlider" type="range" min="2" max="70" step="1" value="12" />
      </div>

      <div class="row">
        <label style="margin:0;">Sparkle</label>
        <input id="sparkleSlider" type="range" min="0" max="1.2" step="0.01" value="1.00" />
      </div>

      <div id="hint">
        <span class="pill">Back: assets/pokemon-back.jpg</span>
        <span class="pill">Displacement: automatic</span>
        <span class="pill">Drag rotate • Scroll zoom • Right-drag pan</span>
      </div>

      <small>
        Auto height is generated as contour grooves (like real card texture maps). Foil mask is auto-generated to favor art/highlights and suppress text-heavy areas.
      </small>
    </div>
  </div>

  <script type="module">
    import * as THREE from "three";
    import { OrbitControls } from "three/addons/controls/OrbitControls.js";

    // ----------------------------
    // REALISM TUNING
    // ----------------------------
    const thickness = 0.0022;         // thinner card edge (more realistic)
    const cornerRadius = 0.045;

    const DISP_SCALE = 0.030;         // lower than before: avoids rubber-sheet waves
    const DISP_CLAMP = 0.82;          // clamp height intensity for displacement
    const FILM_LIFT  = 0.00055;

    const EDGE_FADE_FRAC = 0.12;      // strong border pin (kills hard bevel ridge)

    const AUTOH = {
      maxSize: 1024,
      FREQ: 44.0,          // contour density (higher = more grooves)
      LINE_THICK: 0.10,    // groove thickness
      WARP: 12.0,          // flow around shapes
      NOISE: 0.40,         // breaks uniformity (non tiling)
      EDGE_BOOST: 0.95,    // emphasize features
      SMOOTH_PASSES: 11    // bigger terrain = nicer contours
    };

    // ---------- Logger ----------
    const statusEl = document.getElementById("status");
    const log = (m) => statusEl.textContent = m + "\n" + statusEl.textContent;

    window.addEventListener("error", (e) => log("JS ERROR ❌ " + (e.message || e.error || e)));
    window.addEventListener("unhandledrejection", (e) => log("PROMISE ERROR ❌ " + (e.reason?.message || e.reason || e)));

    // ---------- UI collapse ----------
    const ui = document.getElementById("ui");
    document.getElementById("toggleUiBtn").addEventListener("click", () => ui.classList.toggle("collapsed"));

    // ---------- WebGL check ----------
    {
      const c = document.createElement("canvas");
      const gl = c.getContext("webgl") || c.getContext("experimental-webgl");
      if (!gl) { alert("WebGL not available"); throw new Error("WebGL not available"); }
      log("WebGL: available ✅");
    }

    // ---------- Renderer ----------
    const renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    document.body.appendChild(renderer.domElement);

    // ---------- Scene / camera ----------
    const scene = new THREE.Scene();
    scene.fog = new THREE.Fog(0x070a10, 2.5, 10);

    const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.01, 100);
    camera.position.set(0, 0.35, 1.35);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.06;
    controls.minDistance = 0.6;
    controls.maxDistance = 3.0;
    controls.target.set(0, 0.05, 0);

    // ---------- Lights (slightly more "studio") ----------
    scene.add(new THREE.AmbientLight(0xffffff, 0.42));
    const key = new THREE.DirectionalLight(0xffffff, 1.45); key.position.set(1.6, 2.2, 1.4); scene.add(key);
    const fill = new THREE.DirectionalLight(0xffffff, 0.70); fill.position.set(-1.8, 1.0, 1.4); scene.add(fill);
    const rim  = new THREE.DirectionalLight(0xaad8ff, 0.80); rim.position.set(0.0, 2.2, -2.3); scene.add(rim);

    // ---------- Card dimensions ----------
    const cardWidth = 0.63;
    const cardHeight = 0.88;

    function roundedRectShape(w, h, r) {
      const x = -w/2, y = -h/2;
      const s = new THREE.Shape();
      const rr = Math.min(r, w/2, h/2);
      s.moveTo(x + rr, y);
      s.lineTo(x + w - rr, y); s.quadraticCurveTo(x + w, y, x + w, y + rr);
      s.lineTo(x + w, y + h - rr); s.quadraticCurveTo(x + w, y + h, x + w - rr, y + h);
      s.lineTo(x + rr, y + h); s.quadraticCurveTo(x, y + h, x, y + h - rr);
      s.lineTo(x, y + rr); s.quadraticCurveTo(x, y, x + rr, y);
      return s;
    }

    function extrudeSidesOnly(shape) {
      const full = new THREE.ExtrudeGeometry(shape, {
        depth: thickness,
        bevelEnabled: false,
        curveSegments: 28
      });
      full.translate(0, 0, -thickness/2);
      full.computeVertexNormals();

      const g = full.toNonIndexed();
      const pos = g.attributes.position;
      const nor = g.attributes.normal;

      const keptPos = [];
      const keptNor = [];

      for (let i = 0; i < pos.count; i += 3) {
        const nz = (nor.getZ(i) + nor.getZ(i+1) + nor.getZ(i+2)) / 3;
        if (Math.abs(nz) > 0.6) continue; // remove caps
        for (let k = 0; k < 3; k++) {
          keptPos.push(pos.getX(i+k), pos.getY(i+k), pos.getZ(i+k));
          keptNor.push(nor.getX(i+k), nor.getY(i+k), nor.getZ(i+k));
        }
      }

      const out = new THREE.BufferGeometry();
      out.setAttribute("position", new THREE.Float32BufferAttribute(keptPos, 3));
      out.setAttribute("normal", new THREE.Float32BufferAttribute(keptNor, 3));
      return out;
    }

    function makeRoundedFaceGeometry() {
      const shape = roundedRectShape(cardWidth, cardHeight, cornerRadius);
      const g = new THREE.ShapeGeometry(shape, 150);
      g.computeBoundingBox();
      const bb = g.boundingBox;
      const size = new THREE.Vector3();
      bb.getSize(size);

      const pos = g.attributes.position;
      const uv = [];
      for (let i = 0; i < pos.count; i++) {
        const x = pos.getX(i);
        const y = pos.getY(i);
        uv.push((x - bb.min.x) / size.x, (y - bb.min.y) / size.y);
      }
      g.setAttribute("uv", new THREE.Float32BufferAttribute(uv, 2));
      g.computeVertexNormals();
      return g;
    }

    const shape = roundedRectShape(cardWidth, cardHeight, cornerRadius);
    const sideGeom = extrudeSidesOnly(shape);
    const faceGeom = makeRoundedFaceGeometry();

    // ---------- Materials / textures ----------
    const loader = new THREE.TextureLoader();

    const edgeMat = new THREE.MeshStandardMaterial({
      color: 0x20242d,
      roughness: 0.95,
      metalness: 0.0
    });

    const permanentBack = loader.load(
      "./assets/pokemon-back.jpg",
      () => log("Back texture loaded ✅"),
      undefined,
      () => log("Back texture failed ❌ Check assets/pokemon-back.jpg (case sensitive)")
    );
    permanentBack.colorSpace = THREE.SRGBColorSpace;
    permanentBack.anisotropy = 8;
    permanentBack.flipY = true;

    const defaultFront = loader.load(
      "https://threejs.org/examples/textures/uv_grid_opengl.jpg",
      () => log("Default front loaded ✅")
    );
    defaultFront.colorSpace = THREE.SRGBColorSpace;
    defaultFront.anisotropy = 8;
    defaultFront.flipY = false;

    // 1x1 defaults
    const defaultHeight = new THREE.DataTexture(new Uint8Array([0]), 1, 1, THREE.RedFormat);
    defaultHeight.colorSpace = THREE.NoColorSpace;
    defaultHeight.flipY = true;
    defaultHeight.needsUpdate = true;

    const defaultMask = new THREE.DataTexture(new Uint8Array([255]), 1, 1, THREE.RedFormat);
    defaultMask.colorSpace = THREE.NoColorSpace;
    defaultMask.flipY = true;
    defaultMask.needsUpdate = true;

    const frontMat = new THREE.MeshStandardMaterial({
      map: defaultFront,
      roughness: 0.52,
      metalness: 0.07,
      bumpMap: defaultHeight,
      bumpScale: parseFloat(document.getElementById("bumpSlider").value),
      displacementMap: defaultHeight,
      displacementScale: DISP_SCALE,
      displacementBias: 0.0
    });

    const backMat = new THREE.MeshStandardMaterial({
      map: permanentBack,
      roughness: 0.65,
      metalness: 0.02
    });

    // ---------- Card assembly ----------
    const cardGroup = new THREE.Group();
    scene.add(cardGroup);

    cardGroup.add(new THREE.Mesh(sideGeom, edgeMat));

    const Z_FACE = thickness/2 + 0.0007;

    const frontMesh = new THREE.Mesh(faceGeom, frontMat);
    frontMesh.position.z = Z_FACE;
    cardGroup.add(frontMesh);

    const backMesh = new THREE.Mesh(faceGeom, backMat);
    backMesh.rotation.y = Math.PI;
    backMesh.position.z = -Z_FACE;
    cardGroup.add(backMesh);

    cardGroup.rotation.x = -0.08;
    cardGroup.rotation.y = 0.55;

    // Ground
    const ground = new THREE.Mesh(
      new THREE.PlaneGeometry(6, 6),
      new THREE.MeshStandardMaterial({ color: 0x070a10, roughness: 1, metalness: 0 })
    );
    ground.rotation.x = -Math.PI/2;
    ground.position.y = -0.55;
    scene.add(ground);

    // ---------- Helpers ----------
    let lastFrontImage = null;

    const smoothstep01 = (t) => t*t*(3.0 - 2.0*t);
    function smoothstep(a, b, x) {
      const t = Math.max(0, Math.min(1, (x-a)/(b-a)));
      return t*t*(3 - 2*t);
    }

    function downscaleImageToMax(img, maxSize) {
      const w0 = img.naturalWidth || img.width, h0 = img.naturalHeight || img.height;
      const largest = Math.max(w0, h0);
      if (largest <= maxSize) return img;
      const s = maxSize / largest;
      const w = Math.max(1, Math.round(w0*s));
      const h = Math.max(1, Math.round(h0*s));
      const c = document.createElement("canvas");
      c.width = w; c.height = h;
      c.getContext("2d").drawImage(img, 0, 0, w, h);
      const out = new Image();
      out.src = c.toDataURL("image/jpeg", 0.92);
      return out;
    }

    async function decodeImageFromFile(file) {
      const dataURL = await new Promise((resolve, reject) => {
        const r = new FileReader();
        r.onerror = () => reject(new Error("FileReader failed"));
        r.onload = () => resolve(r.result);
        r.readAsDataURL(file);
      });

      const img = await new Promise((resolve, reject) => {
        const im = new Image();
        im.onload = () => resolve(im);
        im.onerror = () => reject(new Error("Image decode failed"));
        im.src = dataURL;
      });

      return img;
    }

    function imageToTexture(img, { isData=false } = {}) {
      const tex = new THREE.Texture(img);
      tex.anisotropy = 8;
      tex.flipY = true;
      tex.colorSpace = isData ? THREE.NoColorSpace : THREE.SRGBColorSpace;
      tex.needsUpdate = true;
      return tex;
    }

    function canvasToNoColorTexture(canvas) {
      const tex = new THREE.CanvasTexture(canvas);
      tex.colorSpace = THREE.NoColorSpace;
      tex.anisotropy = 8;
      tex.flipY = true;
      tex.needsUpdate = true;
      return tex;
    }

    function drawImageToCanvas(img, maxSize=2048) {
      const w0 = img.naturalWidth || img.width;
      const h0 = img.naturalHeight || img.height;
      const s = Math.min(1, maxSize / Math.max(w0, h0));
      const w = Math.max(1, Math.round(w0 * s));
      const h = Math.max(1, Math.round(h0 * s));
      const c = document.createElement("canvas");
      c.width = w; c.height = h;
      const ctx = c.getContext("2d", { willReadFrequently: true });
      ctx.drawImage(img, 0, 0, w, h);
      return c;
    }

    function toGrayscale(canvas) {
      const ctx = canvas.getContext("2d", { willReadFrequently: true });
      const { width:w, height:h } = canvas;
      const im = ctx.getImageData(0, 0, w, h);
      const d = im.data;
      for (let i=0; i<d.length; i+=4) {
        const r = d[i]/255, g = d[i+1]/255, b = d[i+2]/255;
        const lum = (0.2126*r + 0.7152*g + 0.0722*b) * 255;
        d[i]=d[i+1]=d[i+2]=lum;
        d[i+3]=255;
      }
      ctx.putImageData(im, 0, 0);
      return canvas;
    }

    function normalizeCanvasGrayscale(canvas, pLo=0.01, pHi=0.99) {
      const ctx = canvas.getContext("2d", { willReadFrequently: true });
      const { width:w, height:h } = canvas;
      const im = ctx.getImageData(0, 0, w, h);
      const d = im.data;

      const hist = new Uint32Array(256);
      for (let i=0; i<d.length; i+=4) hist[d[i]]++;

      const total = w*h;
      const loCount = Math.floor(total * pLo);
      const hiCount = Math.floor(total * pHi);

      let acc=0, vLo=0, vHi=255;
      for (let v=0; v<256; v++) { acc += hist[v]; if (acc >= loCount) { vLo = v; break; } }
      acc=0;
      for (let v=0; v<256; v++) { acc += hist[v]; if (acc >= hiCount) { vHi = v; break; } }

      const range = Math.max(1, vHi - vLo);
      for (let i=0; i<d.length; i+=4) {
        let v = d[i];
        v = (v - vLo) * 255 / range;
        v = Math.max(0, Math.min(255, v));
        d[i]=d[i+1]=d[i+2]=v;
        d[i+3]=255;
      }
      ctx.putImageData(im, 0, 0);
      return canvas;
    }

    function applyEdgeFadeToCanvas(canvas, edgeFrac=EDGE_FADE_FRAC) {
      const ctx = canvas.getContext("2d", { willReadFrequently: true });
      const { width:w, height:h } = canvas;
      const im = ctx.getImageData(0, 0, w, h);
      const d = im.data;

      const fadePx = Math.max(1, Math.round(Math.min(w,h) * edgeFrac));

      for (let y=0; y<h; y++) {
        for (let x=0; x<w; x++) {
          const dist = Math.min(x, y, (w-1-x), (h-1-y));
          const t = Math.max(0, Math.min(1, dist / fadePx));
          const m = smoothstep01(t);
          const i = (y*w + x) * 4;
          const v = d[i] * m;
          d[i]=d[i+1]=d[i+2]=v;
          d[i+3]=255;
        }
      }
      ctx.putImageData(im, 0, 0);
      return canvas;
    }

    // Float blur + edge for generators
    function blur3x3Float(src, w, h) {
      const out = new Float32Array(src.length);
      for (let y=0; y<h; y++) for (let x=0; x<w; x++) {
        let sum=0, count=0;
        for (let oy=-1; oy<=1; oy++) for (let ox=-1; ox<=1; ox++) {
          const xx=x+ox, yy=y+oy;
          if (xx<0||xx>=w||yy<0||yy>=h) continue;
          sum += src[yy*w+xx];
          count++;
        }
        out[y*w+x] = sum / count;
      }
      return out;
    }
    function blurNFloat(src, w, h, passes) {
      let cur = src;
      for (let i=0; i<passes; i++) cur = blur3x3Float(cur, w, h);
      return cur;
    }
    function sobelEdgeFloat(src, w, h) {
      const out = new Float32Array(src.length);
      for (let y=1; y<h-1; y++) {
        for (let x=1; x<w-1; x++) {
          const i = y*w + x;
          const gx =
            -src[i-w-1] -2.0*src[i-1] -src[i+w-1] +
             src[i-w+1] +2.0*src[i+1] +src[i+w+1];
          const gy =
            -src[i-w-1] -2.0*src[i-w] -src[i-w+1] +
             src[i+w-1] +2.0*src[i+w] +src[i+w+1];
          out[i] = Math.min(1.0, Math.sqrt(gx*gx + gy*gy));
        }
      }
      return out;
    }

    // Non-tiling value noise
    function valueNoise(x, y) {
      const n = Math.sin(x * 127.1 + y * 311.7) * 43758.5453123;
      return n - Math.floor(n);
    }
    function smoothNoise2D(x, y) {
      const xi = Math.floor(x), yi = Math.floor(y);
      const xf = x - xi, yf = y - yi;
      const u = xf * xf * (3 - 2 * xf);
      const v = yf * yf * (3 - 2 * yf);
      const n00 = valueNoise(xi, yi);
      const n10 = valueNoise(xi + 1, yi);
      const n01 = valueNoise(xi, yi + 1);
      const n11 = valueNoise(xi + 1, yi + 1);
      const nx0 = n00 * (1 - u) + n10 * u;
      const nx1 = n01 * (1 - u) + n11 * u;
      return nx0 * (1 - v) + nx1 * v;
    }

    // ---- Height generator: contour-groove engraving (like real card maps) ----
    // white = high, black = grooves
    function generateHeightFromImage(img) {
      const w0 = img.naturalWidth || img.width;
      const h0 = img.naturalHeight || img.height;
      const s = Math.min(1, AUTOH.maxSize / Math.max(w0, h0));
      const w = Math.max(1, Math.round(w0 * s));
      const h = Math.max(1, Math.round(h0 * s));

      const c = document.createElement("canvas");
      c.width = w; c.height = h;
      const ctx = c.getContext("2d", { willReadFrequently: true });
      ctx.drawImage(img, 0, 0, w, h);

      const im = ctx.getImageData(0, 0, w, h);
      const d = im.data;

      // Luma
      const lum = new Float32Array(w*h);
      for (let i=0, p=0; p<lum.length; p++, i+=4) {
        const r = d[i]/255, g = d[i+1]/255, b = d[i+2]/255;
        lum[p] = 0.2126*r + 0.7152*g + 0.0722*b;
      }

      // Smooth terrain (topographic feel)
      const base = blurNFloat(lum, w, h, AUTOH.SMOOTH_PASSES);

      // Gradient for flow warp
      const gx = new Float32Array(w*h);
      const gy = new Float32Array(w*h);
      for (let y=1; y<h-1; y++) for (let x=1; x<w-1; x++) {
        const i = y*w + x;
        gx[i] = (base[i+1] - base[i-1]) * 0.5;
        gy[i] = (base[i+w] - base[i-w]) * 0.5;
      }

      // Edges from lightly blurred luma
      const small = blurNFloat(lum, w, h, 2);
      const edge = sobelEdgeFloat(small, w, h);

      const out = ctx.createImageData(w, h);

      for (let y=0; y<h; y++) {
        for (let x=0; x<w; x++) {
          const i = y*w + x;

          // Perpendicular-to-gradient warp makes lines "wrap" around shapes
          const gxn = gx[i], gyn = gy[i];
          const len = Math.max(1e-6, Math.sqrt(gxn*gxn + gyn*gyn));
          const px = -gyn / len;
          const py =  gxn / len;

          // Non-tiling noise breaks perfect rings
          const n = (smoothNoise2D(x*0.035, y*0.035) - 0.5) * AUTOH.NOISE;

          const wx = x + px * AUTOH.WARP * (0.30 + edge[i]) + n * 10.0;
          const wy = y + py * AUTOH.WARP * (0.30 + edge[i]) + n * 10.0;

          const sx = Math.max(0, Math.min(w-1, Math.round(wx)));
          const sy = Math.max(0, Math.min(h-1, Math.round(wy)));
          const si = sy*w + sx;

          // Contours
          const phase = base[si] * AUTOH.FREQ + n*2.0;
          const s1 = Math.abs(Math.sin(phase * Math.PI));

          // Groove lines around contour boundaries
          let lineMask = 1.0 - smoothstep(AUTOH.LINE_THICK, AUTOH.LINE_THICK*2.3, s1);

          // Boost near features
          lineMask = Math.min(1.0, lineMask + edge[i] * AUTOH.EDGE_BOOST);

          // Height: mostly high, grooves carved in
          let height = 1.0 - lineMask * 0.95;

          const v = Math.round(height * 255);
          const o = i*4;
          out.data[o]=out.data[o+1]=out.data[o+2]=v;
          out.data[o+3]=255;
        }
      }

      ctx.putImageData(out, 0, 0);

      // Normalize + strong edge fade to keep border flat
      toGrayscale(c);
      normalizeCanvasGrayscale(c, 0.02, 0.98);
      applyEdgeFadeToCanvas(c, EDGE_FADE_FRAC);

      return c;
    }

    // ---- Foil mask generator: prefers art/highlights, suppresses text-ish edges ----
    // Output: white=foil, black=no foil
    function generateFoilMaskFromImage(img, maxSize=1024) {
      const w0 = img.naturalWidth || img.width;
      const h0 = img.naturalHeight || img.height;
      const s = Math.min(1, maxSize / Math.max(w0, h0));
      const w = Math.max(1, Math.round(w0 * s));
      const h = Math.max(1, Math.round(h0 * s));

      const c = document.createElement("canvas");
      c.width = w; c.height = h;
      const ctx = c.getContext("2d", { willReadFrequently: true });
      ctx.drawImage(img, 0, 0, w, h);

      const im = ctx.getImageData(0, 0, w, h);
      const d = im.data;

      // Build float fields: value, saturation, luma
      const val = new Float32Array(w*h);
      const sat = new Float32Array(w*h);
      const lum = new Float32Array(w*h);

      for (let i=0, p=0; p<val.length; p++, i+=4) {
        const r = d[i]/255, g = d[i+1]/255, b = d[i+2]/255;
        const maxc = Math.max(r,g,b), minc = Math.min(r,g,b);
        val[p] = maxc;
        sat[p] = (maxc === 0) ? 0 : (maxc - minc) / maxc;
        lum[p] = 0.2126*r + 0.7152*g + 0.0722*b;
      }

      // Edge map: "text-like" regions tend to have lots of sharp edges
      const small = blurNFloat(lum, w, h, 1);
      const edge = sobelEdgeFloat(small, w, h);

      // Smooth maps so mask is coherent
      const v2 = blurNFloat(val, w, h, 3);
      const s2 = blurNFloat(sat, w, h, 3);
      const e2 = blurNFloat(edge, w, h, 2);

      const out = ctx.createImageData(w, h);
      for (let p=0, i=0; p<v2.length; p++, i+=4) {
        // "Foil likelihood":
        // - favors bright + saturated + moderately textured
        // - suppresses very edge-dense zones (often text blocks)
        const bright = smoothstep(0.40, 0.92, v2[p]);
        const colorful = smoothstep(0.10, 0.65, s2[p]);

        // suppress heavy edges
        const edgeSuppress = 1.0 - smoothstep(0.20, 0.85, e2[p]);

        let m = bright * (0.55 + 0.65*colorful) * (0.55 + 0.60*edgeSuppress);

        // add gentle randomness so foil isn't perfectly uniform
        const nx = smoothNoise2D((p % w)*0.03, Math.floor(p / w)*0.03);
        m = Math.max(0.0, Math.min(1.0, m * (0.85 + 0.30*(nx-0.5))));

        const g = Math.round(m * 255);
        out.data[i]=out.data[i+1]=out.data[i+2]=g;
        out.data[i+3]=255;
      }

      ctx.putImageData(out, 0, 0);

      // soften and pin edges (avoid foil right at card border)
      // use grayscale normalize lightly
      normalizeCanvasGrayscale(c, 0.04, 0.995);
      applyEdgeFadeToCanvas(c, EDGE_FADE_FRAC * 0.75);

      return c;
    }

    function applyFrontTexture(tex, label="Custom front") {
      if (frontMat.map) frontMat.map.dispose();
      frontMat.map = tex;
      frontMat.needsUpdate = true;
      if (tex.image) lastFrontImage = tex.image;
      document.getElementById("titlePill").textContent = label;
    }

    function applyHeightFromCanvas(canvas) {
      // Ensure strong border pin + normalization
      toGrayscale(canvas);
      normalizeCanvasGrayscale(canvas, 0.02, 0.98);
      applyEdgeFadeToCanvas(canvas, EDGE_FADE_FRAC);

      // Clamp displacement intensity by compressing histogram (reduces "rubber")
      // (simple gamma-ish curve)
      const ctx = canvas.getContext("2d", { willReadFrequently: true });
      const { width:w, height:h } = canvas;
      const im = ctx.getImageData(0, 0, w, h);
      const d = im.data;
      for (let i=0; i<d.length; i+=4) {
        const v = d[i] / 255;
        const cV = Math.pow(v, 1.15);              // subtle curve
        const cl = Math.min(1.0, cV / DISP_CLAMP); // clamp
        const out = Math.round(cl * 255);
        d[i]=d[i+1]=d[i+2]=out;
      }
      ctx.putImageData(im, 0, 0);

      const tex = canvasToNoColorTexture(canvas);

      if (frontMat.bumpMap && frontMat.bumpMap !== defaultHeight) frontMat.bumpMap.dispose();
      frontMat.bumpMap = tex;
      frontMat.displacementMap = tex;
      frontMat.displacementScale = DISP_SCALE;
      frontMat.displacementBias = 0.0;
      frontMat.bumpScale = parseFloat(document.getElementById("bumpSlider").value);
      frontMat.needsUpdate = true;

      frontFilmMat.uniforms.uHeight.value = tex;

      log(`Height applied ✅ (${canvas.width}x${canvas.height})`);
    }

    function applyMaskFromCanvas(canvas) {
      const tex = canvasToNoColorTexture(canvas);
      frontFilmMat.uniforms.uMask.value = tex;
      log(`Foil mask applied ✅ (${canvas.width}x${canvas.height})`);
    }

    function clearMaps() {
      frontMat.bumpMap = defaultHeight;
      frontMat.displacementMap = defaultHeight;
      frontMat.needsUpdate = true;

      frontFilmMat.uniforms.uHeight.value = defaultHeight;
      frontFilmMat.uniforms.uMask.value = defaultMask;

      log("Maps cleared ✅");
    }

    // ---------- Holo film shader (wider bands + modern look) ----------
    function makeHoloFilmMaterial(heightTex, maskTex) {
      return new THREE.ShaderMaterial({
        transparent: true,
        depthWrite: false,
        blending: THREE.AdditiveBlending,
        uniforms: {
          uTime: { value: 0.0 },
          uStrength: { value: parseFloat(document.getElementById("holoSlider").value) },
          uHeight: { value: heightTex },
          uMask: { value: maskTex },
          uRelief: { value: parseFloat(document.getElementById("holoReliefSlider").value) },
          uBandScale: { value: parseFloat(document.getElementById("bandSlider").value) },
          uSparkle: { value: parseFloat(document.getElementById("sparkleSlider").value) },
          uDispScale: { value: DISP_SCALE },
          uFilmLift: { value: FILM_LIFT }
        },
        vertexShader: `
          varying vec2 vUv;
          varying vec3 vN;
          varying vec3 vV;
          varying vec3 vTx;
          varying vec3 vTy;

          uniform sampler2D uHeight;
          uniform float uDispScale;
          uniform float uFilmLift;

          void main() {
            vUv = uv;
            float h = texture2D(uHeight, vUv).r;
            vec3 displaced = position + normal * (h * uDispScale + uFilmLift);

            vec4 mv = modelViewMatrix * vec4(displaced, 1.0);
            vV = -mv.xyz;

            vN = normalize(normalMatrix * normal);
            vTx = normalize(normalMatrix * vec3(1.0, 0.0, 0.0));
            vTy = normalize(normalMatrix * vec3(0.0, 1.0, 0.0));

            gl_Position = projectionMatrix * mv;
          }
        `,
        fragmentShader: `
          precision highp float;
          varying vec2 vUv;
          varying vec3 vN;
          varying vec3 vV;
          varying vec3 vTx;
          varying vec3 vTy;

          uniform float uTime;
          uniform float uStrength;
          uniform sampler2D uHeight;
          uniform sampler2D uMask;
          uniform float uRelief;
          uniform float uBandScale;
          uniform float uSparkle;

          float hash21(vec2 p){
            p = fract(p*vec2(123.34, 456.21));
            p += dot(p, p+45.32);
            return fract(p.x*p.y);
          }

          void main() {
            float mask = texture2D(uMask, vUv).r;
            if (mask < 0.01) discard;

            float eps = 0.0016;
            float hC  = texture2D(uHeight, vUv).r;
            float hX1 = texture2D(uHeight, vUv + vec2(eps, 0.0)).r;
            float hX0 = texture2D(uHeight, vUv - vec2(eps, 0.0)).r;
            float hY1 = texture2D(uHeight, vUv + vec2(0.0, eps)).r;
            float hY0 = texture2D(uHeight, vUv - vec2(0.0, eps)).r;

            float dx = (hX1 - hX0);
            float dy = (hY1 - hY0);

            vec3 N = normalize(vN + (-dx * uRelief) * vTx + (-dy * uRelief) * vTy);
            vec3 V = normalize(vV);

            // Fresnel tuned for modern foil (visible at wider angles)
            float fres = pow(1.0 - max(dot(N, V), 0.0), 1.18);

            float bs = max(1.0, uBandScale);

            // WIDE bands: use lower frequency by default
            float bands = sin(vUv.y*bs + vUv.x*(bs*0.18) + uTime*1.55 + hC*6.0) * 0.5 + 0.5;
            float sweep = sin(vUv.x*(bs*0.55) - vUv.y*(bs*0.35) + uTime*0.95 + hC*4.0) * 0.5 + 0.5;

            // fine film grain + sparkles
            float micro = sin((vUv.x + vUv.y*0.55) * 720.0 + uTime*0.28 + hC*10.0) * 0.5 + 0.5;

            float sp = step(0.988, hash21(vUv*vec2(900.0,700.0) + uTime*0.22 + hC*2.5));
            float sparkle = sp * (1.35 * uSparkle);

            vec3 rainbow = 0.55 + 0.45*cos(6.28318*(vec3(0.0,0.33,0.67) + bands));

            float ridge = smoothstep(0.20, 0.85, hC);

            vec3 film = rainbow*(0.20 + 1.70*fres)
                      + rainbow*(sweep*0.18)
                      + rainbow*(micro*0.08)
                      + sparkle;

            // final alpha: strength + fresnel + ridge + mask
            float a = clamp((0.16 + 0.92*fres) * uStrength * (0.82 + 0.55*ridge) * mask, 0.0, 1.0);
            gl_FragColor = vec4(film * a, a);
          }
        `
      });
    }

    const frontFilmMat = makeHoloFilmMaterial(defaultHeight, defaultMask);
    frontFilmMat.polygonOffset = true;
    frontFilmMat.polygonOffsetFactor = -1;
    frontFilmMat.polygonOffsetUnits = -1;

    const frontFilm = new THREE.Mesh(faceGeom, frontFilmMat);
    frontFilm.position.z = Z_FACE + 0.0002;
    cardGroup.add(frontFilm);

    // ---------- UI wiring ----------
    const bumpSlider = document.getElementById("bumpSlider");
    const holoSlider = document.getElementById("holoSlider");
    const holoReliefSlider = document.getElementById("holoReliefSlider");
    const bandSlider = document.getElementById("bandSlider");
    const sparkleSlider = document.getElementById("sparkleSlider");

    bumpSlider.addEventListener("input", () => {
      frontMat.bumpScale = parseFloat(bumpSlider.value);
      frontMat.needsUpdate = true;
    });
    holoSlider.addEventListener("input", () => frontFilmMat.uniforms.uStrength.value = parseFloat(holoSlider.value));
    holoReliefSlider.addEventListener("input", () => frontFilmMat.uniforms.uRelief.value = parseFloat(holoReliefSlider.value));
    bandSlider.addEventListener("input", () => frontFilmMat.uniforms.uBandScale.value = parseFloat(bandSlider.value));
    sparkleSlider.addEventListener("input", () => frontFilmMat.uniforms.uSparkle.value = parseFloat(sparkleSlider.value));

    document.getElementById("clearMapsBtn").addEventListener("click", clearMaps);

    async function regenAll() {
      if (!lastFrontImage) { alert("Upload a front image (or choose a preset) first."); return; }
      log("Generating height (contour grooves)…");
      const h = generateHeightFromImage(lastFrontImage);
      applyHeightFromCanvas(h);

      log("Generating foil mask (realistic)…");
      const m = generateFoilMaskFromImage(lastFrontImage, 1024);
      applyMaskFromCanvas(m);

      log("Regen done ✅");
    }

    document.getElementById("regenAllBtn").addEventListener("click", regenAll);
    document.getElementById("regenFoilBtn").addEventListener("click", () => {
      if (!lastFrontImage) { alert("Upload a front image (or choose a preset) first."); return; }
      log("Generating foil mask (realistic)…");
      const m = generateFoilMaskFromImage(lastFrontImage, 1024);
      applyMaskFromCanvas(m);
      log("Foil regen ✅");
    });

    document.getElementById("frontInput").addEventListener("change", async (e) => {
      const file = e.target.files?.[0];
      if (!file) return;
      try {
        log(`Front picked: ${file.name} (${(file.size/1024/1024).toFixed(2)} MB)`);
        const img0 = await decodeImageFromFile(file);
        const img = downscaleImageToMax(img0, 2048);
        const finalImg = await new Promise((resolve, reject) => {
          if (img === img0) return resolve(img0);
          img.onload = () => resolve(img);
          img.onerror = () => reject(new Error("Downscaled image decode failed"));
        });
        lastFrontImage = finalImg;

        const tex = imageToTexture(finalImg, { isData:false });
        applyFrontTexture(tex, file.name);
        log(`Front applied ✅ ${finalImg.naturalWidth}x${finalImg.naturalHeight}`);

        // Auto regen for realism
        await regenAll();
      } catch (err) {
        log("Front failed ❌ " + err.message);
        alert("Front failed: " + err.message);
      }
    });

    document.getElementById("heightInput").addEventListener("change", async (e) => {
      const file = e.target.files?.[0];
      if (!file) return;
      try {
        log(`Height picked: ${file.name} (${(file.size/1024/1024).toFixed(2)} MB)`);
        const img0 = await decodeImageFromFile(file);
        const img = downscaleImageToMax(img0, 2048);
        const finalImg = await new Promise((resolve, reject) => {
          if (img === img0) return resolve(img0);
          img.onload = () => resolve(img);
          img.onerror = () => reject(new Error("Downscaled image decode failed"));
        });
        const canvas = drawImageToCanvas(finalImg, 2048);
        applyHeightFromCanvas(canvas);
      } catch (err) {
        log("Height failed ❌ " + err.message);
        alert("Height failed: " + err.message);
      }
    });

    document.getElementById("maskInput").addEventListener("change", async (e) => {
      const file = e.target.files?.[0];
      if (!file) return;
      try {
        log(`Mask picked: ${file.name} (${(file.size/1024/1024).toFixed(2)} MB)`);
        const img0 = await decodeImageFromFile(file);
        const img = downscaleImageToMax(img0, 2048);
        const finalImg = await new Promise((resolve, reject) => {
          if (img === img0) return resolve(img0);
          img.onload = () => resolve(img);
          img.onerror = () => reject(new Error("Downscaled image decode failed"));
        });
        const canvas = drawImageToCanvas(finalImg, 2048);
        applyMaskFromCanvas(canvas);
      } catch (err) {
        log("Mask failed ❌ " + err.message);
        alert("Mask failed: " + err.message);
      }
    });

    // Reset / export
    document.getElementById("resetBtn").addEventListener("click", () => {
      controls.target.set(0, 0.05, 0);
      camera.position.set(0, 0.35, 1.35);
      cardGroup.rotation.x = -0.08;
      cardGroup.rotation.y = 0.55;
      controls.update();
      log("View reset ✅");
    });
    document.getElementById("exportBtn").addEventListener("click", () => {
      renderer.render(scene, camera);
      const a = document.createElement("a");
      a.download = "card_view.png";
      a.href = renderer.domElement.toDataURL("image/png");
      a.click();
      log("Exported PNG ✅");
    });

    // ---------- Presets ----------
    const PRESETS = [
      { id: "mega-rayquaza", name: "Mega Rayquaza", tune: { bump: 0.095, holo: 1.18, relief: 2.70, band: 12, sparkle: 1.00 } },
      { id: "mega-blastoise", name: "Mega Blastoise", tune: { bump: 0.095, holo: 1.15, relief: 2.55, band: 12, sparkle: 1.00 } }
    ];

    const presetSelect = document.getElementById("presetSelect");
    const presetThumbs = document.getElementById("presetThumbs");

    function presetPaths(id) {
      return {
        front: `./assets/cards/${id}-front.jpg`,
        height:`./assets/cards/${id}-height.png`,
        mask: `./assets/cards/${id}-mask.png`,
        thumb:`./assets/cards/${id}-thumb.jpg`
      };
    }

    function setFromTune(t) {
      if (!t) return;
      if (typeof t.bump === "number") bumpSlider.value = t.bump.toFixed(3);
      if (typeof t.holo === "number") holoSlider.value = t.holo.toFixed(2);
      if (typeof t.relief === "number") holoReliefSlider.value = t.relief.toFixed(2);
      if (typeof t.band === "number") bandSlider.value = String(Math.round(t.band));
      if (typeof t.sparkle === "number") sparkleSlider.value = t.sparkle.toFixed(2);

      frontMat.bumpScale = parseFloat(bumpSlider.value);
      frontFilmMat.uniforms.uStrength.value = parseFloat(holoSlider.value);
      frontFilmMat.uniforms.uRelief.value = parseFloat(holoReliefSlider.value);
      frontFilmMat.uniforms.uBandScale.value = parseFloat(bandSlider.value);
      frontFilmMat.uniforms.uSparkle.value = parseFloat(sparkleSlider.value);
      frontMat.needsUpdate = true;
    }

    function loadTexture(path, { isData=false } = {}) {
      return new Promise((resolve, reject) => {
        loader.load(path, (t) => {
          t.anisotropy = 8;
          t.flipY = true;
          t.colorSpace = isData ? THREE.NoColorSpace : THREE.SRGBColorSpace;
          resolve(t);
        }, undefined, () => reject(new Error(`Failed: ${path}`)));
      });
    }

    async function applyPreset(p) {
      const { front, height, mask } = presetPaths(p.id);
      log(`Loading preset: ${p.name}…`);
      document.getElementById("titlePill").textContent = p.name;
      setFromTune(p.tune);

      try {
        const frontTex = await loadTexture(front, { isData:false });
        applyFrontTexture(frontTex, p.name);
        if (frontTex.image) lastFrontImage = frontTex.image;

        // Height: load or auto-generate
        try {
          const hTex = await loadTexture(height, { isData:true });
          const canvas = drawImageToCanvas(hTex.image, 2048);
          applyHeightFromCanvas(canvas);
          log("Preset height loaded ✅");
        } catch {
          log("Preset height missing → auto-generating…");
          const canvas = generateHeightFromImage(lastFrontImage);
          applyHeightFromCanvas(canvas);
        }

        // Mask: load or auto-generate realistic
        try {
          const mTex = await loadTexture(mask, { isData:true });
          const canvas = drawImageToCanvas(mTex.image, 1024);
          applyMaskFromCanvas(canvas);
          log("Preset mask loaded ✅");
        } catch {
          log("Preset mask missing → auto-generating…");
          const canvas = generateFoilMaskFromImage(lastFrontImage, 1024);
          applyMaskFromCanvas(canvas);
        }

        log(`Preset applied ✅ ${p.name}`);
      } catch (err) {
        log("Preset failed ❌ " + err.message);
      }
    }

    function buildPresetsUI() {
      presetSelect.innerHTML =
        `<option value="">— Choose a card —</option>` +
        PRESETS.map(p => `<option value="${p.id}">${p.name}</option>`).join("");

      presetThumbs.innerHTML = "";
      for (const p of PRESETS) {
        const btn = document.createElement("button");
        btn.className = "thumbBtn";
        btn.type = "button";
        btn.title = p.name;

        const { thumb } = presetPaths(p.id);
        const img = document.createElement("img");
        img.alt = p.name;
        img.src = thumb;
        img.onerror = () => img.remove();

        const label = document.createElement("span");
        label.textContent = p.name;

        btn.appendChild(img);
        btn.appendChild(label);
        btn.addEventListener("click", () => {
          presetSelect.value = p.id;
          applyPreset(p);
        });

        presetThumbs.appendChild(btn);
      }

      presetSelect.addEventListener("change", () => {
        const id = presetSelect.value;
        const p = PRESETS.find(x => x.id === id);
        if (!p) return;
        applyPreset(p);
      });
    }
    buildPresetsUI();

    // ---------- Resize ----------
    window.addEventListener("resize", () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // ---------- Animate ----------
    const clock = new THREE.Clock();
    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      frontFilmMat.uniforms.uTime.value = clock.getElapsedTime();
      renderer.render(scene, camera);
    }
    animate();

    log("Viewer ready ✅");
  </script>
</body>
</html>
