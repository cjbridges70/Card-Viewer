<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Card Viewer (Stable)</title>
  <style>
    html,body{height:100%;margin:0;overflow:hidden;background:#0b0e12;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;}
    #hud{
      position:fixed;left:12px;top:12px;right:12px;z-index:10;
      display:flex;gap:10px;align-items:center;flex-wrap:wrap;
      color:#e7eefc;
    }
    .pill{
      background:rgba(18,20,26,.78);border:1px solid rgba(255,255,255,.10);
      border-radius:14px;padding:8px 10px;backdrop-filter:blur(10px);-webkit-backdrop-filter:blur(10px);
      box-shadow:0 10px 30px rgba(0,0,0,.35);
      display:flex;gap:8px;align-items:center;flex-wrap:wrap;
    }
    select,button,input{
      background:rgba(255,255,255,.06);border:1px solid rgba(255,255,255,.12);
      color:#e7eefc;border-radius:10px;padding:8px 10px;font-size:14px;
    }
    button{cursor:pointer}
    #status{margin-left:auto;opacity:.85}
    #log{
      position:fixed;left:12px;bottom:12px;width:min(720px,calc(100% - 24px));
      max-height:35vh;overflow:auto;white-space:pre-wrap;
      font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace;font-size:12px;line-height:1.25;
      color:#e7eefc;background:rgba(9,12,16,.72);border:1px solid rgba(255,255,255,.10);
      border-radius:14px;padding:10px 12px;backdrop-filter:blur(10px);-webkit-backdrop-filter:blur(10px);
      display:none;
    }
    #log.on{display:block}
    canvas{display:block;width:100%;height:100%}
  </style>
</head>
<body>
  <div id="hud">
    <div class="pill">
      <select id="preset">
        <option value="ray">Mega Rayquaza</option>
        <option value="blast">Mega Blastoise</option>
      </select>
      <button id="reload">Reload</button>
      <button id="reset">Reset View</button>
      <button id="toggleLog">Toggle Log</button>
    </div>
    <div class="pill">
      <label style="display:flex;gap:8px;align-items:center;">
        <span style="opacity:.85">Front upload</span>
        <input id="frontFile" type="file" accept="image/*">
      </label>
    </div>
    <div id="status" class="pill">Booting…</div>
  </div>

  <div id="log"></div>

  <script type="module">
    import * as THREE from './libs/three.module.js';

    // ----------------- paths (your structure) -----------------
    const PATH_BACK = './assets/pokemon-back.jpg';
    const PRESETS = {
      ray:   './assets/presets/mega-rayquaza-front.JPG',
      blast: './assets/presets/mega-blastoise-front.JPG'
    };

    // ----------------- log/status -----------------
    const logEl = document.getElementById('log');
    const statusEl = document.getElementById('status');
    function log(s){ logEl.textContent += s + "\\n"; logEl.scrollTop = logEl.scrollHeight; console.log(s); }
    function status(s){ statusEl.textContent = s; }

    document.getElementById('toggleLog').onclick = ()=> logEl.classList.toggle('on');

    // ----------------- renderer/scene -----------------
    const renderer = new THREE.WebGLRenderer({ antialias:true });
    renderer.setPixelRatio(Math.min(2, window.devicePixelRatio || 1));
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.15;
    document.body.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0b0e12);

    const camera = new THREE.PerspectiveCamera(40, window.innerWidth/window.innerHeight, 0.01, 50);
    camera.position.set(0, 0.06, 1.9);

    // lights (fix “too dark”)
    scene.add(new THREE.AmbientLight(0xffffff, 0.75));
    const key = new THREE.DirectionalLight(0xffffff, 1.6);
    key.position.set(1.2, 1.6, 1.4);
    scene.add(key);
    const fill = new THREE.DirectionalLight(0x88b6ff, 0.45);
    fill.position.set(-1.6, 0.2, 0.6);
    scene.add(fill);

    // ----------------- tiny touch/mouse orbit (no OrbitControls needed) -----------------
    const state = {
      target: new THREE.Vector3(0, 0.02, 0),
      yaw: 0.35,
      pitch: -0.10,
      dist: 1.9,
      dragging: false,
      lastX: 0,
      lastY: 0,
      pinchDist: 0
    };

    function updateCamera(){
      const cp = Math.cos(state.pitch), sp = Math.sin(state.pitch);
      const cy = Math.cos(state.yaw),   sy = Math.sin(state.yaw);
      const x = state.dist * cp * sy;
      const y = state.dist * sp;
      const z = state.dist * cp * cy;
      camera.position.set(state.target.x + x, state.target.y + y, state.target.z + z);
      camera.lookAt(state.target);
    }
    updateCamera();

    function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }

    const canvas = renderer.domElement;

    canvas.addEventListener('pointerdown', (e)=>{
      state.dragging = true;
      state.lastX = e.clientX;
      state.lastY = e.clientY;
      canvas.setPointerCapture(e.pointerId);
    });
    canvas.addEventListener('pointerup', (e)=>{
      state.dragging = false;
      try{ canvas.releasePointerCapture(e.pointerId); }catch{}
    });
    canvas.addEventListener('pointermove', (e)=>{
      if(!state.dragging) return;
      const dx = e.clientX - state.lastX;
      const dy = e.clientY - state.lastY;
      state.lastX = e.clientX;
      state.lastY = e.clientY;
      state.yaw   += dx * 0.007;
      state.pitch += dy * 0.007;
      state.pitch = clamp(state.pitch, -1.2, 0.9);
    });

    canvas.addEventListener('wheel', (e)=>{
      e.preventDefault();
      state.dist *= (e.deltaY > 0) ? 1.06 : 0.94;
      state.dist = clamp(state.dist, 1.1, 4.5);
    }, { passive:false });

    // pinch zoom (touch)
    canvas.addEventListener('touchstart', (e)=>{
      if(e.touches.length === 2){
        const dx = e.touches[0].clientX - e.touches[1].clientX;
        const dy = e.touches[0].clientY - e.touches[1].clientY;
        state.pinchDist = Math.sqrt(dx*dx + dy*dy);
      }
    }, { passive:true });

    canvas.addEventListener('touchmove', (e)=>{
      if(e.touches.length === 2){
        const dx = e.touches[0].clientX - e.touches[1].clientX;
        const dy = e.touches[0].clientY - e.touches[1].clientY;
        const d = Math.sqrt(dx*dx + dy*dy);
        const ratio = d / Math.max(1, state.pinchDist);
        state.dist /= ratio;
        state.dist = clamp(state.dist, 1.1, 4.5);
        state.pinchDist = d;
      }
    }, { passive:true });

    document.getElementById('reset').onclick = ()=>{
      state.yaw = 0.35; state.pitch = -0.10; state.dist = 1.9;
      updateCamera();
    };

    // ----------------- rounded corners via shader discard (real Pokémon corners) -----------------
    const roundedRectGLSL = `
      float roundedMask(vec2 uv, float r){
        vec2 p = uv * 2.0 - 1.0;
        float rx = r * 2.0;
        vec2 q = abs(p) - (vec2(1.0) - vec2(rx));
        float outside = length(max(q, 0.0)) - rx;
        return 1.0 - step(0.0, outside);
      }
    `;

    // ----------------- materials (fix flip/mirror) -----------------
    const uniforms = {
      uFront:{value:null},
      uBack:{value:null},
      uCorner:{value:0.075},
      uTime:{value:0}
    };

    const frontMat = new THREE.ShaderMaterial({
      uniforms,
      transparent:true,
      side:THREE.FrontSide,
      vertexShader:`
        varying vec2 vUv;
        void main(){
          vUv = uv; // correct orientation
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);
        }
      `,
      fragmentShader:`
        precision highp float;
        varying vec2 vUv;
        uniform sampler2D uFront;
        uniform float uCorner;
        uniform float uTime;
        ${roundedRectGLSL}

        float hash(vec2 p){ return fract(sin(dot(p, vec2(127.1,311.7))) * 43758.5453); }

        void main(){
          float inside = roundedMask(vUv, uCorner);
          if(inside < 0.5) discard;

          vec3 base = texture2D(uFront, vUv).rgb;

          // simple brightening so it’s not “too dark”
          base = pow(base, vec3(1.0/1.05));

          gl_FragColor = vec4(base, 1.0);
        }
      `
    });

    const backMat = new THREE.ShaderMaterial({
      uniforms,
      transparent:true,
      side:THREE.FrontSide,
      vertexShader:`
        varying vec2 vUv;
        void main(){
          // cancel mirroring from 180° rotation:
          vUv = vec2(1.0 - uv.x, uv.y);
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);
        }
      `,
      fragmentShader:`
        precision highp float;
        varying vec2 vUv;
        uniform sampler2D uBack;
        uniform float uCorner;
        ${roundedRectGLSL}
        void main(){
          float inside = roundedMask(vUv, uCorner);
          if(inside < 0.5) discard;
          vec3 base = texture2D(uBack, vUv).rgb;
          base = pow(base, vec3(1.0/1.05));
          gl_FragColor = vec4(base, 1.0);
        }
      `
    });

    // card meshes
    const W = 1.0;
    const H = W * (88/63);
    const geo = new THREE.PlaneGeometry(W, H, 1, 1);

    const group = new THREE.Group();
    const front = new THREE.Mesh(geo, frontMat);
    front.position.z = 0.003;
    const back = new THREE.Mesh(geo, backMat);
    back.rotation.y = Math.PI;
    back.position.z = -0.003;
    group.add(front, back);
    group.rotation.x = -0.04;
    scene.add(group);

    // ----------------- texture loading -----------------
    const loader = new THREE.TextureLoader();
    function loadTex(url){
      return new Promise((resolve,reject)=>{
        loader.load(url, (t)=>{
          t.colorSpace = THREE.SRGBColorSpace;
          t.anisotropy = 8;
          t.wrapS = t.wrapT = THREE.ClampToEdgeWrapping;
          // keep default flipY=true (matches vUv=uv)
          resolve(t);
        }, undefined, ()=>reject(new Error('Failed to load: ' + url)));
      });
    }

    async function loadPreset(which){
      try{
        status('Loading…');
        logEl.textContent = '';
        const f = PRESETS[which];
        const [frontT, backT] = await Promise.all([loadTex(f), loadTex(PATH_BACK)]);
        uniforms.uFront.value = frontT;
        uniforms.uBack.value = backT;
        log('✓ Loaded: ' + f);
        log('✓ Loaded: ' + PATH_BACK);
        status('Ready');
      }catch(e){
        log('✗ ' + e.message);
        status('Error');
      }
    }

    document.getElementById('preset').addEventListener('change', (e)=> loadPreset(e.target.value));
    document.getElementById('reload').onclick = ()=> loadPreset(document.getElementById('preset').value);

    document.getElementById('frontFile').addEventListener('change', async (e)=>{
      const file = e.target.files?.[0];
      if(!file) return;
      status('Loading upload…');
      const url = URL.createObjectURL(file);
      try{
        const t = await loadTex(url);
        uniforms.uFront.value = t;
        log('✓ Loaded upload: ' + file.name);
        status('Ready');
      }catch(err){
        log('✗ ' + err.message);
        status('Error');
      }finally{
        // keep URL alive for texture; do not revoke immediately
      }
    });

    // resize
    window.addEventListener('resize', ()=>{
      camera.aspect = window.innerWidth/window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // animate
    const clock = new THREE.Clock();
    function animate(){
      requestAnimationFrame(animate);
      uniforms.uTime.value = clock.getElapsedTime();
      updateCamera();
      renderer.render(scene, camera);
    }
    animate();

    // boot
    status('Loading preset…');
    loadPreset('ray');

  </script>
</body>
</html>
