<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Card Viewer</title>
  <style>
    :root{ color-scheme: dark; }
    html,body{ height:100%; margin:0; background:#07080b; overflow:hidden; font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif; }
    #app{ position:fixed; inset:0; }
    canvas{ display:block; width:100%; height:100%; }

    .topbar{
      position: fixed; left: 12px; right: 12px; top: calc(10px + env(safe-area-inset-top));
      display:flex; gap:10px; align-items:center; justify-content:space-between;
      z-index: 30; pointer-events:none;
    }
    .topbar > *{ pointer-events:auto; }

    .pill{
      background: rgba(18,20,26,.78);
      border: 1px solid rgba(255,255,255,.10);
      border-radius: 14px;
      padding: 8px 10px;
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      box-shadow: 0 10px 30px rgba(0,0,0,.35);
      color:#e8eefc;
    }
    .row{ display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    select,button,input[type="file"]{
      background: rgba(255,255,255,.06);
      border: 1px solid rgba(255,255,255,.12);
      color:#e8eefc;
      border-radius: 10px;
      padding: 8px 10px;
      font-size: 14px;
    }
    button{ cursor:pointer; }
    button:hover{ background: rgba(255,255,255,.10); }

    #panel{
      position: fixed;
      right: 12px;
      top: calc(54px + env(safe-area-inset-top));
      width: min(380px, calc(100vw - 24px));
      max-height: calc(100vh - 80px - env(safe-area-inset-top) - env(safe-area-inset-bottom));
      overflow:auto;
      z-index: 30;
    }
    .section{ margin:10px 0; }
    .section h3{ margin:0 0 8px 0; font-size:13px; letter-spacing:.02em; color:#b9c6e6; text-transform:uppercase; }
    .grid{ display:grid; grid-template-columns: 1fr auto; gap:8px 10px; align-items:center; }
    .grid label{ font-size:13px; color:#d6def3; }
    input[type="range"]{ width:100%; }
    .hint{ opacity:.9; font-size:12px; color:#a9b9df; margin-top:8px; line-height:1.25; }
    .small{ font-size:12px; opacity:.8; }
    .chk{ display:flex; gap:8px; align-items:center; }
    .chk input{ transform: scale(1.1); }

    #debug{
      position: fixed;
      left: 12px;
      bottom: calc(10px + env(safe-area-inset-bottom));
      width: min(760px, calc(100vw - 24px));
      max-height: 34vh;
      z-index: 40;
      overflow:auto;
      white-space: pre-wrap;
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      font-size: 12px;
      line-height: 1.25;
      color: #e8eefc;
    }
    #debug .title{ font-weight:700; margin-bottom:6px; display:flex; justify-content:space-between; align-items:center; gap:10px; }
    #debug .err{ color:#ff9a9a; }
    #debug .ok{ color:#b6ffb6; }
    .badge{ font-size:12px; opacity:.85; padding:6px 10px; border-radius:999px; }
    .muted{ opacity:.75; }
  </style>

  <script type="importmap">
    {
      "imports": {
        "three": "./libs/three.module.js",
        "three/addons/": "./libs/examples/jsm/"
      }
    }
  </script>
</head>
<body>
  <div id="app"></div>

  <div class="topbar">
    <div class="pill row">
      <select id="preset">
        <option value="ray">Mega Rayquaza</option>
        <option value="blast">Mega Blastoise</option>
      </select>
      <button id="reload">Reload</button>
      <button id="resetAll">Reset</button>
      <span id="status" class="badge muted">Booting…</span>
    </div>
    <div class="pill row">
      <span class="muted">Drag to rotate · Pinch/scroll to zoom</span>
      <button id="resetView">Reset View</button>
    </div>
  </div>

  <div id="panel" class="pill">
    <div class="section">
      <h3>Images</h3>
      <div class="grid">
        <label>Front (upload)</label><input id="frontFile" type="file" accept="image/*" />
        <label>Height (optional)</label><input id="heightFile" type="file" accept="image/*" />
      </div>
      <div class="hint">If you don’t upload a height map, one is auto-generated from the front image.</div>
    </div>

    <div class="section">
      <h3>Effects</h3>
      <div class="grid">
        <div class="chk"><input id="fxHolo" type="checkbox" checked /><label for="fxHolo">Holographic (front)</label></div><span></span>
        <div class="chk"><input id="fxHeight" type="checkbox" checked /><label for="fxHeight">Auto Height + Micro-Emboss</label></div><span></span>
        <div class="chk"><input id="fxMask" type="checkbox" checked /><label for="fxMask">Auto Foil Mask (protect subject)</label></div><span></span>
      </div>
    </div>

    <div class="section">
      <h3>Tuning</h3>
      <div class="grid">
        <label>Emboss Strength</label><input id="emboss" type="range" min="0" max="6" step="0.01" value="2.60" />
        <label>Holo Intensity</label><input id="holo" type="range" min="0" max="4" step="0.01" value="1.70" />
        <label>Holo Band Width</label><input id="band" type="range" min="0.02" max="0.70" step="0.01" value="0.25" />
        <label>Foil Grain</label><input id="grain" type="range" min="0" max="3" step="0.01" value="1.15" />
        <label>Corner Radius</label><input id="radius" type="range" min="0.00" max="0.20" step="0.001" value="0.065" />
      </div>
      <div class="hint small">Try Emboss 2.0–3.5. If it’s subtle, rotate the card under the light.</div>
    </div>

    <div class="section">
      <h3>Export</h3>
      <div class="row">
        <button id="exportHeight">Export Height</button>
        <button id="exportMask">Export Foil Mask</button>
        <button id="toggleLog">Toggle Log</button>
      </div>
    </div>

    <div class="section">
      <h3>Status</h3>
      <div class="small" id="miniStatus">—</div>
    </div>
  </div>

  <div id="debug" class="pill">
    <div class="title">
      <span>DEBUG</span>
      <span class="small muted">tap “Toggle Log” to hide</span>
    </div>
    <div id="dbgText"></div>
  </div>

  <script type="module">
    // ---------- logger ----------
    const dbgBox  = document.getElementById("debug");
    const dbgText = document.getElementById("dbgText");
    const statusEl = document.getElementById("status");
    const miniStatus = document.getElementById("miniStatus");
    const log = (msg, cls="") => {
      const line = document.createElement("div");
      line.textContent = msg;
      if(cls) line.className = cls;
      dbgText.appendChild(line);
      dbgBox.scrollTop = dbgBox.scrollHeight;
      console.log(msg);
    };
    const setStatus = (msg) => { statusEl.textContent = msg; miniStatus.textContent = msg; };

    window.addEventListener("error", (e) => log("❌ window.error: " + (e?.message || e), "err"));
    window.addEventListener("unhandledrejection", (e) => log("❌ unhandledrejection: " + (e?.reason?.message || e?.reason || e), "err"));

    import * as THREE from "three";
    import { OrbitControls } from "three/addons/controls/OrbitControls.js";
    log("✓ Imports OK (three + OrbitControls)", "ok");

    // ---------- paths ----------
    const PATH_BACK = "./assets/pokemon-back.jpg";
    const PRESETS = {
      ray:   "./assets/presets/mega-rayquaza-front.JPG",
      blast: "./assets/presets/mega-blastoise-front.JPG"
    };

    // ---------- renderer / scene ----------
    const app = document.getElementById("app");
    const renderer = new THREE.WebGLRenderer({ antialias:true });
    renderer.setPixelRatio(Math.min(2, window.devicePixelRatio || 1));
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    app.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x07080b);

    const camera = new THREE.PerspectiveCamera(38, window.innerWidth/window.innerHeight, 0.01, 50);
    camera.position.set(0.0, 0.05, 1.55);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.08;
    controls.minDistance = 0.8;
    controls.maxDistance = 3.0;
    controls.target.set(0, 0.02, 0);

    scene.add(new THREE.AmbientLight(0xffffff, 0.22));
    const key = new THREE.DirectionalLight(0xffffff, 2.2);
    key.position.set(1.2, 1.3, 1.6);
    scene.add(key);

    // ---------- card dimensions ----------
    const CARD_W = 1.0;
    const CARD_H = CARD_W * (88/63);
    const THICK = 0.015;
    const EPS = 0.0008;

    // ---------- rounded-rect discard in shader (UV space) ----------
    const roundedRectGLSL = `
      float roundedMask(vec2 uv, float r){
        vec2 p = uv * 2.0 - 1.0;
        float rx = r * 2.0;
        vec2 q = abs(p) - (vec2(1.0) - vec2(rx));
        float outside = length(max(q, 0.0)) - rx;
        return 1.0 - step(0.0, outside);
      }
    `;

    // ---------- height/mask generation ----------
    function canvasFromImage(img, maxDim=1024){
      const scale = Math.min(1, maxDim / Math.max(img.width, img.height));
      const w = Math.max(2, Math.floor(img.width * scale));
      const h = Math.max(2, Math.floor(img.height * scale));
      const c = document.createElement("canvas");
      c.width = w; c.height = h;
      const ctx = c.getContext("2d", { willReadFrequently:true });
      ctx.drawImage(img, 0, 0, w, h);
      return { c, ctx, w, h };
    }

    function blur3x3(data, w, h){
      const out = new Uint8ClampedArray(data.length);
      const idx = (x,y)=>y*w+x;
      for(let y=1;y<h-1;y++){
        for(let x=1;x<w-1;x++){
          let s=0;
          s += data[idx(x-1,y-1)] + data[idx(x,y-1)] + data[idx(x+1,y-1)];
          s += data[idx(x-1,y  )] + data[idx(x,y  )] + data[idx(x+1,y  )];
          s += data[idx(x-1,y+1)] + data[idx(x,y+1)] + data[idx(x+1,y+1)];
          out[idx(x,y)] = (s/9)|0;
        }
      }
      data.set(out);
    }

    function sobelMag(gray, w, h){
      const out = new Uint8ClampedArray(w*h);
      const idx = (x,y)=>y*w+x;
      for(let y=1;y<h-1;y++){
        for(let x=1;x<w-1;x++){
          const gx =
            -1*gray[idx(x-1,y-1)] + 1*gray[idx(x+1,y-1)] +
            -2*gray[idx(x-1,y  )] + 2*gray[idx(x+1,y  )] +
            -1*gray[idx(x-1,y+1)] + 1*gray[idx(x+1,y+1)];
          const gy =
            -1*gray[idx(x-1,y-1)] + -2*gray[idx(x,y-1)] + -1*gray[idx(x+1,y-1)] +
             1*gray[idx(x-1,y+1)] +  2*gray[idx(x,y+1)] +  1*gray[idx(x+1,y+1)];
          out[idx(x,y)] = Math.min(255, Math.sqrt(gx*gx + gy*gy))|0;
        }
      }
      return out;
    }

    function generateHeightAndMask(frontImg){
      const { ctx, w, h } = canvasFromImage(frontImg, 1024);
      const img = ctx.getImageData(0,0,w,h);
      const px = img.data;

      const gray = new Uint8ClampedArray(w*h);
      for(let i=0, p=0; i<gray.length; i++, p+=4){
        const r=px[p], g=px[p+1], b=px[p+2];
        gray[i] = (0.2126*r + 0.7152*g + 0.0722*b)|0;
      }

      const edges = sobelMag(gray,w,h);
      blur3x3(edges,w,h); blur3x3(edges,w,h);

      const height = new Uint8ClampedArray(w*h);
      for(let i=0;i<height.length;i++){
        const v = (0.70*gray[i] + 0.65*edges[i]);
        height[i] = Math.max(0, Math.min(255, v))|0;
      }
      blur3x3(height,w,h);

      let mean=0;
      for(let i=0;i<edges.length;i++) mean += edges[i];
      mean /= edges.length;

      const mask = new Uint8ClampedArray(w*h);
      for(let i=0;i<mask.length;i++){
        let m = (edges[i] - mean) * 2.4 + 105;
        m = Math.max(0, Math.min(255, m));
        if(gray[i] > 235) m *= 0.65;
        mask[i] = m|0;
      }
      blur3x3(mask,w,h); blur3x3(mask,w,h);

      const makeGrayCanvas = (arr) => {
        const c = document.createElement("canvas");
        c.width=w; c.height=h;
        const cctx = c.getContext("2d");
        const im = cctx.createImageData(w,h);
        for(let i=0, p=0;i<arr.length;i++,p+=4){
          const v=arr[i];
          im.data[p]=v; im.data[p+1]=v; im.data[p+2]=v; im.data[p+3]=255;
        }
        cctx.putImageData(im,0,0);
        return c;
      };

      return { heightCanvas: makeGrayCanvas(height), maskCanvas: makeGrayCanvas(mask) };
    }

    // IMPORTANT: make texture orientation consistent for Safari:
    // - Use vUv flipped in shader AND flipY=true on textures (matches Three defaults)
    function texFromCanvas(c){
      const t = new THREE.CanvasTexture(c);
      t.colorSpace = THREE.SRGBColorSpace;
      t.wrapS = t.wrapT = THREE.ClampToEdgeWrapping;
      t.flipY = true;
      t.needsUpdate = true;
      return t;
    }

    function texFromImage(img){
      const t = new THREE.Texture(img);
      t.colorSpace = THREE.SRGBColorSpace;
      t.wrapS = t.wrapT = THREE.ClampToEdgeWrapping;
      t.flipY = true;
      t.needsUpdate = true;
      return t;
    }

    function loadImage(url){
      return new Promise((resolve,reject)=>{
        const img = new Image();
        img.crossOrigin = "anonymous";
        img.onload = ()=>resolve(img);
        img.onerror = ()=>reject(new Error("Image failed: " + url));
        img.src = url;
      });
    }

    // ---------- shared uniforms ----------
    const uniforms = {
      uFront: { value: null },
      uBack:  { value: null },
      uHeight:{ value: null },
      uMask:  { value: null },

      uTexel: { value: new THREE.Vector2(1/1024, 1/1024) },

      uEmboss: { value: 2.6 },
      uHolo:   { value: 1.7 },
      uBand:   { value: 0.25 },
      uGrain:  { value: 1.15 },
      uRadius: { value: 0.065 },

      uEnableHolo: { value: 1 },
      uEnableHeight:{ value: 1 },
      uEnableMask: { value: 1 },

      uTime: { value: 0 },
      uCamPos: { value: new THREE.Vector3() },
      uLightDir: { value: new THREE.Vector3(0.6, 0.8, 1.0).normalize() },
      uLightCol: { value: new THREE.Color(1,1,1) }
    };

    // ---------- front shader ----------
    const frontMat = new THREE.ShaderMaterial({
      uniforms,
      transparent: true,
      side: THREE.FrontSide,
      vertexShader: /* glsl */`
        varying vec2 vUv;
        varying vec3 vWorldPos;
        varying vec3 vNormalW;
        void main(){
          // Flip UV vertically so images are right-side-up across Safari/Three combos
          vUv = vec2(uv.x, 1.0 - uv.y);
          vec4 wp = modelMatrix * vec4(position,1.0);
          vWorldPos = wp.xyz;
          vNormalW = normalize(mat3(modelMatrix) * normal);
          gl_Position = projectionMatrix * viewMatrix * wp;
        }
      `,
      fragmentShader: /* glsl */`
        precision highp float;
        varying vec2 vUv;
        varying vec3 vWorldPos;
        varying vec3 vNormalW;

        uniform sampler2D uFront;
        uniform sampler2D uHeight;
        uniform sampler2D uMask;

        uniform vec2 uTexel;

        uniform float uEmboss;
        uniform float uHolo;
        uniform float uBand;
        uniform float uGrain;
        uniform float uRadius;

        uniform float uEnableHolo;
        uniform float uEnableHeight;
        uniform float uEnableMask;

        uniform float uTime;
        uniform vec3 uCamPos;
        uniform vec3 uLightDir;
        uniform vec3 uLightCol;

        ${roundedRectGLSL}

        float hash12(vec2 p){
          vec3 p3  = fract(vec3(p.xyx) * .1031);
          p3 += dot(p3, p3.yzx + 33.33);
          return fract((p3.x + p3.y) * p3.z);
        }

        float microLines(vec2 uv){
          float a = 1.25 + 0.25*sin(uTime*0.15);
          mat2 R = mat2(cos(a),-sin(a),sin(a),cos(a));
          vec2 p = (uv - 0.5);
          p = R * p;
          float n = hash12(uv*37.0 + uTime*0.03);
          p += (n-0.5) * 0.02;
          float f = 900.0;
          float s = sin((p.y)*f);
          return 0.5 + 0.5*s;
        }

        vec3 normalFromHeight(vec2 uv){
          float h  = texture2D(uHeight, uv).r;
          float hx = texture2D(uHeight, uv + vec2(uTexel.x, 0.0)).r;
          float hy = texture2D(uHeight, uv + vec2(0.0, uTexel.y)).r;
          // stronger z makes normals less "flat" -> emboss reads better
          return normalize(vec3(h - hx, h - hy, 0.04));
        }

        void main(){
          float inside = roundedMask(vUv, uRadius);
          if(inside < 0.5) discard;

          vec3 base = texture2D(uFront, vUv).rgb;

          // Build a perturbed normal
          vec3 nW = normalize(vNormalW);
          if(uEnableHeight > 0.5){
            vec3 nh = normalFromHeight(vUv);
            float ml = microLines(vUv);
            vec3 bump = normalize(vec3(nh.xy * (0.6 + 0.4*ml) * uEmboss, 1.0));
            // blend bump into world normal
            nW = normalize(vec3(bump.xy, 1.0));
          }

          vec3 V = normalize(uCamPos - vWorldPos);
          vec3 L = normalize(uLightDir);

          float NdotL = max(dot(nW, L), 0.0);
          float NdotV = max(dot(nW, V), 0.0);

          // classic spec (emboss becomes obvious here)
          vec3 R = reflect(-L, nW);
          float spec = pow(max(dot(R, V), 0.0), 60.0);

          // subject protection mask (0..1)
          float protect = 0.0;
          if(uEnableMask > 0.5){
            protect = texture2D(uMask, vUv).r;
          }

          // holo bands + grain (kept wavy like you liked)
          float bands = 0.0;
          float grain = 0.0;
          if(uEnableHolo > 0.5){
            float ang = atan(V.y, V.x);
            float sweep = (vUv.x*1.15 + vUv.y*0.35) + 0.08*sin(uTime*0.25);
            float b = sin((sweep + ang*0.12) * (6.28318 / max(0.02,uBand)));
            bands = 0.5 + 0.5*b;

            float h = hash12(vUv*vec2(1400.0, 900.0) + uTime*0.02);
            grain = (h - 0.5) * 0.25 * uGrain;
          }

          vec3 holoCol = vec3(
            0.55 + 0.45*sin(6.28318*(bands + 0.00)),
            0.55 + 0.45*sin(6.28318*(bands + 0.33)),
            0.55 + 0.45*sin(6.28318*(bands + 0.66))
          );

          float fres = pow(1.0 - NdotV, 2.0);
          float holoAmt = uHolo * (1.0 - protect);

          // Lighting base: slightly darker ambient, stronger directional
          vec3 lit = base * (0.30 + 0.90*NdotL) * uLightCol;

          // Holo overlay (reduced intensity vs prior so colors stay closer)
          lit += holoCol * (0.12*holoAmt) * (0.35 + 0.65*fres);
          lit += grain * (0.25 + 0.75*fres);

          // Spec highlight (emboss pops here)
          lit += vec3(1.0) * spec * (0.10 + 0.20*uEnableHeight);

          gl_FragColor = vec4(lit, 1.0);
        }
      `
    });

    // ---------- back shader (now actually visible) ----------
    const backMat = new THREE.ShaderMaterial({
      uniforms,
      transparent: true,
      // IMPORTANT: use FrontSide because we rotate the back plane 180°
      side: THREE.FrontSide,
      vertexShader: /* glsl */`
        varying vec2 vUv;
        varying vec3 vNormalW;
        varying vec3 vWorldPos;
        void main(){
          vUv = vec2(uv.x, 1.0 - uv.y);
          vec4 wp = modelMatrix * vec4(position,1.0);
          vWorldPos = wp.xyz;
          vNormalW = normalize(mat3(modelMatrix) * normal);
          gl_Position = projectionMatrix * viewMatrix * wp;
        }
      `,
      fragmentShader: /* glsl */`
        precision highp float;
        varying vec2 vUv;
        varying vec3 vNormalW;
        varying vec3 vWorldPos;

        uniform sampler2D uBack;
        uniform float uRadius;

        uniform vec3 uCamPos;
        uniform vec3 uLightDir;

        ${roundedRectGLSL}

        void main(){
          float inside = roundedMask(vUv, uRadius);
          if(inside < 0.5) discard;

          vec3 base = texture2D(uBack, vUv).rgb;

          vec3 n = normalize(vNormalW);
          vec3 L = normalize(uLightDir);
          vec3 V = normalize(uCamPos - vWorldPos);
          float NdotL = max(dot(n, L), 0.0);
          vec3 R = reflect(-L, n);
          float spec = pow(max(dot(R, V), 0.0), 40.0);

          vec3 lit = base * (0.35 + 0.85*NdotL) + vec3(1.0)*spec*0.06;
          gl_FragColor = vec4(lit, 1.0);
        }
      `
    });

    // ---------- thickness ----------
    const edgeMat = new THREE.MeshStandardMaterial({ color: 0x0e0f13, roughness: 0.85, metalness: 0.05 });
    const edgeGeo = new THREE.BoxGeometry(CARD_W, CARD_H, THICK);
    const edgeMesh = new THREE.Mesh(edgeGeo, edgeMat);
    scene.add(edgeMesh);

    // ---------- front/back planes ----------
    const planeGeo = new THREE.PlaneGeometry(CARD_W, CARD_H, 1, 1);

    const frontMesh = new THREE.Mesh(planeGeo, frontMat);
    frontMesh.position.z = THICK/2 + EPS;
    scene.add(frontMesh);

    const backMesh = new THREE.Mesh(planeGeo, backMat);
    backMesh.rotation.y = Math.PI;
    backMesh.position.z = -THICK/2 - EPS;
    scene.add(backMesh);

    // group transform
    const cardGroup = new THREE.Group();
    cardGroup.add(edgeMesh, frontMesh, backMesh);
    cardGroup.rotation.x = -0.05;
    scene.add(cardGroup);

    // ---------- UI ----------
    const UI = {
      preset: document.getElementById("preset"),
      reload: document.getElementById("reload"),
      resetAll: document.getElementById("resetAll"),
      resetView: document.getElementById("resetView"),
      frontFile: document.getElementById("frontFile"),
      heightFile: document.getElementById("heightFile"),
      fxHolo: document.getElementById("fxHolo"),
      fxHeight: document.getElementById("fxHeight"),
      fxMask: document.getElementById("fxMask"),
      emboss: document.getElementById("emboss"),
      holo: document.getElementById("holo"),
      band: document.getElementById("band"),
      grain: document.getElementById("grain"),
      radius: document.getElementById("radius"),
      exportHeight: document.getElementById("exportHeight"),
      exportMask: document.getElementById("exportMask"),
      toggleLog: document.getElementById("toggleLog"),
    };

    UI.toggleLog.onclick = () => {
      dbgBox.style.display = (dbgBox.style.display === "none") ? "block" : "none";
    };

    UI.resetView.onclick = () => {
      controls.target.set(0, 0.02, 0);
      camera.position.set(0.0, 0.05, 1.55);
      controls.update();
    };

    function applyUniformsFromUI(){
      uniforms.uEmboss.value = parseFloat(UI.emboss.value);
      uniforms.uHolo.value = parseFloat(UI.holo.value);
      uniforms.uBand.value = parseFloat(UI.band.value);
      uniforms.uGrain.value = parseFloat(UI.grain.value);
      uniforms.uRadius.value = parseFloat(UI.radius.value);

      uniforms.uEnableHolo.value = UI.fxHolo.checked ? 1 : 0;
      uniforms.uEnableHeight.value = UI.fxHeight.checked ? 1 : 0;
      uniforms.uEnableMask.value = UI.fxMask.checked ? 1 : 0;
    }
    for(const el of [UI.fxHolo,UI.fxHeight,UI.fxMask,UI.emboss,UI.holo,UI.band,UI.grain,UI.radius]){
      el.addEventListener("input", applyUniformsFromUI);
      el.addEventListener("change", applyUniformsFromUI);
    }

    function resetUI(){
      UI.fxHolo.checked = true;
      UI.fxHeight.checked = true;
      UI.fxMask.checked = true;
      UI.emboss.value = "2.60";
      UI.holo.value = "1.70";
      UI.band.value = "0.25";
      UI.grain.value = "1.15";
      UI.radius.value = "0.065";
      applyUniformsFromUI();
    }

    UI.resetAll.onclick = () => {
      resetUI();
      loadPreset(UI.preset.value);
      setStatus("Reset");
      log("✓ Reset done", "ok");
    };

    // ---------- uploads ----------
    function fileToImage(file){
      return new Promise((resolve,reject)=>{
        const url = URL.createObjectURL(file);
        const img = new Image();
        img.onload = ()=>{ URL.revokeObjectURL(url); resolve(img); };
        img.onerror = ()=>{ URL.revokeObjectURL(url); reject(new Error("Failed to read file: " + file.name)); };
        img.src = url;
      });
    }

    let lastGen = { heightCanvas:null, maskCanvas:null };

    async function setFrontImage(img, label="front"){
      uniforms.uFront.value = texFromImage(img);

      const gen = generateHeightAndMask(img);
      lastGen = gen;

      uniforms.uHeight.value = texFromCanvas(gen.heightCanvas);
      uniforms.uMask.value   = texFromCanvas(gen.maskCanvas);

      // Correct texel size for the height sampler (this is HUGE for emboss)
      uniforms.uTexel.value.set(1/gen.heightCanvas.width, 1/gen.heightCanvas.height);

      log(`✓ Front set (${label}) · auto height/mask generated`, "ok");
    }

    async function setBackImage(img){
      uniforms.uBack.value = texFromImage(img);
      log("✓ Back set", "ok");
    }

    UI.frontFile.onchange = async () => {
      if(!UI.frontFile.files?.length) return;
      try{
        setStatus("Loading front upload…");
        const img = await fileToImage(UI.frontFile.files[0]);
        await setFrontImage(img, "upload");
        setStatus("Ready");
      }catch(e){
        log("❌ " + e.message, "err");
        setStatus("Error");
      }
    };

    UI.heightFile.onchange = async () => {
      if(!UI.heightFile.files?.length) return;
      try{
        setStatus("Loading height upload…");
        const img = await fileToImage(UI.heightFile.files[0]);
        const { c } = canvasFromImage(img, 1024);
        uniforms.uHeight.value = texFromCanvas(c);
        uniforms.uTexel.value.set(1/c.width, 1/c.height);
        setStatus("Ready");
        log("✓ Height uploaded", "ok");
      }catch(e){
        log("❌ " + e.message, "err");
        setStatus("Error");
      }
    };

    // ---------- preset loading ----------
    async function loadPreset(which){
      dbgText.textContent = "";
      log("Preset: " + which);
      applyUniformsFromUI();
      try{
        setStatus("Loading images…");
        const [frontImg, backImg] = await Promise.all([
          loadImage(PRESETS[which]),
          loadImage(PATH_BACK)
        ]);
        log("✓ Loaded: " + PRESETS[which], "ok");
        log("✓ Loaded: " + PATH_BACK, "ok");

        await setFrontImage(frontImg, which);
        await setBackImage(backImg);

        setStatus("Ready");
      }catch(e){
        log("❌ " + e.message, "err");
        setStatus("Error");
      }
    }

    UI.reload.onclick = () => loadPreset(UI.preset.value);
    UI.preset.onchange = UI.reload.onclick;

    // ---------- export ----------
    function downloadCanvasPNG(c, filename){
      c.toBlob((blob)=>{
        const a = document.createElement("a");
        const url = URL.createObjectURL(blob);
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        a.remove();
        URL.revokeObjectURL(url);
      }, "image/png");
    }

    UI.exportHeight.onclick = () => {
      if(!lastGen.heightCanvas){ log("❌ No generated height to export yet.", "err"); return; }
      downloadCanvasPNG(lastGen.heightCanvas, "height.png");
      log("✓ Exported height.png", "ok");
    };

    UI.exportMask.onclick = () => {
      if(!lastGen.maskCanvas){ log("❌ No generated foil mask to export yet.", "err"); return; }
      downloadCanvasPNG(lastGen.maskCanvas, "foil-mask.png");
      log("✓ Exported foil-mask.png", "ok");
    };

    // ---------- loop ----------
    const clock = new THREE.Clock();
    function animate(){
      requestAnimationFrame(animate);
      uniforms.uTime.value = clock.getElapsedTime();
      uniforms.uCamPos.value.copy(camera.position);

      // keep light direction stable in view — you can later make it follow the camera if you want
      uniforms.uLightDir.value.set(0.65, 0.85, 1.05).normalize();

      controls.update();
      renderer.render(scene, camera);
    }
    animate();

    window.addEventListener("resize", () => {
      camera.aspect = window.innerWidth/window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // ---------- boot ----------
    resetUI();
    setStatus("Loading preset…");
    loadPreset(UI.preset.value);
  </script>
</body>
</html>
