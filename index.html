<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Card Viewer</title>
  <style>
    html, body { height: 100%; margin: 0; background:#050607; overflow:hidden; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; }
    #app { position:fixed; inset:0; }
    canvas { display:block; width:100%; height:100%; }

    /* Minimal top bar */
    #topbar{
      position:fixed; left:12px; right:12px; top: calc(10px + env(safe-area-inset-top));
      display:flex; gap:10px; align-items:center; justify-content:space-between;
      padding:10px 12px;
      border-radius:14px;
      background: rgba(15,16,18,.72);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      border: 1px solid rgba(255,255,255,.08);
      z-index: 10;
    }
    #topbar .left { display:flex; gap:10px; align-items:center; min-width:0; }
    #topbar .right { display:flex; gap:10px; align-items:center; }

    select, button {
      height: 38px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.06);
      color: #eaeaea;
      padding: 0 12px;
      font-size: 14px;
      outline: none;
    }
    select { max-width: 55vw; }
    button { cursor:pointer; }
    button:active { transform: translateY(1px); }

    /* On-screen debug console */
    #dbg {
      position: fixed;
      left: 12px;
      right: 12px;
      bottom: calc(12px + env(safe-area-inset-bottom));
      max-height: 32vh;
      overflow: auto;
      padding: 10px 12px;
      border-radius: 14px;
      background: rgba(0,0,0,.55);
      border: 1px solid rgba(255,255,255,.10);
      color: #d6d6d6;
      font: 12px/1.35 ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      z-index: 10;
      display:none;
      white-space: pre-wrap;
    }
    #dbg .line { margin: 0 0 6px 0; }
    #hint {
      position: fixed;
      left: 12px;
      right: 12px;
      top: calc(62px + env(safe-area-inset-top));
      z-index: 10;
      color: rgba(255,255,255,.65);
      font-size: 12px;
      text-align: center;
      pointer-events:none;
      text-shadow: 0 2px 10px rgba(0,0,0,.6);
    }
  </style>
</head>
<body>
  <div id="app"></div>

  <div id="topbar">
    <div class="left">
      <select id="preset">
        <option value="ray">Mega Rayquaza</option>
        <option value="blast">Mega Blastoise</option>
      </select>
      <button id="reload">Reload</button>
      <button id="toggleDbg">Debug</button>
    </div>
    <div class="right">
      <button id="reset">Reset View</button>
    </div>
  </div>

  <div id="hint">Drag to rotate • Pinch/scroll to zoom</div>
  <div id="dbg"></div>

  <script type="module">
    // ---------------------------
    // On-screen debug console
    // ---------------------------
    const dbgEl = document.getElementById('dbg');
    const toggleDbgBtn = document.getElementById('toggleDbg');
    function log(...args){
      const msg = args.map(a => (typeof a === 'string' ? a : JSON.stringify(a, null, 2))).join(' ');
      const div = document.createElement('div');
      div.className = 'line';
      div.textContent = msg;
      dbgEl.appendChild(div);
      dbgEl.scrollTop = dbgEl.scrollHeight;
      // Also log to JS console if available
      try { console.log(...args); } catch {}
    }
    function showDbg(v){ dbgEl.style.display = v ? 'block' : 'none'; }
    toggleDbgBtn.onclick = () => showDbg(dbgEl.style.display === 'none');

    window.addEventListener('error', (e) => {
      showDbg(true);
      log('❌ window.error:', e.message, (e.filename||''), (e.lineno||''), (e.colno||''));
    });
    window.addEventListener('unhandledrejection', (e) => {
      showDbg(true);
      log('❌ unhandledrejection:', (e.reason && e.reason.message) ? e.reason.message : String(e.reason));
    });

    // ---------------------------
    // Imports (libs structure)
    // ---------------------------
    let THREE, OrbitControls;
    try{
      THREE = await import('./libs/three.module.js');
      ({ OrbitControls } = await import('./libs/examples/jsm/controls/OrbitControls.js'));
      log('✅ Imports OK');
    }catch(err){
      showDbg(true);
      log('❌ Import failed. Check paths under /libs/. Error:', err?.message || String(err));
      throw err;
    }

    // ---------------------------
    // Helpers: safe textures
    // ---------------------------
    function make1x1RGBA(r,g,b,a=255, srgb=true){
      const data = new Uint8Array([r,g,b,a]);
      const t = new THREE.DataTexture(data, 1, 1, THREE.RGBAFormat);
      t.flipY = false;
      t.needsUpdate = true;
      t.colorSpace = srgb ? THREE.SRGBColorSpace : THREE.NoColorSpace;
      return t;
    }
    function make1x1Gray(v){
      return make1x1RGBA(v,v,v,255,false);
    }

    async function loadImage(url){
      return new Promise((resolve, reject) => {
        const img = new Image();
        img.crossOrigin = 'anonymous';
        img.onload = () => resolve(img);
        img.onerror = () => reject(new Error('Image failed: ' + url));
        img.src = url;
      });
    }

    async function loadTextureTry(urls, {srgb=true} = {}){
      let lastErr = null;
      for (const url of urls){
        try{
          const img = await loadImage(url);
          const tex = new THREE.Texture(img);
          tex.needsUpdate = true;
          tex.flipY = false;
          tex.colorSpace = srgb ? THREE.SRGBColorSpace : THREE.NoColorSpace;
          return { tex, url };
        }catch(e){
          lastErr = e;
          log('⚠️', e.message);
        }
      }
      throw lastErr || new Error('All texture attempts failed');
    }

    // ---------------------------
    // Auto height + foil mask from image
    // (works without ML, but looks "TCG-ish")
    // ---------------------------
    function canvasFromImage(img){
      const c = document.createElement('canvas');
      c.width = img.naturalWidth || img.width;
      c.height = img.naturalHeight || img.height;
      const ctx = c.getContext('2d', { willReadFrequently:true });
      ctx.drawImage(img, 0, 0);
      return { c, ctx };
    }

    // Create a height map guided by local detail (edges) + a non-tiling micro-emboss field
    function makeAutoHeight(img){
      const { c, ctx } = canvasFromImage(img);
      const w = c.width, h = c.height;

      // Downscale for speed
      const scale = Math.max(1, Math.floor(Math.max(w,h) / 900));
      const dw = Math.floor(w/scale), dh = Math.floor(h/scale);
      const d = document.createElement('canvas');
      d.width = dw; d.height = dh;
      const dctx = d.getContext('2d', { willReadFrequently:true });
      dctx.drawImage(c, 0, 0, dw, dh);

      const imgData = dctx.getImageData(0,0,dw,dh);
      const data = imgData.data;

      // grayscale + sobel-ish edge magnitude
      const gray = new Float32Array(dw*dh);
      for(let i=0;i<dw*dh;i++){
        const r = data[i*4+0], g = data[i*4+1], b = data[i*4+2];
        gray[i] = (0.2126*r + 0.7152*g + 0.0722*b) / 255;
      }

      const edge = new Float32Array(dw*dh);
      const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));
      for(let y=1;y<dh-1;y++){
        for(let x=1;x<dw-1;x++){
          const i = y*dw + x;
          // simple gradient magnitude
          const gx = gray[i+1] - gray[i-1];
          const gy = gray[i+dw] - gray[i-dw];
          let e = Math.sqrt(gx*gx + gy*gy);
          edge[i] = e;
        }
      }

      // Non-tiling micro emboss: value noise (deterministic) blurred via cheap neighborhood
      function hash(n){ n = (n<<13) ^ n; return (1.0 - ((n*(n*n*15731+789221)+1376312589) & 0x7fffffff) / 1073741824.0); }
      const micro = new Float32Array(dw*dh);
      for(let y=0;y<dh;y++){
        for(let x=0;x<dw;x++){
          const n = (x*374761393 + y*668265263) | 0;
          micro[y*dw+x] = (hash(n) * 0.5 + 0.5);
        }
      }
      // blur micro (3 passes box blur)
      const tmp = new Float32Array(dw*dh);
      for(let pass=0; pass<3; pass++){
        for(let y=1;y<dh-1;y++){
          for(let x=1;x<dw-1;x++){
            const i = y*dw+x;
            tmp[i] = (
              micro[i] + micro[i-1] + micro[i+1] +
              micro[i-dw] + micro[i+dw]
            ) / 5;
          }
        }
        micro.set(tmp);
      }

      // Combine:
      // - edges drive relief aligned with artwork
      // - micro gives subtle non-repeating texture
      const out = document.createElement('canvas');
      out.width = dw; out.height = dh;
      const outCtx = out.getContext('2d');
      const outData = outCtx.createImageData(dw, dh);

      // Normalize edge
      let emax = 1e-6;
      for(let i=0;i<edge.length;i++) emax = Math.max(emax, edge[i]);
      for(let i=0;i<edge.length;i++) edge[i] = edge[i] / emax;

      for(let i=0;i<dw*dh;i++){
        const g = gray[i];
        const e = edge[i];
        const m = micro[i];

        // “card-like”: backgrounds get more texture than flat text boxes
        // Use edge + a bit of inverted smooth grayscale
        let v = 0.55
          + (e * 0.55)          // detail follows art
          + ((1.0 - g) * 0.12)  // helps linework pop
          + ((m - 0.5) * 0.18); // micro emboss

        v = clamp(v, 0.0, 1.0);
        const u8 = Math.floor(v * 255);
        outData.data[i*4+0] = u8;
        outData.data[i*4+1] = u8;
        outData.data[i*4+2] = u8;
        outData.data[i*4+3] = 255;
      }
      outCtx.putImageData(outData,0,0);
      return out;
    }

    // Auto foil mask: reduce foil on saturated/dark foreground shapes, increase on flatter background.
    // This isn’t perfect segmentation, but it usually masks the Pokémon reasonably.
    function makeAutoFoilMask(img){
      const { c, ctx } = canvasFromImage(img);
      const w = c.width, h = c.height;

      const scale = Math.max(1, Math.floor(Math.max(w,h) / 900));
      const dw = Math.floor(w/scale), dh = Math.floor(h/scale);
      const d = document.createElement('canvas');
      d.width = dw; d.height = dh;
      const dctx = d.getContext('2d', { willReadFrequently:true });
      dctx.drawImage(c, 0, 0, dw, dh);

      const im = dctx.getImageData(0,0,dw,dh);
      const data = im.data;

      const out = document.createElement('canvas');
      out.width = dw; out.height = dh;
      const octx = out.getContext('2d');
      const od = octx.createImageData(dw, dh);

      const clamp = (v)=>Math.max(0,Math.min(1,v));

      for(let i=0;i<dw*dh;i++){
        const r = data[i*4+0]/255, g = data[i*4+1]/255, b = data[i*4+2]/255;
        const maxc = Math.max(r,g,b), minc = Math.min(r,g,b);
        const sat = (maxc - minc);                 // 0..1
        const lum = (0.2126*r + 0.7152*g + 0.0722*b); // 0..1

        // heuristic: flat/desaturated background -> higher foil
        // saturated/dark art -> lower foil
        let v = 0.78;
        v += (1.0 - sat) * 0.25;
        v += (lum - 0.5) * 0.08;
        v -= (sat * 0.35);
        v -= (Math.max(0, 0.45 - lum) * 0.45);

        v = clamp(v);

        const u8 = Math.floor(v*255);
        od.data[i*4+0]=u8; od.data[i*4+1]=u8; od.data[i*4+2]=u8; od.data[i*4+3]=255;
      }

      octx.putImageData(od,0,0);
      return out;
    }

    function canvasToTexture(canvas, {srgb=false} = {}){
      const tex = new THREE.CanvasTexture(canvas);
      tex.needsUpdate = true;
      tex.flipY = false;
      tex.colorSpace = srgb ? THREE.SRGBColorSpace : THREE.NoColorSpace;
      return tex;
    }

    // ---------------------------
    // THREE scene setup
    // ---------------------------
    const app = document.getElementById('app');
    const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:false });
    renderer.setPixelRatio(Math.min(2, window.devicePixelRatio || 1));
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    app.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x050607);

    const camera = new THREE.PerspectiveCamera(35, window.innerWidth/window.innerHeight, 0.01, 50);
    camera.position.set(0, 0, 2.35);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.06;
    controls.minDistance = 1.4;
    controls.maxDistance = 5.0;
    controls.enablePan = false;

    document.getElementById('reset').onclick = () => {
      camera.position.set(0, 0, 2.35);
      controls.target.set(0,0,0);
      controls.update();
    };

    const keyLight = new THREE.DirectionalLight(0xffffff, 1.15);
    keyLight.position.set(1.8, 1.3, 2.2);
    scene.add(keyLight);

    const fill = new THREE.DirectionalLight(0xffffff, 0.55);
    fill.position.set(-1.2, -0.6, 1.8);
    scene.add(fill);

    const amb = new THREE.AmbientLight(0xffffff, 0.25);
    scene.add(amb);

    // Rounded card geometry (ONLY rounded corners)
    function roundedRectShape(w, h, r){
      const s = new THREE.Shape();
      const x = -w/2, y = -h/2;
      s.moveTo(x+r, y);
      s.lineTo(x+w-r, y);
      s.quadraticCurveTo(x+w, y, x+w, y+r);
      s.lineTo(x+w, y+h-r);
      s.quadraticCurveTo(x+w, y+h, x+w-r, y+h);
      s.lineTo(x+r, y+h);
      s.quadraticCurveTo(x, y+h, x, y+h-r);
      s.lineTo(x, y+r);
      s.quadraticCurveTo(x, y, x+r, y);
      return s;
    }

    const CARD_W = 1.0;
    const CARD_H = 1.395; // Pokemon-ish
    const CORNER_R = 0.06;
    const shape = roundedRectShape(CARD_W, CARD_H, CORNER_R);

    // A denser geometry so displacement can look good
    const geo = new THREE.ShapeGeometry(shape, 140);
    geo.computeVertexNormals();

    // Border cut mask in shader (ensures no sharp alpha corners)
    // (We still use rounded geometry, but this makes the texture/holo extend cleanly to edge)
    function roundedRectMask(uv, r){
      // UV 0..1, convert to -0.5..0.5 with aspect in mind
      // We do a simple distance field for rounded rect.
      const p = `
        vec2 p = vUv - vec2(0.5);
        vec2 b = vec2(0.5 - ${r.toFixed(5)}, 0.5 - ${r.toFixed(5)});
        vec2 d = abs(p) - b;
        float outside = length(max(d,0.0)) - ${r.toFixed(5)};
        float mask = 1.0 - smoothstep(0.0, 0.004, outside);
      `;
      return p;
    }

    // Front material (custom shader: holo + foil mask + rounded clip + height displacement)
    const uniforms = {
      uMap: { value: make1x1RGBA(255,255,255,255,true) },
      uHeight: { value: make1x1Gray(128) },
      uFoilMask: { value: make1x1Gray(255) },
      uTime: { value: 0 },
      uReliefIntensity: { value: 2.2 },     // strong
      uFoilIntensity: { value: 2.0 },       // extreme
      uFoilBandWidth: { value: 0.25 },      // your “25% looks best”
      uFlipFoil: { value: 0.0 },            // for upside-down issues if needed
    };

    const frontMat = new THREE.ShaderMaterial({
      uniforms,
      transparent: false,
      side: THREE.FrontSide,
      vertexShader: `
        varying vec2 vUv;
        varying vec3 vN;
        uniform sampler2D uHeight;
        uniform float uReliefIntensity;
        void main(){
          vUv = uv;
          vec3 pos = position;
          vec3 n = normal;

          float h = texture2D(uHeight, vUv).r;
          float disp = (h - 0.5) * 0.026 * uReliefIntensity;
          pos += n * disp;

          vN = normalize(normalMatrix * n);
          gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
        }
      `,
      fragmentShader: `
        varying vec2 vUv;
        varying vec3 vN;

        uniform sampler2D uMap;
        uniform sampler2D uFoilMask;
        uniform float uTime;
        uniform float uFoilIntensity;
        uniform float uFoilBandWidth;
        uniform float uFlipFoil;

        // Cheap rainbow
        vec3 spectral(float t){
          return 0.5 + 0.5*cos(6.28318*(vec3(0.0,0.33,0.66)+t));
        }

        void main(){
          // Rounded clip so corners never show sharp edges
          vec2 p = vUv - vec2(0.5);
          float r = ${ (CORNER_R / CARD_W * 0.5).toFixed(6) }; // scaled-ish
          vec2 b = vec2(0.5 - r, 0.5 - r);
          vec2 d = abs(p) - b;
          float outside = length(max(d,0.0)) - r;
          float clip = 1.0 - smoothstep(0.0, 0.004, outside);
          if(clip < 0.01) discard;

          vec4 base = texture2D(uMap, vUv);

          // Foil mask (0..1)
          float fm = texture2D(uFoilMask, vUv).r;

          // View-based holo bands (wide)
          float ndv = clamp(dot(normalize(vN), vec3(0.0,0.0,1.0)), 0.0, 1.0);
          float band = (vUv.y * (1.0 - uFlipFoil) + (1.0 - vUv.y) * uFlipFoil);
          band += (1.0 - ndv) * 0.65;
          band += sin(uTime*0.6) * 0.03;

          // Wider = smaller frequency; band width acts like smoothing window
          float stripes = sin((band) * 6.28318 / max(uFoilBandWidth, 0.02));
          stripes = 0.5 + 0.5*stripes;

          vec3 holo = spectral(band*0.8 + stripes*0.35);
          holo *= (0.35 + 0.65*(1.0-ndv));

          // "Extreme" foil response
          float foilAmt = fm * uFoilIntensity;
          vec3 col = base.rgb;

          // Multiply + add for punch
          col = mix(col, col * (1.0 + holo*1.35), clamp(foilAmt, 0.0, 1.0));
          col += holo * 0.45 * foilAmt;

          // Subtle “paper/print” rolloff
          col *= (0.92 + 0.08*ndv);

          gl_FragColor = vec4(col, 1.0);
        }
      `
    });

    // Back material (simple)
    const backMat = new THREE.MeshStandardMaterial({
      map: make1x1RGBA(30,30,30,255,true),
      roughness: 0.9,
      metalness: 0.0,
      side: THREE.BackSide
    });

    // Single mesh with 2-sided materials using groups
    // ShapeGeometry is single group by default -> easiest: duplicate mesh
    const frontMesh = new THREE.Mesh(geo, frontMat);
    const backMesh  = new THREE.Mesh(geo, backMat);
    backMesh.rotation.y = Math.PI;

    // Slight separation so z-fighting never happens
    backMesh.position.z = -0.002;
    scene.add(frontMesh);
    scene.add(backMesh);

    // ---------------------------
    // Asset paths (case-robust)
    // ---------------------------
    function caseVariants(path){
      // if you pass ".../file.jpg" it will try jpg/JPG/jpeg/JPEG as well
      const dot = path.lastIndexOf('.');
      if(dot < 0) return [path];
      const base = path.slice(0,dot);
      const ext = path.slice(dot+1);
      const exts = new Set([
        ext,
        ext.toLowerCase(),
        ext.toUpperCase(),
        ext.toLowerCase().replace('jpeg','jpg'),
        ext.toLowerCase().replace('jpg','jpeg'),
        ext.toUpperCase().replace('JPEG','JPG'),
        ext.toUpperCase().replace('JPG','JPEG')
      ]);
      return Array.from(exts).map(e => `${base}.${e}`);
    }

    function presetFrontUrls(which){
      if(which === 'ray'){
        return caseVariants('./assets/presets/mega-rayquaza-front.JPG');
      }
      return caseVariants('./assets/presets/mega-blastoise-front.JPG');
    }

    function backUrls(){
      // your screenshot shows pokemon-back.jpg is in presets
      return [
        ...caseVariants('./assets/presets/pokemon-back.jpg'),
        ...caseVariants('./assets/presets/pokemon-back.JPG')
      ];
    }

    async function applyFrontFromUrl(urls){
      log('— Loading front…');
      const { tex, url } = await loadTextureTry(urls, { srgb:true });
      uniforms.uMap.value = tex;
      log('✅ Front loaded:', url);

      // Generate height + foil mask from the front image
      const img = tex.image;

      try{
        const heightCanvas = makeAutoHeight(img);
        uniforms.uHeight.value = canvasToTexture(heightCanvas, { srgb:false });
        log('✅ Auto height generated');
      }catch(e){
        showDbg(true);
        log('❌ Auto height failed:', e.message);
        uniforms.uHeight.value = make1x1Gray(128);
      }

      try{
        const foilCanvas = makeAutoFoilMask(img);
        uniforms.uFoilMask.value = canvasToTexture(foilCanvas, { srgb:false });
        log('✅ Auto foil mask generated');
      }catch(e){
        showDbg(true);
        log('❌ Auto foil mask failed:', e.message);
        uniforms.uFoilMask.value = make1x1Gray(255);
      }
    }

    async function applyBack(){
      log('— Loading back…');
      try{
        const { tex, url } = await loadTextureTry(backUrls(), { srgb:true });
        backMat.map = tex;
        backMat.needsUpdate = true;
        log('✅ Back loaded:', url);
      }catch(e){
        showDbg(true);
        log('❌ Back failed to load. Check path/case:', e.message);
      }
    }

    // Pattern upside-down fix toggle (if you ever need it)
    // 0.0 normal, 1.0 flips along Y
    uniforms.uFlipFoil.value = 0.0;

    async function loadPreset(){
      const which = document.getElementById('preset').value;
      showDbg(false);
      dbgEl.innerHTML = '';
      log('Preset:', which);

      try{
        await Promise.all([
          applyFrontFromUrl(presetFrontUrls(which)),
          applyBack()
        ]);
      }catch(e){
        showDbg(true);
        log('❌ Preset load failed:', e.message);
      }
    }

    document.getElementById('reload').onclick = loadPreset;
    document.getElementById('preset').onchange = loadPreset;

    // Full reset
    document.getElementById('reset').onclick = () => {
      camera.position.set(0, 0, 2.35);
      controls.target.set(0,0,0);
      controls.update();
      uniforms.uReliefIntensity.value = 2.2;
      uniforms.uFoilIntensity.value = 2.0;
      uniforms.uFoilBandWidth.value = 0.25;
      uniforms.uFlipFoil.value = 0.0;
      log('✅ Reset done');
    };

    // Resize
    window.addEventListener('resize', () => {
      renderer.setSize(window.innerWidth, window.innerHeight);
      camera.aspect = window.innerWidth/window.innerHeight;
      camera.updateProjectionMatrix();
    });

    // ---------------------------
    // Render loop
    // ---------------------------
    const clock = new THREE.Clock();
    function animate(){
      requestAnimationFrame(animate);
      uniforms.uTime.value = clock.getElapsedTime();
      controls.update();
      renderer.render(scene, camera);
    }
    animate();

    // First load
    await loadPreset();
  </script>
</body>
</html>
