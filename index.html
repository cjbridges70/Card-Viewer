<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Card Viewer (Stable • Studio Lighting BRIGHT)</title>
  <style>
    html,body{height:100%;margin:0;overflow:hidden;background:#0b0e12;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;}
    #hud{
      position:fixed;left:12px;top:12px;right:12px;z-index:10;
      display:flex;gap:10px;align-items:center;flex-wrap:wrap;
      color:#e7eefc;
    }
    .pill{
      background:rgba(18,20,26,.78);border:1px solid rgba(255,255,255,.10);
      border-radius:14px;padding:8px 10px;backdrop-filter:blur(10px);-webkit-backdrop-filter:blur(10px);
      box-shadow:0 10px 30px rgba(0,0,0,.35);
      display:flex;gap:8px;align-items:center;flex-wrap:wrap;
    }
    select,button,input{
      background:rgba(255,255,255,.06);border:1px solid rgba(255,255,255,.12);
      color:#e7eefc;border-radius:10px;padding:8px 10px;font-size:14px;
    }
    button{cursor:pointer}
    #status{margin-left:auto;opacity:.9}
    #log{
      position:fixed;left:12px;bottom:12px;width:min(720px,calc(100% - 24px));
      max-height:35vh;overflow:auto;white-space:pre-wrap;
      font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace;font-size:12px;line-height:1.25;
      color:#e7eefc;background:rgba(9,12,16,.72);border:1px solid rgba(255,255,255,.10);
      border-radius:14px;padding:10px 12px;backdrop-filter:blur(10px);-webkit-backdrop-filter:blur(10px);
      display:none;
    }
    #log.on{display:block}
    canvas{display:block;width:100%;height:100%}
    .small{font-size:12px;opacity:.85}
    input[type="range"]{padding:0}
  </style>
</head>
<body>
  <div id="hud">
    <div class="pill">
      <select id="preset">
        <option value="ray">Mega Rayquaza</option>
        <option value="blast">Mega Blastoise</option>
      </select>
      <button id="reload">Reload</button>
      <button id="reset">Reset View</button>
      <button id="toggleLog">Toggle Log</button>
    </div>

    <div class="pill">
      <label style="display:flex;gap:8px;align-items:center;">
        <span class="small">Corner</span>
        <input id="corner" type="range" min="0.030" max="0.070" step="0.001" value="0.048">
        <span id="cornerVal" class="small">0.048</span>
      </label>
    </div>

    <div class="pill">
      <label style="display:flex;gap:8px;align-items:center;">
        <span style="opacity:.85">Front upload</span>
        <input id="frontFile" type="file" accept="image/*">
      </label>
    </div>

    <div id="status" class="pill">Booting…</div>
  </div>

  <div id="log"></div>

  <script type="module">
    import * as THREE from './libs/three.module.js';

    const PATH_BACK = './assets/pokemon-back.jpg';
    const PRESETS = {
      ray:   './assets/presets/mega-rayquaza-front.JPG',
      blast: './assets/presets/mega-blastoise-front.JPG'
    };

    const logEl = document.getElementById('log');
    const statusEl = document.getElementById('status');
    function log(s){ logEl.textContent += s + "\\n"; logEl.scrollTop = logEl.scrollHeight; console.log(s); }
    function status(s){ statusEl.textContent = s; }
    document.getElementById('toggleLog').onclick = ()=> logEl.classList.toggle('on');

    // renderer
    const renderer = new THREE.WebGLRenderer({ antialias:true });
    renderer.setPixelRatio(Math.min(2, window.devicePixelRatio || 1));
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.toneMapping = THREE.NoToneMapping;
    document.body.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0b0e12);

    const camera = new THREE.PerspectiveCamera(40, window.innerWidth/window.innerHeight, 0.01, 50);
    camera.position.set(0, 0.06, 1.9);

    // STUDIO LIGHTING (very bright, flat)
    scene.add(new THREE.AmbientLight(0xffffff, 2.2));
    scene.add(new THREE.HemisphereLight(0xffffff, 0xffffff, 2.6));

    const topLight = new THREE.DirectionalLight(0xffffff, 4.5);
    topLight.position.set(0, 2.8, 0.2);
    scene.add(topLight);

    const frontLight = new THREE.DirectionalLight(0xffffff, 4.0);
    frontLight.position.set(0, 0.9, 3.0);
    scene.add(frontLight);

    const leftLight = new THREE.DirectionalLight(0xffffff, 2.4);
    leftLight.position.set(-3.2, 0.5, 1.6);
    scene.add(leftLight);

    const rightLight = new THREE.DirectionalLight(0xffffff, 2.4);
    rightLight.position.set(3.2, 0.5, 1.6);
    scene.add(rightLight);

    const bottomLight = new THREE.DirectionalLight(0xffffff, 1.6);
    bottomLight.position.set(0, -2.8, 1.2);
    scene.add(bottomLight);

    // tiny orbit controls
    const state = {
      target: new THREE.Vector3(0, 0.02, 0),
      yaw: 0.35, pitch: -0.10, dist: 1.9,
      dragging:false, lastX:0, lastY:0, pinchDist:0
    };
    function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
    function updateCamera(){
      const cp=Math.cos(state.pitch), sp=Math.sin(state.pitch);
      const cy=Math.cos(state.yaw),   sy=Math.sin(state.yaw);
      const x=state.dist*cp*sy, y=state.dist*sp, z=state.dist*cp*cy;
      camera.position.set(state.target.x+x, state.target.y+y, state.target.z+z);
      camera.lookAt(state.target);
    }
    updateCamera();

    const canvas = renderer.domElement;
    canvas.addEventListener('pointerdown', (e)=>{
      state.dragging=true; state.lastX=e.clientX; state.lastY=e.clientY;
      canvas.setPointerCapture(e.pointerId);
    });
    canvas.addEventListener('pointerup', (e)=>{
      state.dragging=false; try{canvas.releasePointerCapture(e.pointerId);}catch{}
    });
    canvas.addEventListener('pointermove', (e)=>{
      if(!state.dragging) return;
      const dx=e.clientX-state.lastX, dy=e.clientY-state.lastY;
      state.lastX=e.clientX; state.lastY=e.clientY;
      state.yaw -= dx*0.007;
      state.pitch += dy*0.007;
      state.pitch = clamp(state.pitch, -1.2, 0.9);
    });
    canvas.addEventListener('wheel', (e)=>{
      e.preventDefault();
      state.dist *= (e.deltaY>0)?1.06:0.94;
      state.dist = clamp(state.dist, 1.1, 4.5);
    }, {passive:false});

    // pinch zoom
    canvas.addEventListener('touchstart',(e)=>{
      if(e.touches.length===2){
        const dx=e.touches[0].clientX-e.touches[1].clientX;
        const dy=e.touches[0].clientY-e.touches[1].clientY;
        state.pinchDist=Math.sqrt(dx*dx+dy*dy);
      }
    },{passive:true});
    canvas.addEventListener('touchmove',(e)=>{
      if(e.touches.length===2){
        const dx=e.touches[0].clientX-e.touches[1].clientX;
        const dy=e.touches[0].clientY-e.touches[1].clientY;
        const d=Math.sqrt(dx*dx+dy*dy);
        const ratio=d/Math.max(1,state.pinchDist);
        state.dist/=ratio;
        state.dist=clamp(state.dist,1.1,4.5);
        state.pinchDist=d;
      }
    },{passive:true});

    document.getElementById('reset').onclick=()=>{
      state.yaw=0.35; state.pitch=-0.10; state.dist=1.9;
      updateCamera();
    };

    // rounded corners discard
    const roundedRectGLSL = `
      float roundedMask(vec2 uv, float r){
        vec2 p = uv * 2.0 - 1.0;
        float rx = r * 2.0;
        vec2 q = abs(p) - (vec2(1.0) - vec2(rx));
        float outside = length(max(q, 0.0)) - rx;
        return 1.0 - step(0.0, outside);
      }
    `;

    const uniforms = {
      uFront:{value:null},
      uBack:{value:null},
      uCorner:{value:0.048}
    };

    // brightness tuning (already working for you)
    const STUDIO_GAMMA = 0.78;
    const STUDIO_GAIN  = 1.45;

    const frontMat = new THREE.ShaderMaterial({
      uniforms, transparent:true, side:THREE.FrontSide,
      vertexShader:`varying vec2 vUv; void main(){ vUv=uv; gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0);} `,
      fragmentShader:`
        precision highp float;
        varying vec2 vUv;
        uniform sampler2D uFront;
        uniform float uCorner;
        ${roundedRectGLSL}
        void main(){
          float inside = roundedMask(vUv, uCorner);
          if(inside < 0.5) discard;
          vec3 base = texture2D(uFront, vUv).rgb;
          base = pow(base, vec3(${STUDIO_GAMMA.toFixed(4)}));
          base *= ${STUDIO_GAIN.toFixed(4)};
          base = clamp(base, 0.0, 1.0);
          gl_FragColor = vec4(base, 1.0);
        }
      `
    });

    const backMat = new THREE.ShaderMaterial({
      uniforms, transparent:true, side:THREE.FrontSide,
      vertexShader:`varying vec2 vUv; void main(){ vUv=vec2(1.0-uv.x, uv.y); gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0);} `,
      fragmentShader:`
        precision highp float;
        varying vec2 vUv;
        uniform sampler2D uBack;
        uniform float uCorner;
        ${roundedRectGLSL}
        void main(){
          float inside = roundedMask(vUv, uCorner);
          if(inside < 0.5) discard;
          vec3 base = texture2D(uBack, vUv).rgb;
          base = pow(base, vec3(${STUDIO_GAMMA.toFixed(4)}));
          base *= ${STUDIO_GAIN.toFixed(4)};
          base = clamp(base, 0.0, 1.0);
          gl_FragColor = vec4(base, 1.0);
        }
      `
    });

    // card meshes
    const W=1.0, H=W*(88/63);
    const geo = new THREE.PlaneGeometry(W, H, 1, 1);

    const group = new THREE.Group();
    const front = new THREE.Mesh(geo, frontMat); front.position.z = 0.003;
    const back  = new THREE.Mesh(geo, backMat);  back.rotation.y = Math.PI; back.position.z = -0.003;
    group.add(front, back);
    group.rotation.x = -0.04;
    scene.add(group);

    // Corner slider (for fine tuning)
    const cornerSlider = document.getElementById('corner');
    const cornerVal = document.getElementById('cornerVal');
    function setCorner(v){
      uniforms.uCorner.value = v;
      cornerVal.textContent = v.toFixed(3);
    }
    cornerSlider.addEventListener('input', ()=> setCorner(parseFloat(cornerSlider.value)));
    setCorner(parseFloat(cornerSlider.value));

    // textures
    const loader = new THREE.TextureLoader();
    function loadTex(url){
      return new Promise((resolve,reject)=>{
        loader.load(url, (t)=>{
          t.colorSpace = THREE.SRGBColorSpace;
          t.anisotropy = 8;
          t.wrapS = t.wrapT = THREE.ClampToEdgeWrapping;
          resolve(t);
        }, undefined, ()=>reject(new Error('Failed to load: ' + url)));
      });
    }

    async function loadPreset(which){
      try{
        status('Loading…'); logEl.textContent='';
        const f = PRESETS[which];
        const [frontT, backT] = await Promise.all([loadTex(f), loadTex(PATH_BACK)]);
        uniforms.uFront.value = frontT;
        uniforms.uBack.value  = backT;
        log('✓ Loaded: ' + f);
        log('✓ Loaded: ' + PATH_BACK);
        status('Ready');
      }catch(e){
        log('✗ ' + e.message);
        status('Error');
      }
    }

    document.getElementById('preset').addEventListener('change', (e)=> loadPreset(e.target.value));
    document.getElementById('reload').onclick = ()=> loadPreset(document.getElementById('preset').value);

    document.getElementById('frontFile').addEventListener('change', async (e)=>{
      const file = e.target.files?.[0];
      if(!file) return;
      status('Loading upload…');
      const url = URL.createObjectURL(file);
      try{
        const t = await loadTex(url);
        uniforms.uFront.value = t;
        log('✓ Loaded upload: ' + file.name);
        status('Ready');
      }catch(err){
        log('✗ ' + err.message);
        status('Error');
      }
    });

    window.addEventListener('resize', ()=>{
      camera.aspect = window.innerWidth/window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    function animate(){
      requestAnimationFrame(animate);
      updateCamera();
      renderer.render(scene, camera);
    }
    animate();

    status('Loading preset…');
    loadPreset('ray');
  </script>
</body>
</html>
