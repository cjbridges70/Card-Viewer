<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Card Viewer</title>
  <style>
    :root{
      --bg:#050607;
      --panel: rgba(20,22,26,.78);
      --stroke: rgba(255,255,255,.10);
      --text: rgba(255,255,255,.92);
      --muted: rgba(255,255,255,.70);
      --good: #6ee7b7;
      --warn: #fbbf24;
      --bad: #fb7185;
    }
    html,body{height:100%; margin:0; background:var(--bg); color:var(--text); font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;}
    #app{position:fixed; inset:0; overflow:hidden;}
    canvas{display:block; width:100%; height:100%;}
    /* top bar */
    #topbar{
      position:fixed;
      left: max(10px, env(safe-area-inset-left));
      right:max(10px, env(safe-area-inset-right));
      top: max(10px, env(safe-area-inset-top));
      display:flex;
      gap:10px;
      align-items:center;
      padding:10px;
      border:1px solid var(--stroke);
      border-radius:14px;
      background: rgba(10,12,14,.55);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      z-index: 10;
    }
    #topbar .pill{
      display:flex; align-items:center; gap:8px;
      padding:8px 10px;
      border-radius:12px;
      background: rgba(255,255,255,.06);
      border:1px solid var(--stroke);
      min-height: 38px;
    }
    select, button, input[type=file]{
      background: rgba(0,0,0,.25);
      color:var(--text);
      border:1px solid var(--stroke);
      border-radius:10px;
      padding:8px 10px;
      outline:none;
      font-size:14px;
    }
    button{cursor:pointer}
    button:active{transform: translateY(1px);}
    #hint{
      position:fixed;
      left:50%; transform: translateX(-50%);
      top: calc(max(10px, env(safe-area-inset-top)) + 70px);
      padding:8px 10px;
      border:1px solid var(--stroke);
      border-radius:999px;
      background: rgba(10,12,14,.55);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      color: var(--muted);
      font-size: 13px;
      z-index: 9;
      pointer-events:none;
    }
    /* right panel */
    #panel{
      position:fixed;
      right: max(10px, env(safe-area-inset-right));
      top: calc(max(10px, env(safe-area-inset-top)) + 70px);
      width: min(330px, calc(100vw - 20px));
      border:1px solid var(--stroke);
      border-radius:14px;
      background: var(--panel);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      padding:12px;
      z-index: 10;
    }
    #panel h3{margin:0 0 10px 0; font-size:13px; font-weight:600; color:var(--muted);}
    .row{display:flex; gap:10px; align-items:center; margin:8px 0;}
    .row label{flex:1; font-size:13px; color:var(--muted);}
    .row input[type=range]{flex:1.6}
    .row .val{width:44px; text-align:right; font-variant-numeric: tabular-nums; color:var(--muted); font-size:12px;}
    .toggle{display:flex; align-items:center; gap:8px; padding:8px 10px; border:1px solid var(--stroke); border-radius:12px; background: rgba(255,255,255,.06);}
    .toggle input{transform: scale(1.15);}
    #log{
      margin-top:10px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size:12px;
      color: rgba(255,255,255,.80);
      background: rgba(0,0,0,.25);
      border:1px solid var(--stroke);
      border-radius:12px;
      padding:10px;
      max-height: 22vh;
      overflow:auto;
      white-space:pre-wrap;
    }
    .ok{color:var(--good)}
    .warn{color:var(--warn)}
    .bad{color:var(--bad)}
    /* mobile friendliness */
    @media (max-width: 900px){
      #panel{width: min(360px, calc(100vw - 20px));}
    }
  </style>
</head>
<body>
<div id="app"></div>

<div id="topbar">
  <div class="pill">
    <select id="preset">
      <option value="ray">Mega Rayquaza</option>
      <option value="blast">Mega Blastoise</option>
    </select>
    <button id="reload">Reload</button>
  </div>

  <div class="pill" style="flex:1; justify-content:space-between;">
    <span id="status" style="color:var(--muted); font-size:13px;">Ready</span>
    <button id="resetView">Reset View</button>
  </div>
</div>

<div id="hint">Drag to rotate • Pinch/scroll to zoom</div>

<div id="panel">
  <h3>Images</h3>
  <div class="row" style="align-items:flex-start;">
    <label>Front (upload)</label>
    <input id="frontFile" type="file" accept="image/*" />
  </div>
  <div class="row" style="align-items:flex-start;">
    <label>Height (optional)</label>
    <input id="heightFile" type="file" accept="image/*" />
  </div>

  <h3 style="margin-top:12px;">Effects</h3>
  <div class="row">
    <div class="toggle" style="flex:1;">
      <input id="useHolo" type="checkbox" checked />
      <label style="margin:0; flex:1; color:var(--text);">Holographic (front)</label>
    </div>
  </div>
  <div class="row">
    <div class="toggle" style="flex:1;">
      <input id="autoHeight" type="checkbox" checked />
      <label style="margin:0; flex:1; color:var(--text);">Auto Height + Micro-Emboss</label>
    </div>
  </div>
  <div class="row">
    <div class="toggle" style="flex:1;">
      <input id="autoFoilMask" type="checkbox" checked />
      <label style="margin:0; flex:1; color:var(--text);">Auto Foil Mask (protect subject)</label>
    </div>
  </div>

  <h3 style="margin-top:12px;">Tuning</h3>
  <div class="row">
    <label>Emboss Strength</label>
    <input id="emboss" type="range" min="0" max="3" step="0.01" value="2.25" />
    <div class="val" id="embossVal">2.25</div>
  </div>
  <div class="row">
    <label>Holo Intensity</label>
    <input id="holoI" type="range" min="0" max="3" step="0.01" value="2.2" />
    <div class="val" id="holoIVal">2.20</div>
  </div>
  <div class="row">
    <label>Holo Band Width</label>
    <input id="bandW" type="range" min="0.05" max="1" step="0.01" value="0.25" />
    <div class="val" id="bandWVal">0.25</div>
  </div>
  <div class="row">
    <label>Foil Grain</label>
    <input id="grain" type="range" min="0" max="2" step="0.01" value="1.35" />
    <div class="val" id="grainVal">1.35</div>
  </div>

  <div id="log"></div>
</div>

<script type="module">
  import * as THREE from './libs/three.module.js';
  import { OrbitControls } from './libs/examples/jsm/controls/OrbitControls.js';

  // -------------------------
  // Paths (case-sensitive!)
  // -------------------------
  const PRESETS = {
    ray:   { front: './assets/presets/mega-rayquaza-front.JPG' },
    blast: { front: './assets/presets/mega-blastoise-front.JPG' },
  };

  // Back is in /assets (NOT /assets/presets)
  const BACK_PATH = './assets/pokemon-back.jpg';

  // -------------------------
  // UI helpers
  // -------------------------
  const $ = (id)=>document.getElementById(id);
  const logEl = $('log');
  const statusEl = $('status');

  function setStatus(t){ statusEl.textContent = t; }
  function logLine(txt, cls=''){
    const span = document.createElement('div');
    span.textContent = txt;
    if (cls) span.className = cls;
    logEl.appendChild(span);
    logEl.scrollTop = logEl.scrollHeight;
  }
  function clearLog(){ logEl.textContent=''; }

  // -------------------------
  // Three.js setup
  // -------------------------
  const app = document.getElementById('app');
  const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:false });
  renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
  renderer.setSize(innerWidth, innerHeight);
  renderer.outputColorSpace = THREE.SRGBColorSpace;
  app.appendChild(renderer.domElement);

  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x050607);

  const camera = new THREE.PerspectiveCamera(36, innerWidth/innerHeight, 0.01, 100);
  camera.position.set(0, 0.05, 2.2);

  const controls = new OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;
  controls.dampingFactor = 0.06;
  controls.minDistance = 1.2;
  controls.maxDistance = 4.0;
  controls.enablePan = false;

  // Lights
  scene.add(new THREE.AmbientLight(0xffffff, 0.42));
  const key = new THREE.DirectionalLight(0xffffff, 1.05);
  key.position.set(1.2, 1.4, 1.6);
  scene.add(key);

  const rim = new THREE.DirectionalLight(0xffffff, 0.65);
  rim.position.set(-1.6, 0.4, -1.2);
  scene.add(rim);

  // Ground (subtle)
  const ground = new THREE.Mesh(
    new THREE.PlaneGeometry(20, 20),
    new THREE.MeshStandardMaterial({ color:0x0b0c0e, roughness:1, metalness:0 })
  );
  ground.rotation.x = -Math.PI/2;
  ground.position.y = -0.72;
  scene.add(ground);

  // -------------------------
  // Card geometry (rounded rectangle extrude)
  // -------------------------
  function roundedRectShape(w, h, r){
    const x = -w/2, y = -h/2;
    const s = new THREE.Shape();
    const rr = Math.min(r, w/2, h/2);
    s.moveTo(x+rr, y);
    s.lineTo(x+w-rr, y);
    s.quadraticCurveTo(x+w, y, x+w, y+rr);
    s.lineTo(x+w, y+h-rr);
    s.quadraticCurveTo(x+w, y+h, x+w-rr, y+h);
    s.lineTo(x+rr, y+h);
    s.quadraticCurveTo(x, y+h, x, y+h-rr);
    s.lineTo(x, y+rr);
    s.quadraticCurveTo(x, y, x+rr, y);
    return s;
  }

  const CARD_W = 1.0;
  const CARD_H = 1.38; // pokemon-ish
  const CARD_R = 0.075;
  const CARD_T = 0.02; // thickness

  const shape = roundedRectShape(CARD_W, CARD_H, CARD_R);
  const geom = new THREE.ExtrudeGeometry(shape, {
    depth: CARD_T,
    bevelEnabled: false,
    curveSegments: 18
  });

  // Center extrude so it's symmetric around z=0
  geom.translate(0, 0, -CARD_T/2);

  // Fix UVs for front/back faces: we’ll use custom materials on groups.
  geom.computeVertexNormals();

  // Groups: ExtrudeGeometry creates groups for faces, but not consistent across versions.
  // We'll use a single ShaderMaterial that handles front/back based on normal.
  // -------------------------

  // -------------------------
  // Texture loading
  // -------------------------
  const texLoader = new THREE.TextureLoader();
  function loadTexture(url){
    return new Promise((resolve, reject)=>{
      texLoader.load(url, (t)=>{
        t.colorSpace = THREE.SRGBColorSpace;
        t.anisotropy = Math.min(renderer.capabilities.getMaxAnisotropy(), 8);
        // Important: keep default flipY for image textures (usually correct)
        resolve(t);
      }, undefined, (e)=>reject(e));
    });
  }

  function loadImageToCanvas(fileOrUrl){
    return new Promise((resolve, reject)=>{
      const img = new Image();
      img.crossOrigin = 'anonymous';
      img.onload = ()=>{
        const c = document.createElement('canvas');
        c.width = img.naturalWidth;
        c.height = img.naturalHeight;
        const ctx = c.getContext('2d', { willReadFrequently:true });
        ctx.drawImage(img, 0, 0);
        resolve({ canvas:c, ctx, w:c.width, h:c.height });
      };
      img.onerror = ()=>reject(new Error('Image failed: ' + fileOrUrl));
      if (fileOrUrl instanceof File){
        img.src = URL.createObjectURL(fileOrUrl);
      } else {
        img.src = fileOrUrl;
      }
    });
  }

  // -------------------------
  // Auto height + emboss (image-guided + non-tiling micro)
  // -------------------------
  function clamp01(x){ return Math.max(0, Math.min(1, x)); }

  // tiny deterministic hash noise
  function hash2(x,y){
    let n = x*374761393 + y*668265263;
    n = (n ^ (n >> 13)) * 1274126177;
    return ((n ^ (n >> 16)) >>> 0) / 4294967295;
  }

  function makeMicroEmboss(w,h){
    // non-tiling micro grain + subtle waviness
    const c = document.createElement('canvas');
    c.width = w; c.height = h;
    const ctx = c.getContext('2d', { willReadFrequently:true });
    const img = ctx.createImageData(w,h);
    for (let y=0;y<h;y++){
      for (let x=0;x<w;x++){
        const i = (y*w+x)*4;
        // layered noise, NOT periodic
        const n1 = hash2(x,y);
        const n2 = hash2(x*3, y*3);
        const n3 = hash2(x*11, y*7);
        // gentle directional “foil grain”
        const dir = Math.sin((x*0.0021) + (y*0.0014) + n1*6.0);
        let v = (n1*0.45 + n2*0.35 + n3*0.20);
        v = v*0.7 + (dir*0.3 + 0.5)*0.3;
        const g = Math.floor(v*255);
        img.data[i]=img.data[i+1]=img.data[i+2]=g;
        img.data[i+3]=255;
      }
    }
    ctx.putImageData(img,0,0);
    return c;
  }

  function sobelEdges(gray, w, h){
    const out = new Float32Array(w*h);
    const gxK = [-1,0,1,-2,0,2,-1,0,1];
    const gyK = [-1,-2,-1,0,0,0,1,2,1];
    for (let y=1;y<h-1;y++){
      for (let x=1;x<w-1;x++){
        let gx=0, gy=0, k=0;
        for (let j=-1;j<=1;j++){
          for (let i=-1;i<=1;i++){
            const v = gray[(y+j)*w + (x+i)];
            gx += v * gxK[k];
            gy += v * gyK[k];
            k++;
          }
        }
        const mag = Math.sqrt(gx*gx + gy*gy);
        out[y*w+x] = mag;
      }
    }
    return out;
  }

  function dilate(mask, w, h, r){
    const out = new Uint8ClampedArray(w*h);
    for (let y=0;y<h;y++){
      for (let x=0;x<w;x++){
        let m = 0;
        for (let j=-r;j<=r;j++){
          const yy = y+j; if (yy<0||yy>=h) continue;
          for (let i=-r;i<=r;i++){
            const xx = x+i; if (xx<0||xx>=w) continue;
            m = Math.max(m, mask[yy*w+xx]);
          }
        }
        out[y*w+x] = m;
      }
    }
    return out;
  }

  function makeAutoMapsFromFront(frontCanvas, opts){
    const { w, h } = frontCanvas;
    const ctx = frontCanvas.getContext('2d', { willReadFrequently:true });
    const data = ctx.getImageData(0,0,w,h).data;

    // Grayscale + saturation
    const gray = new Float32Array(w*h);
    const sat = new Float32Array(w*h);
    for (let i=0, p=0; i<data.length; i+=4, p++){
      const r=data[i]/255, g=data[i+1]/255, b=data[i+2]/255;
      const max = Math.max(r,g,b), min = Math.min(r,g,b);
      const l = (0.2126*r + 0.7152*g + 0.0722*b);
      gray[p]=l;
      sat[p] = (max===0) ? 0 : (max-min)/max;
    }

    // Image-guided relief: emphasize edges + midtones, avoid pure whites/blacks (text borders still get relief)
    const edges = sobelEdges(gray,w,h);
    let eMax = 1e-6;
    for (let i=0;i<edges.length;i++) eMax = Math.max(eMax, edges[i]);
    const relief = new Float32Array(w*h);
    for (let i=0;i<w*h;i++){
      const g = gray[i];
      const e = edges[i]/eMax;
      // lift edges, plus subtle midtone bump
      const mid = 1.0 - Math.abs(g - 0.5)*2.0; // 0..1
      relief[i] = clamp01(0.55*e + 0.45*mid);
    }

    // Micro emboss (non-tiling)
    const micro = makeMicroEmboss(w,h);
    const mctx = micro.getContext('2d', { willReadFrequently:true });
    const mdata = mctx.getImageData(0,0,w,h).data;

    // Height map canvas
    const heightC = document.createElement('canvas');
    heightC.width=w; heightC.height=h;
    const hctx = heightC.getContext('2d', { willReadFrequently:true });
    const himg = hctx.createImageData(w,h);

    // Foil mask: heuristic to “protect subject”
    // High saturation + strong edges → likely subject; we *reduce* foil there when autoFoilMask is on.
    const rawMask = new Uint8ClampedArray(w*h);
    for (let i=0;i<w*h;i++){
      const e = clamp01(edges[i]/eMax);
      const s = sat[i];
      // subject likelihood
      const sub = clamp01((s-0.18)*2.2) * clamp01((e-0.10)*1.8);
      rawMask[i] = Math.floor(sub*255);
    }
    const subjectMask = dilate(rawMask, w, h, 3); // expand a bit so outlines are protected

    // Build final height (relief + micro), and foilMask (1=foil, 0=protected)
    const foilC = document.createElement('canvas');
    foilC.width=w; foilC.height=h;
    const fctx = foilC.getContext('2d', { willReadFrequently:true });
    const fimg = fctx.createImageData(w,h);

    const embossStrength = opts.embossStrength;

    for (let i=0, p=0; i<himg.data.length; i+=4, p++){
      const rel = relief[p];
      const mic = mdata[i]/255;

      // Height:
      // - relief dominates (matches image structure)
      // - micro adds “card stock” texture everywhere
      let H = clamp01(rel*0.78 + mic*0.22);
      // exaggerate
      H = clamp01(Math.pow(H, 0.65) * embossStrength);

      const g = Math.floor(H*255);
      himg.data[i]=himg.data[i+1]=himg.data[i+2]=g;
      himg.data[i+3]=255;

      // Foil mask: default = foil everywhere, but if autoFoilMask, reduce foil where subjectMask is high
      let foil = 1.0;
      if (opts.autoFoilMask){
        const sub = subjectMask[p]/255;
        foil = clamp01(1.0 - sub*0.85);
      }
      const fg = Math.floor(foil*255);
      fimg.data[i]=fimg.data[i+1]=fimg.data[i+2]=fg;
      fimg.data[i+3]=255;
    }

    hctx.putImageData(himg,0,0);
    fctx.putImageData(fimg,0,0);

    return { heightCanvas: heightC, foilMaskCanvas: foilC };
  }

  // Flip generated canvases vertically so they match the base image orientation in Three.js
  function canvasToFlippedCanvas(src){
    const c = document.createElement('canvas');
    c.width = src.width; c.height = src.height;
    const ctx = c.getContext('2d');
    ctx.translate(0, src.height);
    ctx.scale(1, -1);
    ctx.drawImage(src, 0, 0);
    return c;
  }

  function canvasTextureFromCanvas(c){
    const t = new THREE.CanvasTexture(c);
    // Canvas textures often appear vertically flipped depending on your pipeline.
    // We pre-flip the canvas itself, so keep flipY default.
    t.anisotropy = Math.min(renderer.capabilities.getMaxAnisotropy(), 8);
    t.colorSpace = THREE.SRGBColorSpace;
    return t;
  }

  // -------------------------
  // Shader (front/back + holo + emboss)
  // -------------------------
  const uniforms = {
    uFront: { value: null },
    uBack:  { value: null },
    uHeight:{ value: null },
    uFoilMask:{ value: null },

    uUseHolo: { value: 1 },
    uAutoHeight: { value: 1 },
    uHoloIntensity: { value: 2.2 },
    uBandWidth: { value: 0.25 },
    uGrain: { value: 1.35 },
    uEmboss: { value: 2.25 },

    uTime: { value: 0 },
    uLightDir: { value: new THREE.Vector3(0.6, 0.9, 0.8).normalize() },
  };

  const mat = new THREE.ShaderMaterial({
    uniforms,
    vertexShader: `
      varying vec2 vUv;
      varying vec3 vN;
      varying vec3 vWPos;
      void main(){
        vUv = uv;
        vN = normalize(normalMatrix * normal);
        vec4 wp = modelMatrix * vec4(position,1.0);
        vWPos = wp.xyz;
        gl_Position = projectionMatrix * viewMatrix * wp;
      }
    `,
    fragmentShader: `
      precision highp float;
      varying vec2 vUv;
      varying vec3 vN;
      varying vec3 vWPos;

      uniform sampler2D uFront;
      uniform sampler2D uBack;
      uniform sampler2D uHeight;
      uniform sampler2D uFoilMask;

      uniform float uUseHolo;
      uniform float uAutoHeight;
      uniform float uHoloIntensity;
      uniform float uBandWidth;
      uniform float uGrain;
      uniform float uEmboss;
      uniform float uTime;
      uniform vec3 uLightDir;

      // Simple hue shift rainbow
      vec3 rainbow(float t){
        return 0.55 + 0.45*cos(6.28318*(t + vec3(0.0, 0.33, 0.67)));
      }

      // Non-tiling-ish foil noise (world + uv mix)
      float nrand(vec2 p){
        return fract(sin(dot(p, vec2(127.1,311.7))) * 43758.5453);
      }

      void main(){
        vec3 N = normalize(vN);
        float facing = step(0.0, N.z); // front if N.z >= 0

        // Base UV for the art
        vec2 uv = vUv;

        // Sample base textures
        vec4 front = texture2D(uFront, uv);
        vec4 back  = texture2D(uBack,  uv);

        // Height/foil uv are already pre-flipped by canvasToFlippedCanvas,
        // so they should match the base art orientation.
        float h = texture2D(uHeight, uv).r; // 0..1
        float foilMask = texture2D(uFoilMask, uv).r;

        // Emboss: perturb normal using height gradient in UV space
        vec2 px = vec2(1.0/1024.0, 1.0/1024.0);
        float hx = texture2D(uHeight, uv + vec2(px.x, 0.0)).r - h;
        float hy = texture2D(uHeight, uv + vec2(0.0, px.y)).r - h;

        vec3 embN = normalize(N + vec3(-hx, -hy, 0.0) * (uEmboss*0.9) * uAutoHeight);

        // Lighting
        float diff = clamp(dot(embN, normalize(uLightDir)), 0.0, 1.0);
        float rim = pow(1.0 - clamp(dot(embN, vec3(0.0,0.0,1.0)), 0.0, 1.0), 2.0);

        // Holo bands: WIDE diagonal bands (band width default 0.25 per your note)
        float angle = 0.75; // diagonal
        float band = (uv.x*0.9 + uv.y*0.9)*angle;
        band += (vWPos.x*0.15 + vWPos.y*0.10);
        band += uTime*0.02;

        float bw = max(0.06, uBandWidth);
        float bands = smoothstep(0.5-bw, 0.5, fract(band)) - smoothstep(0.5, 0.5+bw, fract(band));
        bands = clamp(bands, 0.0, 1.0);

        // Foil grain: non-repeating by mixing world pos + uv
        float grain = nrand(uv*vec2(900.0, 700.0) + vWPos.xy*17.0);
        grain = pow(grain, 1.6);

        vec3 holo = rainbow(band*0.25);
        float holoAmt = uUseHolo * uHoloIntensity * (0.35 + 0.65*bands);
        holoAmt *= (0.55 + 0.45*diff);
        holoAmt *= (0.65 + 0.35*grain*uGrain);
        holoAmt *= foilMask; // respect mask (protect subject)

        // Composite
        vec3 base = mix(back.rgb, front.rgb, facing);

        // Add holo as an energetic overlay (more “modern”)
        vec3 outCol = base;
        outCol = mix(outCol, outCol + holo*holoAmt, facing); // holo front only

        // Spec highlights
        outCol += (0.10*diff + 0.08*rim) * vec3(1.0);

        // Mild contrast
        outCol = pow(outCol, vec3(0.98));

        gl_FragColor = vec4(outCol, 1.0);
      }
    `,
  });

  const card = new THREE.Mesh(geom, mat);
  card.rotation.y = 0.25;
  card.rotation.x = -0.08;
  scene.add(card);

  // -------------------------
  // State & loading pipeline
  // -------------------------
  let currentFrontURL = PRESETS.ray.front;
  let currentFrontFile = null;
  let currentHeightFile = null;

  async function loadAll(){
    clearLog();
    setStatus('Loading…');
    logLine('Loading textures…');

    // base back (exact path, no guessing)
    let backTex;
    try{
      backTex = await loadTexture(BACK_PATH);
      uniforms.uBack.value = backTex;
      logLine(`✓ Back loaded: ${BACK_PATH}`, 'ok');
    }catch(e){
      uniforms.uBack.value = new THREE.Texture(); // placeholder
      logLine(`✗ Back failed: ${BACK_PATH}`, 'bad');
      logLine('Make sure assets/pokemon-back.jpg is committed and pushed.', 'warn');
      setStatus('Back failed');
      // continue so front still renders
    }

    // front image
    let frontTex;
    try{
      frontTex = currentFrontFile ? await new Promise((res, rej)=>{
        const url = URL.createObjectURL(currentFrontFile);
        texLoader.load(url, (t)=>{
          t.colorSpace = THREE.SRGBColorSpace;
          t.anisotropy = Math.min(renderer.capabilities.getMaxAnisotropy(), 8);
          res(t);
        }, undefined, rej);
      }) : await loadTexture(currentFrontURL);

      uniforms.uFront.value = frontTex;
      logLine(`✓ Front loaded: ${currentFrontFile ? currentFrontFile.name : currentFrontURL}`, 'ok');
    }catch(e){
      uniforms.uFront.value = new THREE.Texture();
      logLine(`✗ Front failed`, 'bad');
      setStatus('Front failed');
      return;
    }

    // height + foil mask
    try{
      const opts = {
        embossStrength: parseFloat($('emboss').value),
        autoFoilMask: $('autoFoilMask').checked
      };

      let heightCanvas, foilMaskCanvas;

      if (currentHeightFile){
        // User provided height map: use it, still generate foil mask from front
        const { canvas: frontC } = await loadImageToCanvas(currentFrontFile ? currentFrontFile : currentFrontURL);
        const { canvas: heightC } = await loadImageToCanvas(currentHeightFile);

        // ensure same size by drawing height into front-sized canvas
        const hc = document.createElement('canvas');
        hc.width = frontC.width; hc.height = frontC.height;
        const hctx = hc.getContext('2d');
        hctx.drawImage(heightC, 0, 0, hc.width, hc.height);

        const { foilMaskCanvas: fm } = makeAutoMapsFromFront(frontC, opts);
        heightCanvas = hc;
        foilMaskCanvas = fm;

        logLine(`✓ Height loaded (user): ${currentHeightFile.name}`, 'ok');
      } else {
        // Auto-generate both from front
        const { canvas: frontC } = await loadImageToCanvas(currentFrontFile ? currentFrontFile : currentFrontURL);
        const maps = makeAutoMapsFromFront(frontC, opts);
        heightCanvas = maps.heightCanvas;
        foilMaskCanvas = maps.foilMaskCanvas;
        logLine(`✓ Auto height generated`, 'ok');
        logLine(`✓ Auto foil mask generated`, 'ok');
      }

      // Flip generated canvases vertically so patterns are not upside down
      const flippedH = canvasToFlippedCanvas(heightCanvas);
      const flippedF = canvasToFlippedCanvas(foilMaskCanvas);

      // Upload to GPU
      const ht = canvasTextureFromCanvas(flippedH);
      ht.colorSpace = THREE.SRGBColorSpace; // grayscale but fine
      const ft = canvasTextureFromCanvas(flippedF);
      ft.colorSpace = THREE.SRGBColorSpace;

      uniforms.uHeight.value = ht;
      uniforms.uFoilMask.value = ft;

    }catch(e){
      logLine(`✗ Auto maps failed: ${e.message}`, 'bad');
      // fallback
      const fallback = document.createElement('canvas');
      fallback.width = 4; fallback.height = 4;
      const ctx = fallback.getContext('2d');
      ctx.fillStyle = '#7f7f7f'; ctx.fillRect(0,0,4,4);
      const t = canvasTextureFromCanvas(fallback);
      uniforms.uHeight.value = t;
      uniforms.uFoilMask.value = t;
    }

    setStatus('Ready');
  }

  // -------------------------
  // UI wiring
  // -------------------------
  function syncVals(){
    $('embossVal').textContent = (+$('emboss').value).toFixed(2);
    $('holoIVal').textContent = (+$('holoI').value).toFixed(2);
    $('bandWVal').textContent = (+$('bandW').value).toFixed(2);
    $('grainVal').textContent = (+$('grain').value).toFixed(2);

    uniforms.uEmboss.value = +$('emboss').value;
    uniforms.uHoloIntensity.value = +$('holoI').value;
    uniforms.uBandWidth.value = +$('bandW').value;
    uniforms.uGrain.value = +$('grain').value;
    uniforms.uUseHolo.value = $('useHolo').checked ? 1 : 0;
    uniforms.uAutoHeight.value = $('autoHeight').checked ? 1 : 0;
  }

  $('emboss').addEventListener('input', ()=>{ syncVals(); if ($('autoHeight').checked) loadAll(); });
  $('holoI').addEventListener('input', syncVals);
  $('bandW').addEventListener('input', syncVals);
  $('grain').addEventListener('input', syncVals);

  $('useHolo').addEventListener('change', syncVals);
  $('autoHeight').addEventListener('change', ()=>{ syncVals(); loadAll(); });
  $('autoFoilMask').addEventListener('change', ()=>{ syncVals(); loadAll(); });

  $('preset').addEventListener('change', ()=>{
    const key = $('preset').value;
    currentFrontURL = PRESETS[key].front;
    currentFrontFile = null;
    $('frontFile').value = '';
    $('heightFile').value = '';
    currentHeightFile = null;
    loadAll();
  });

  $('frontFile').addEventListener('change', ()=>{
    const f = $('frontFile').files?.[0];
    if (!f) return;
    currentFrontFile = f;
    currentHeightFile = null;
    $('heightFile').value = '';
    loadAll();
  });

  $('heightFile').addEventListener('change', ()=>{
    const f = $('heightFile').files?.[0];
    currentHeightFile = f || null;
    loadAll();
  });

  $('reload').addEventListener('click', loadAll);

  $('resetView').addEventListener('click', ()=>{
    controls.reset();
    camera.position.set(0, 0.05, 2.2);
    card.rotation.set(-0.08, 0.25, 0);
  });

  // Resize
  addEventListener('resize', ()=>{
    renderer.setSize(innerWidth, innerHeight);
    camera.aspect = innerWidth/innerHeight;
    camera.updateProjectionMatrix();
  });

  // -------------------------
  // Render loop
  // -------------------------
  const clock = new THREE.Clock();
  function tick(){
    uniforms.uTime.value = clock.getElapsedTime();
    controls.update();
    renderer.render(scene, camera);
    requestAnimationFrame(tick);
  }

  syncVals();
  loadAll();
  tick();
</script>
</body>
</html>
