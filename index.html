<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>3D Card Viewer (Base)</title>
  <style>
    html, body { margin: 0; height: 100%; overflow: hidden; background: #0b0f14; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; }
    canvas { display: block; }
    #ui {
      position: fixed; top: 12px; left: 12px; z-index: 10;
      background: rgba(0,0,0,.58); color: #fff; padding: 12px; border-radius: 12px;
      backdrop-filter: blur(8px);
      display: grid; gap: 10px; min-width: 280px; max-width: min(92vw, 360px);
      box-shadow: 0 10px 30px rgba(0,0,0,.35);
    }
    #ui label { font-size: 12px; opacity: .95; display: grid; gap: 6px; }
    #ui small { opacity: .75; line-height: 1.25; }
    #status {
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      font-size: 11px;
      white-space: pre-wrap;
      background: rgba(255,255,255,.06);
      border: 1px solid rgba(255,255,255,.08);
      padding: 8px 10px;
      border-radius: 10px;
      max-height: 120px;
      overflow: auto;
      line-height: 1.25;
    }
  </style>
</head>
<body>
  <div id="ui">
    <div id="status">Loading…</div>

    <label>Front image (PNG/JPG)
      <input id="frontInput" type="file" accept="image/*" />
    </label>

    <label>Back image (PNG/JPG)
      <input id="backInput" type="file" accept="image/*" />
    </label>

    <small>
      Drag to rotate • Scroll to zoom • Right-drag to pan<br/>
      If you’re on iPhone: very large photos are auto-downscaled.
    </small>
  </div>

  <script type="module">
    // IMPORTANT: self-hosted modules (works reliably on iOS + GitHub Pages)
    import * as THREE from "./libs/three.module.js";
    import { OrbitControls } from "./libs/examples/jsm/controls/OrbitControls.js";

    const statusEl = document.getElementById("status");
    const log = (m) => statusEl.textContent = m + "\n" + statusEl.textContent;

    // ---- Quick WebGL check ----
    const test = document.createElement("canvas");
    const gl = test.getContext("webgl") || test.getContext("experimental-webgl");
    if (!gl) {
      statusEl.textContent = "WebGL not available in this browser.";
      throw new Error("WebGL not available");
    }
    log("WebGL: available ✅");

    // ---------- Renderer / Scene / Camera ----------
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    document.body.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    scene.fog = new THREE.Fog(0x0b0f14, 2.5, 10);

    const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.01, 100);
    camera.position.set(0, 0.35, 1.35);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.06;
    controls.minDistance = 0.6;
    controls.maxDistance = 3.0;
    controls.target.set(0, 0.05, 0);

    // ---------- Lights ----------
    scene.add(new THREE.AmbientLight(0xffffff, 0.5));

    const key = new THREE.DirectionalLight(0xffffff, 1.2);
    key.position.set(1.5, 2.0, 1.2);
    scene.add(key);

    const fill = new THREE.DirectionalLight(0xffffff, 0.6);
    fill.position.set(-1.8, 1.2, 1.6);
    scene.add(fill);

    const rim = new THREE.DirectionalLight(0x9bd5ff, 0.6);
    rim.position.set(0.0, 1.8, -2.0);
    scene.add(rim);

    // ---------- Rounded card geometry (extruded) ----------
    const cardWidth = 0.63;
    const cardHeight = 0.88;
    const cornerRadius = 0.045;
    const thickness = 0.02;

    function roundedRectShape(w, h, r) {
      const x = -w / 2, y = -h / 2;
      const shape = new THREE.Shape();
      const rr = Math.min(r, w / 2, h / 2);

      shape.moveTo(x + rr, y);
      shape.lineTo(x + w - rr, y);
      shape.quadraticCurveTo(x + w, y, x + w, y + rr);
      shape.lineTo(x + w, y + h - rr);
      shape.quadraticCurveTo(x + w, y + h, x + w - rr, y + h);
      shape.lineTo(x + rr, y + h);
      shape.quadraticCurveTo(x, y + h, x, y + h - rr);
      shape.lineTo(x, y + rr);
      shape.quadraticCurveTo(x, y, x + rr, y);

      return shape;
    }

    const shape = roundedRectShape(cardWidth, cardHeight, cornerRadius);
    const geom = new THREE.ExtrudeGeometry(shape, {
      depth: thickness,
      bevelEnabled: true,
      bevelThickness: 0.004,
      bevelSize: 0.004,
      bevelSegments: 3,
      curveSegments: 24
    });
    geom.translate(0, 0, -thickness / 2);
    geom.computeVertexNormals();

    // Planar UV for caps so textures display correctly
    geom.computeBoundingBox();
    const bb = geom.boundingBox;
    const size = new THREE.Vector3();
    bb.getSize(size);
    const pos = geom.attributes.position;
    const uv = [];
    for (let i = 0; i < pos.count; i++) {
      const x = pos.getX(i);
      const y = pos.getY(i);
      uv.push((x - bb.min.x) / size.x, (y - bb.min.y) / size.y);
    }
    geom.setAttribute("uv", new THREE.Float32BufferAttribute(uv, 2));

    // Rebuild groups so we can assign: edges, front, back
    geom.clearGroups();
    const index = geom.index;
    const normal = geom.attributes.normal;

    const side = [];
    const front = [];
    const back = [];

    for (let i = 0; i < index.count; i += 3) {
      const a = index.getX(i), b = index.getX(i+1), c = index.getX(i+2);
      const nz = (normal.getZ(a) + normal.getZ(b) + normal.getZ(c)) / 3;
      if (nz > 0.6) front.push(a,b,c);
      else if (nz < -0.6) back.push(a,b,c);
      else side.push(a,b,c);
    }

    const merged = new Uint32Array(side.length + front.length + back.length);
    merged.set(side, 0);
    merged.set(front, side.length);
    merged.set(back, side.length + front.length);

    geom.setIndex(new THREE.BufferAttribute(merged, 1));
    geom.addGroup(0, side.length, 0);
    geom.addGroup(side.length, front.length, 1);
    geom.addGroup(side.length + front.length, back.length, 2);

    // ---------- Materials ----------
    const texLoader = new THREE.TextureLoader();
    const defaultFront = texLoader.load("https://threejs.org/examples/textures/uv_grid_opengl.jpg");
    const defaultBack  = texLoader.load("https://threejs.org/examples/textures/uv_grid_directx.jpg");
    for (const t of [defaultFront, defaultBack]) {
      t.colorSpace = THREE.SRGBColorSpace;
      t.flipY = false;
      t.anisotropy = 8;
    }

    const edgeMat = new THREE.MeshStandardMaterial({ color: 0x1b222e, roughness: 0.9, metalness: 0.0 });
    const frontMat = new THREE.MeshStandardMaterial({ map: defaultFront, roughness: 0.6, metalness: 0.05 });
    const backMat  = new THREE.MeshStandardMaterial({ map: defaultBack,  roughness: 0.6, metalness: 0.05 });

    const card = new THREE.Mesh(geom, [edgeMat, frontMat, backMat]);
    card.rotation.x = -0.08;
    card.rotation.y = 0.55;
    scene.add(card);

    // Ground (for contrast)
    const ground = new THREE.Mesh(
      new THREE.PlaneGeometry(6, 6),
      new THREE.MeshStandardMaterial({ color: 0x0b0f14, roughness: 1, metalness: 0 })
    );
    ground.rotation.x = -Math.PI / 2;
    ground.position.y = -0.55;
    scene.add(ground);

    // ---------- iOS-safe texture upload ----------
    function makeTextureFromImg(img) {
      const tex = new THREE.Texture(img);
      tex.colorSpace = THREE.SRGBColorSpace;
      tex.flipY = false;
      tex.anisotropy = 8;
      tex.needsUpdate = true;
      return tex;
    }

    function downscaleImageToMax(img, maxSize) {
      const w0 = img.naturalWidth || img.width;
      const h0 = img.naturalHeight || img.height;
      const largest = Math.max(w0, h0);
      if (largest <= maxSize) return img;

      const scale = maxSize / largest;
      const w = Math.max(1, Math.round(w0 * scale));
      const h = Math.max(1, Math.round(h0 * scale));

      const canvas = document.createElement("canvas");
      canvas.width = w; canvas.height = h;
      const ctx = canvas.getContext("2d");
      ctx.drawImage(img, 0, 0, w, h);

      const out = new Image();
      out.src = canvas.toDataURL("image/jpeg", 0.92);
      return out;
    }

    async function loadImageFromFile(file) {
      const dataURL = await new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onerror = () => reject(new Error("FileReader failed"));
        reader.onload = () => resolve(reader.result);
        reader.readAsDataURL(file);
      });

      const img = await new Promise((resolve, reject) => {
        const im = new Image();
        im.onload = () => resolve(im);
        im.onerror = () => reject(new Error("Image decode failed"));
        im.src = dataURL;
      });

      return img;
    }

    async function loadTextureFromFile(file, maxSize = 2048) {
      const img = await loadImageFromFile(file);
      log(`Loaded: ${file.name} (${img.naturalWidth}x${img.naturalHeight})`);

      const maybeDown = downscaleImageToMax(img, maxSize);
      const finalImg = await new Promise((resolve, reject) => {
        if (maybeDown === img) return resolve(img);
        maybeDown.onload = () => resolve(maybeDown);
        maybeDown.onerror = () => reject(new Error("Downscaled image decode failed"));
      });

      if (finalImg !== img) log(`Downscaled to: ${finalImg.naturalWidth}x${finalImg.naturalHeight}`);
      return makeTextureFromImg(finalImg);
    }

    const frontInput = document.getElementById("frontInput");
    const backInput  = document.getElementById("backInput");

    frontInput.addEventListener("change", async (e) => {
      const file = e.target.files?.[0];
      if (!file) return;
      try {
        log(`Front upload: ${file.name}`);
        const tex = await loadTextureFromFile(file, 2048);
        if (frontMat.map) frontMat.map.dispose();
        frontMat.map = tex;
        frontMat.needsUpdate = true;
        log("Front applied ✅");
      } catch (err) {
        log("Front failed ❌ " + err.message);
        alert("Front texture failed: " + err.message);
      }
    });

    backInput.addEventListener("change", async (e) => {
      const file = e.target.files?.[0];
      if (!file) return;
      try {
        log(`Back upload: ${file.name}`);
        const tex = await loadTextureFromFile(file, 2048);
        if (backMat.map) backMat.map.dispose();
        backMat.map = tex;
        backMat.needsUpdate = true;
        log("Back applied ✅");
      } catch (err) {
        log("Back failed ❌ " + err.message);
        alert("Back texture failed: " + err.message);
      }
    });

    // ---------- Resize + loop ----------
    window.addEventListener("resize", () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    }
    animate();

    log("Viewer ready. Upload front/back images.");
  </script>
</body>
</html>
