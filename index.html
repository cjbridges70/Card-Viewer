<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Card Viewer</title>

  <!-- IMPORTANT: This makes OrbitControls' "from 'three'" work on GitHub Pages/iOS -->
  <script type="importmap">
  {
    "imports": {
      "three": "./libs/three.module.js"
    }
  }
  </script>

  <style>
    :root{
      --bg:#050608;
      --panel: rgba(20,22,28,.78);
      --panel2: rgba(20,22,28,.55);
      --text: rgba(255,255,255,.92);
      --muted: rgba(255,255,255,.65);
      --line: rgba(255,255,255,.12);
      --accent: rgba(120,170,255,.9);
      --radius: 14px;
    }

    html,body{height:100%; margin:0; background:var(--bg); overflow:hidden; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;}
    #wrap{position:fixed; inset:0;}
    canvas{display:block; width:100%; height:100%;}

    /* Top bar */
    #topbar{
      position:fixed;
      left: max(10px, env(safe-area-inset-left));
      right: max(10px, env(safe-area-inset-right));
      top: max(10px, env(safe-area-inset-top));
      display:flex; gap:10px; align-items:center;
      padding:10px 12px;
      background: var(--panel2);
      border: 1px solid var(--line);
      border-radius: var(--radius);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      z-index:10;
    }
    #topbar .pill{
      display:flex; align-items:center; gap:8px;
      padding:8px 10px;
      background: rgba(0,0,0,.25);
      border: 1px solid var(--line);
      border-radius: 999px;
      color:var(--text);
    }
    select, button, input[type="range"]{font:inherit;}
    select{
      background: transparent;
      color: var(--text);
      border: none;
      outline: none;
      appearance: none;
      padding-right: 18px;
    }
    button{
      background: rgba(0,0,0,.25);
      color: var(--text);
      border: 1px solid var(--line);
      border-radius: 999px;
      padding: 8px 12px;
      cursor:pointer;
    }
    button:active{transform: translateY(1px);}
    #status{margin-left:auto; color: var(--muted); font-size: 13px;}

    /* Right panel */
    #panel{
      position:fixed;
      right: max(10px, env(safe-area-inset-right));
      top: max(64px, env(safe-area-inset-top) + 54px);
      width: min(360px, calc(100vw - 20px));
      background: var(--panel);
      border: 1px solid var(--line);
      border-radius: var(--radius);
      padding: 12px;
      color: var(--text);
      z-index:10;
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
    }
    .group{padding:10px; border:1px solid var(--line); border-radius: 12px; margin-top:10px; background: rgba(0,0,0,.18);}
    .group h3{margin:0 0 8px 0; font-size:13px; color:var(--muted); font-weight:600; letter-spacing:.2px;}
    .row{display:flex; align-items:center; justify-content:space-between; gap:10px; margin:8px 0;}
    .row label{font-size:13px; color:var(--text);}
    .row .val{font-size:12px; color: var(--muted); width: 44px; text-align:right;}
    input[type="checkbox"]{transform: scale(1.1);}
    input[type="range"]{width: 170px;}
    .hint{font-size:12px; color: var(--muted); line-height:1.3;}
    #log{
      margin-top:10px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 12px;
      color: rgba(255,255,255,.75);
      white-space: pre-wrap;
      background: rgba(0,0,0,.28);
      border: 1px solid var(--line);
      border-radius: 12px;
      padding: 10px;
      max-height: 22vh;
      overflow:auto;
    }

    /* Mobile: allow panel to be collapsed */
    #collapseBtn{display:none;}
    @media (max-width: 820px){
      #panel{
        left: max(10px, env(safe-area-inset-left));
        right: max(10px, env(safe-area-inset-right));
        width: auto;
      }
      #collapseBtn{display:inline-flex;}
    }
    .hidden{display:none !important;}
  </style>
</head>

<body>
<div id="wrap"></div>

<div id="topbar">
  <div class="pill">
    <select id="preset">
      <option value="ray">Mega Rayquaza</option>
      <option value="blast">Mega Blastoise</option>
    </select>
  </div>

  <button id="reload">Reload</button>
  <button id="resetView">Reset View</button>
  <button id="collapseBtn">Panel</button>

  <div id="status">Ready</div>
</div>

<div id="panel">
  <div class="group">
    <h3>Effects</h3>
    <div class="row">
      <label><input id="chkHolo" type="checkbox" checked /> Holographic (front)</label>
      <span class="val"></span>
    </div>
    <div class="row">
      <label><input id="chkAutoHeight" type="checkbox" checked /> Auto Height + Micro-Emboss</label>
      <span class="val"></span>
    </div>
    <div class="row">
      <label><input id="chkFoilMask" type="checkbox" checked /> Auto Foil Mask (protect subject)</label>
      <span class="val"></span>
    </div>
    <div class="hint">
      “Auto Height” produces image-guided relief + non-tiling micro-emboss (avoids obvious repeating waves).
      “Auto Foil Mask” tries to keep the subject less foiled than the background.
    </div>
  </div>

  <div class="group">
    <h3>Tuning</h3>

    <div class="row">
      <label>Emboss Strength</label>
      <input id="sEmboss" type="range" min="0" max="3" step="0.01" value="2.25" />
      <div class="val" id="vEmboss">2.25</div>
    </div>

    <div class="row">
      <label>Holo Intensity</label>
      <input id="sHolo" type="range" min="0" max="3" step="0.01" value="2.20" />
      <div class="val" id="vHolo">2.20</div>
    </div>

    <div class="row">
      <label>Holo Band Width</label>
      <input id="sBand" type="range" min="0.05" max="0.70" step="0.01" value="0.25" />
      <div class="val" id="vBand">0.25</div>
    </div>

    <div class="row">
      <label>Foil Grain</label>
      <input id="sGrain" type="range" min="0" max="2.5" step="0.01" value="1.35" />
      <div class="val" id="vGrain">1.35</div>
    </div>

    <div class="hint">Your “band width @ 25%” preference is set as default here.</div>
  </div>

  <div id="log"></div>
</div>

<script type="module">
  import * as THREE from "three";
  import { OrbitControls } from "./libs/examples/jsm/controls/OrbitControls.js";

  // ---------- File paths (exactly your structure) ----------
  const PRESETS = {
    ray: {
      front: "./assets/presets/mega-rayquaza-front.JPG"
    },
    blast: {
      front: "./assets/presets/mega-blastoise-front.JPG"
    }
  };
  const BACK_URL = "./assets/pokemon-back.jpg";

  // ---------- UI helpers ----------
  const $ = (id)=>document.getElementById(id);
  const logEl = $("log");
  const statusEl = $("status");

  function log(msg){
    logEl.textContent = (logEl.textContent ? logEl.textContent + "\n" : "") + msg;
    logEl.scrollTop = logEl.scrollHeight;
  }
  function status(msg){ statusEl.textContent = msg; }

  // ---------- Three.js setup ----------
  const wrap = document.getElementById("wrap");
  const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:false });
  renderer.setPixelRatio(Math.min(2, window.devicePixelRatio || 1));
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.outputColorSpace = THREE.SRGBColorSpace;
  wrap.appendChild(renderer.domElement);

  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x050608);

  const camera = new THREE.PerspectiveCamera(40, window.innerWidth/window.innerHeight, 0.01, 100);
  camera.position.set(0, 0.22, 1.25);

  const controls = new OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;
  controls.dampingFactor = 0.08;
  controls.enablePan = false;
  controls.minDistance = 0.5;
  controls.maxDistance = 3.5;

  // lighting (simple but “real card” friendly)
  const key = new THREE.DirectionalLight(0xffffff, 1.2);
  key.position.set(1.2, 1.2, 1.2);
  scene.add(key);

  const fill = new THREE.DirectionalLight(0xffffff, 0.55);
  fill.position.set(-1.4, 0.6, 0.8);
  scene.add(fill);

  const rim = new THREE.DirectionalLight(0xffffff, 0.65);
  rim.position.set(0.0, -0.6, -1.2);
  scene.add(rim);

  const ambient = new THREE.AmbientLight(0xffffff, 0.18);
  scene.add(ambient);

  // ---------- Rounded card geometry (no sharp corners) ----------
  function roundedRectShape(w, h, r){
    const x = -w/2, y = -h/2;
    const s = new THREE.Shape();
    s.moveTo(x + r, y);
    s.lineTo(x + w - r, y);
    s.quadraticCurveTo(x + w, y, x + w, y + r);
    s.lineTo(x + w, y + h - r);
    s.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
    s.lineTo(x + r, y + h);
    s.quadraticCurveTo(x, y + h, x, y + h - r);
    s.lineTo(x, y + r);
    s.quadraticCurveTo(x, y, x + r, y);
    return s;
  }

  // Pokemon card-ish proportions
  const CARD_W = 0.63;
  const CARD_H = 0.88;
  const CARD_R = 0.045;  // corner radius
  const CARD_T = 0.012;  // thickness

  const shape = roundedRectShape(CARD_W, CARD_H, CARD_R);
  const geom = new THREE.ExtrudeGeometry(shape, {
    depth: CARD_T,
    bevelEnabled: false,
    curveSegments: 32,
    steps: 1
  });
  // center it
  geom.translate(0,0,-CARD_T/2);

  // Add clean UVs for front/back by projecting onto the shape plane
  // (ExtrudeGeometry already generates usable UVs for top/bottom; keep that.)

  // ---------- Materials (we swap maps after loading) ----------
  // Side: neutral gray plastic
  const sideMat = new THREE.MeshStandardMaterial({
    color: 0x2b2f38,
    metalness: 0.15,
    roughness: 0.65
  });

  // Front/back will be custom shader-ish via MeshPhysicalMaterial + maps
  const frontMat = new THREE.MeshPhysicalMaterial({
    color: 0xffffff,
    metalness: 0.0,
    roughness: 0.35,
    clearcoat: 1.0,
    clearcoatRoughness: 0.12,
    sheen: 0.0
  });

  const backMat = new THREE.MeshPhysicalMaterial({
    color: 0xffffff,
    metalness: 0.0,
    roughness: 0.42,
    clearcoat: 0.85,
    clearcoatRoughness: 0.2
  });

  // ExtrudeGeometry groups: typically [0]=front, [1]=back, [2]=sides
  const card = new THREE.Mesh(geom, [frontMat, backMat, sideMat]);
  scene.add(card);

  // ---------- Texture loading helpers ----------
  const loader = new THREE.TextureLoader();

  function loadTexture(url){
    return new Promise((resolve, reject)=>{
      loader.load(url, (tex)=>{
        tex.colorSpace = THREE.SRGBColorSpace;
        tex.anisotropy = Math.min(8, renderer.capabilities.getMaxAnisotropy());
        // Keep default flipY for TextureLoader maps (correct in most cases)
        resolve(tex);
      }, undefined, (err)=>reject(err));
    });
  }

  // ---------- Image processing (auto height + foil mask) ----------
  function makeCanvas(w,h){
    const c = document.createElement("canvas");
    c.width = w; c.height = h;
    return c;
  }

  function imgToCanvas(img){
    const c = makeCanvas(img.width, img.height);
    const g = c.getContext("2d", { willReadFrequently:true });
    g.drawImage(img, 0, 0);
    return { c, g };
  }

  function texToImage(tex){
    // TextureLoader gives an HTMLImageElement in tex.image on most browsers
    const img = tex.image;
    if (!img || !img.width) throw new Error("Texture image not ready");
    return img;
  }

  // Fast luminance
  function luminance(r,g,b){ return 0.2126*r + 0.7152*g + 0.0722*b; }

  // Simple separable blur (small radius) for stability
  function blurGray(src, w, h, radius){
    const tmp = new Float32Array(w*h);
    const out = new Float32Array(w*h);
    // horiz
    for(let y=0;y<h;y++){
      for(let x=0;x<w;x++){
        let acc=0, n=0;
        for(let k=-radius;k<=radius;k++){
          const xx = Math.min(w-1, Math.max(0, x+k));
          acc += src[y*w+xx];
          n++;
        }
        tmp[y*w+x] = acc/n;
      }
    }
    // vert
    for(let y=0;y<h;y++){
      for(let x=0;x<w;x++){
        let acc=0, n=0;
        for(let k=-radius;k<=radius;k++){
          const yy = Math.min(h-1, Math.max(0, y+k));
          acc += tmp[yy*w+x];
          n++;
        }
        out[y*w+x] = acc/n;
      }
    }
    return out;
  }

  // Non-tiling micro-emboss: domain-warped noise (no obvious repeats)
  function fbmNoise(w,h,seed=1337){
    let s = seed >>> 0;
    const rand = ()=> (s = (s*1664525 + 1013904223)>>>0) / 4294967296;
    const n = new Float32Array(w*h);
    for(let i=0;i<n.length;i++) n[i] = rand();
    // blur to make it “grain” not salt-pepper
    return blurGray(n, w, h, 2);
  }

  function generateAutoHeight(frontTex, strength){
    const img = texToImage(frontTex);
    const { c, g } = imgToCanvas(img);
    const w = c.width, h = c.height;

    const imgd = g.getImageData(0,0,w,h);
    const d = imgd.data;

    // base luminance
    const lum = new Float32Array(w*h);
    for(let i=0, p=0;i<d.length;i+=4,p++){
      lum[p] = luminance(d[i], d[i+1], d[i+2]) / 255;
    }

    // edge-ish relief: (lum - blurred lum)
    const blur = blurGray(lum, w, h, 4);
    const relief = new Float32Array(w*h);
    for(let i=0;i<relief.length;i++){
      relief[i] = lum[i] - blur[i];
    }

    // micro emboss: add non-tiling grain, lightly guided by lum so it “follows” image regions
    const grain = fbmNoise(w,h, 777);
    const micro = new Float32Array(w*h);
    for(let i=0;i<micro.length;i++){
      const guided = (0.35 + 0.65*lum[i]);      // stronger emboss in brighter/painted regions
      micro[i] = (grain[i] - 0.5) * guided;
    }
    const microBlur = blurGray(micro, w, h, 1);

    // combine + normalize
    let min=1e9, max=-1e9;
    const out = new Float32Array(w*h);
    for(let i=0;i<out.length;i++){
      const v = (relief[i]*1.6 + microBlur[i]*1.2) * strength;
      out[i] = v;
      if(v<min) min=v;
      if(v>max) max=v;
    }
    const range = Math.max(1e-6, max-min);

    // write height into grayscale image (0..255)
    const hc = makeCanvas(w,h);
    const hg = hc.getContext("2d", { willReadFrequently:true });
    const hImg = hg.createImageData(w,h);
    const hd = hImg.data;
    for(let i=0,p=0;i<hd.length;i+=4,p++){
      const nrm = (out[p]-min)/range;
      const v = Math.max(0, Math.min(255, Math.round(nrm*255)));
      hd[i]=hd[i+1]=hd[i+2]=v;
      hd[i+3]=255;
    }
    hg.putImageData(hImg,0,0);

    const heightTex = new THREE.CanvasTexture(hc);
    heightTex.colorSpace = THREE.NoColorSpace;
    heightTex.anisotropy = Math.min(8, renderer.capabilities.getMaxAnisotropy());
    return heightTex;
  }

  // Heuristic “protect subject” mask: high-detail + mid-sat center region tends to be subject
  function generateFoilMask(frontTex){
    const img = texToImage(frontTex);
    const { c, g } = imgToCanvas(img);
    const w = c.width, h = c.height;

    const imgd = g.getImageData(0,0,w,h);
    const d = imgd.data;

    const score = new Float32Array(w*h);

    // center bias
    const cx = w*0.5, cy = h*0.52;
    const invMax = 1 / Math.sqrt(cx*cx + cy*cy);

    // simple gradient magnitude + saturation + center bias
    const lum = new Float32Array(w*h);
    const sat = new Float32Array(w*h);
    for(let y=0;y<h;y++){
      for(let x=0;x<w;x++){
        const p = y*w+x;
        const i = p*4;
        const r=d[i]/255, gg=d[i+1]/255, b=d[i+2]/255;
        lum[p] = (0.2126*r + 0.7152*gg + 0.0722*b);
        const mx = Math.max(r,gg,b), mn = Math.min(r,gg,b);
        sat[p] = (mx-mn);
      }
    }

    for(let y=1;y<h-1;y++){
      for(let x=1;x<w-1;x++){
        const p = y*w+x;
        const gx = lum[p+1]-lum[p-1];
        const gy = lum[p+w]-lum[p-w];
        const grad = Math.min(1, Math.sqrt(gx*gx+gy*gy)*2.2);

        const dx = (x-cx), dy=(y-cy);
        const center = 1 - Math.min(1, Math.sqrt(dx*dx+dy*dy)*invMax);

        score[p] = (grad*0.65 + sat[p]*0.35) * (0.55 + 0.45*center);
      }
    }

    // blur score to make regions
    const blur = blurGray(score, w, h, 8);

    // threshold-ish to create “subject” region, then feather
    let mMin=1e9, mMax=-1e9;
    for(let i=0;i<blur.length;i++){ if(blur[i]<mMin)mMin=blur[i]; if(blur[i]>mMax)mMax=blur[i]; }
    const t = mMin + (mMax-mMin)*0.60;

    const mask = new Float32Array(w*h);
    for(let i=0;i<mask.length;i++){
      // subject=1, background=0
      mask[i] = blur[i] > t ? 1 : 0;
    }
    const feather = blurGray(mask, w, h, 10);

    // We want FOIL on background (1) and less on subject (0)
    const mc = makeCanvas(w,h);
    const mg = mc.getContext("2d", { willReadFrequently:true });
    const mImg = mg.createImageData(w,h);
    const md = mImg.data;
    for(let i=0,p=0;i<md.length;i+=4,p++){
      const subj = Math.max(0, Math.min(1, feather[p]));
      const foil = 1 - subj;
      const v = Math.round(foil*255);
      md[i]=md[i+1]=md[i+2]=v;
      md[i+3]=255;
    }
    mg.putImageData(mImg,0,0);

    const maskTex = new THREE.CanvasTexture(mc);
    maskTex.colorSpace = THREE.NoColorSpace;
    maskTex.anisotropy = Math.min(8, renderer.capabilities.getMaxAnisotropy());
    return maskTex;
  }

  // ---------- Holo shader-ish effect via onBeforeCompile ----------
  // We keep it simple: add view-dependent rainbow bands + grain, then multiply by foil mask.
  function applyHoloToMaterial(mat){
    mat.onBeforeCompile = (shader)=>{
      shader.uniforms.uHoloIntensity = { value: 2.2 };
      shader.uniforms.uBandWidth     = { value: 0.25 };
      shader.uniforms.uGrain         = { value: 1.35 };
      shader.uniforms.uTime          = { value: 0.0 };
      shader.uniforms.uFoilMask      = { value: null };

      shader.vertexShader = shader.vertexShader.replace(
        "#include <common>",
        `#include <common>
         varying vec2 vUv2;
         varying vec3 vPosW;
         varying vec3 vNormW;
        `
      ).replace(
        "#include <uv_vertex>",
        `#include <uv_vertex>
         vUv2 = uv;
        `
      ).replace(
        "#include <worldpos_vertex>",
        `#include <worldpos_vertex>
         #include <worldpos_vertex>
         vPosW = worldPosition.xyz;
         vNormW = normalize(mat3(modelMatrix) * normal);
        `
      );

      shader.fragmentShader = shader.fragmentShader.replace(
        "#include <common>",
        `#include <common>
         varying vec2 vUv2;
         varying vec3 vPosW;
         varying vec3 vNormW;
         uniform float uHoloIntensity;
         uniform float uBandWidth;
         uniform float uGrain;
         uniform float uTime;
         uniform sampler2D uFoilMask;

         float hash12(vec2 p){
           vec3 p3  = fract(vec3(p.xyx) * 0.1031);
           p3 += dot(p3, p3.yzx + 33.33);
           return fract((p3.x + p3.y) * p3.z);
         }

         vec3 rainbow(float t){
           // smooth spectrum
           return 0.6 + 0.4*cos(6.28318*(t + vec3(0.0, 0.33, 0.67)));
         }
        `
      );

      shader.fragmentShader = shader.fragmentShader.replace(
        "#include <output_fragment>",
        `
         // ----- Holo bands (wider bands when uBandWidth is larger) -----
         vec3 V = normalize(cameraPosition - vPosW);
         float ndv = clamp(dot(normalize(vNormW), V), 0.0, 1.0);

         // diagonal band coord (wide + soft, no tight striping)
         float bandCoord = (vUv2.x*0.85 + vUv2.y*0.65) + (1.0-ndv)*0.55;
         float bandW = max(0.02, uBandWidth);
         float bands = sin((bandCoord) * (3.14159 / bandW));   // lower frequency when width increases
         bands = 0.5 + 0.5*bands;

         // subtle moving shimmer
         float shimmer = 0.15 * sin((bandCoord + uTime*0.12) * 6.0);

         // grain (non-tiling-ish hash)
         float g = (hash12(vUv2*vec2(1200.0, 900.0) + uTime) - 0.5) * 2.0;
         g *= uGrain * 0.08;

         vec3 holo = rainbow(bandCoord + shimmer + g);
         holo *= (bands*0.85 + 0.15);

         // foil mask (white=foil, black=protected)
         float foil = 1.0;
         if (uFoilMask != sampler2D(0)) {
           foil = texture2D(uFoilMask, vUv2).r;
         }

         // combine: add holo into specular-looking boost
         vec3 base = outgoingLight;
         vec3 boost = holo * uHoloIntensity * foil;

         outgoingLight = base + boost * 0.25;

         gl_FragColor = vec4( outgoingLight, diffuseColor.a );
        `
      );

      mat.userData.shader = shader;
    };
    mat.needsUpdate = true;
  }

  applyHoloToMaterial(frontMat);

  // ---------- Build / rebuild card maps ----------
  let frontTex = null;
  let backTex  = null;
  let heightTex = null;
  let foilMaskTex = null;

  async function buildFromPreset(presetKey){
    logEl.textContent = "";
    status("Loading…");
    log(`Preset: ${presetKey}`);

    try{
      const preset = PRESETS[presetKey];
      log(`- Loading front: ${preset.front}`);
      frontTex = await loadTexture(preset.front);

      log(`- Loading back:  ${BACK_URL}`);
      backTex = await loadTexture(BACK_URL);

      // Assign base maps
      frontMat.map = frontTex;
      backMat.map = backTex;

      // Height/displacement
      if ($("chkAutoHeight").checked){
        const s = parseFloat($("sEmboss").value);
        log(`- Auto height generating (strength ${s.toFixed(2)})…`);
        heightTex = generateAutoHeight(frontTex, s);
        frontMat.displacementMap = heightTex;
        frontMat.displacementScale = 0.012;  // physical-ish emboss depth
        frontMat.normalMap = heightTex;      // cheap “extra pop”; ok for effect
        frontMat.normalScale = new THREE.Vector2(0.18,0.18);
      } else {
        frontMat.displacementMap = null;
        frontMat.normalMap = null;
      }

      // Foil mask
      if ($("chkFoilMask").checked){
        log(`- Auto foil mask generating…`);
        foilMaskTex = generateFoilMask(frontTex);
      } else {
        foilMaskTex = null;
      }

      // Hook shader uniforms if compiled
      // (we force a render after setting maps so onBeforeCompile runs)
      frontMat.needsUpdate = true;
      backMat.needsUpdate = true;

      // small tilt to look nice by default
      card.rotation.set(-0.15, 0.35, 0.0);

      status("Ready");
      log("✓ Loaded");
    } catch(e){
      console.error(e);
      status("Error");
      log(`❌ ${e?.message || e}`);
    }
  }

  // Update shader sliders
  function syncUI(){
    $("vEmboss").textContent = (+$("sEmboss").value).toFixed(2);
    $("vHolo").textContent   = (+$("sHolo").value).toFixed(2);
    $("vBand").textContent   = (+$("sBand").value).toFixed(2);
    $("vGrain").textContent  = (+$("sGrain").value).toFixed(2);
  }
  syncUI();

  // UI wiring
  $("preset").addEventListener("change", ()=>buildFromPreset($("preset").value));
  $("reload").addEventListener("click", ()=>buildFromPreset($("preset").value));
  $("resetView").addEventListener("click", ()=>{
    camera.position.set(0, 0.22, 1.25);
    controls.target.set(0,0,0);
    controls.update();
  });

  $("collapseBtn").addEventListener("click", ()=>{
    $("panel").classList.toggle("hidden");
  });

  for (const id of ["sEmboss","sHolo","sBand","sGrain"]) {
    $(id).addEventListener("input", ()=>{
      syncUI();
      // Rebuild height if emboss changes
      if (id === "sEmboss" && $("chkAutoHeight").checked && frontTex){
        heightTex = generateAutoHeight(frontTex, parseFloat($("sEmboss").value));
        frontMat.displacementMap = heightTex;
        frontMat.needsUpdate = true;
      }
    });
  }

  for (const id of ["chkHolo","chkAutoHeight","chkFoilMask"]) {
    $(id).addEventListener("change", ()=>{
      // simplest: rebuild everything from current preset when toggles change
      buildFromPreset($("preset").value);
    });
  }

  // ---------- Render loop ----------
  let t0 = performance.now();
  function animate(){
    requestAnimationFrame(animate);
    controls.update();

    const t = (performance.now() - t0) / 1000;

    // Drive holo uniforms + enable/disable
    const shader = frontMat.userData.shader;
    if (shader){
      const holoOn = $("chkHolo").checked ? 1.0 : 0.0;
      shader.uniforms.uHoloIntensity.value = parseFloat($("sHolo").value) * holoOn;
      shader.uniforms.uBandWidth.value     = parseFloat($("sBand").value);
      shader.uniforms.uGrain.value         = parseFloat($("sGrain").value);
      shader.uniforms.uTime.value          = t;
      shader.uniforms.uFoilMask.value      = foilMaskTex || null;
    }

    renderer.render(scene, camera);
  }

  // Resize
  window.addEventListener("resize", ()=>{
    renderer.setSize(window.innerWidth, window.innerHeight);
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
  });

  // Start
  buildFromPreset("ray");
  animate();
</script>
</body>
</html>
