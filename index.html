<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Card Viewer</title>
  <style>
    html, body { height: 100%; margin: 0; background: #07090d; overflow: hidden; }
    #app { position: fixed; inset: 0; }
    canvas { display: block; width: 100%; height: 100%; }

    /* Top bar */
    .topbar {
      position: fixed; left: 12px; right: 12px; top: 10px;
      display: flex; gap: 10px; align-items: center;
      padding: 10px 12px;
      background: rgba(20, 24, 33, 0.62);
      border: 1px solid rgba(255,255,255,0.10);
      border-radius: 14px;
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      z-index: 10;
      color: rgba(255,255,255,0.9);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      user-select: none;
    }
    .topbar .left { display: flex; gap: 10px; align-items: center; flex: 1; min-width: 0; }
    .topbar .right { display: flex; gap: 10px; align-items: center; }
    select, button, input[type="file"] {
      background: rgba(255,255,255,0.08);
      color: rgba(255,255,255,0.92);
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: 10px;
      padding: 8px 10px;
      font-size: 14px;
      outline: none;
    }
    button { cursor: pointer; }
    button:active { transform: translateY(1px); }

    /* Panel */
    .panel {
      position: fixed; right: 12px; top: 78px;
      width: min(360px, calc(100vw - 24px));
      background: rgba(20, 24, 33, 0.62);
      border: 1px solid rgba(255,255,255,0.10);
      border-radius: 16px;
      padding: 12px;
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      z-index: 10;
      color: rgba(255,255,255,0.9);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
    }
    .panel h3 { margin: 0 0 10px; font-size: 13px; letter-spacing: 0.04em; opacity: 0.9; }
    .row { display: grid; grid-template-columns: 1fr; gap: 8px; margin-bottom: 10px; }
    .row label { font-size: 12px; opacity: 0.85; display: flex; justify-content: space-between; align-items: center; gap: 10px;}
    .row small { opacity: 0.7; }
    .toggles { display: grid; grid-template-columns: 1fr; gap: 8px; margin: 10px 0; }
    .toggle {
      display: flex; align-items: center; justify-content: space-between;
      gap: 10px; padding: 10px 10px;
      background: rgba(255,255,255,0.06);
      border: 1px solid rgba(255,255,255,0.10);
      border-radius: 12px;
      font-size: 13px;
    }
    .toggle input { transform: scale(1.15); }
    .slider {
      display: grid; grid-template-columns: 1fr 70px;
      gap: 10px; align-items: center;
      margin: 8px 0;
      font-size: 12px;
      opacity: 0.9;
    }
    .slider input[type="range"] { width: 100%; }
    .slider .val { text-align: right; opacity: 0.9; }

    .hint {
      margin-top: 10px;
      font-size: 12px;
      opacity: 0.75;
      line-height: 1.35;
    }

    .log {
      position: fixed; left: 12px; bottom: 12px;
      width: min(520px, calc(100vw - 24px));
      background: rgba(10, 12, 18, 0.72);
      border: 1px solid rgba(255,255,255,0.10);
      border-radius: 16px;
      padding: 10px 12px;
      color: rgba(255,255,255,0.86);
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
      font-size: 12px;
      white-space: pre-wrap;
      max-height: 30vh;
      overflow: auto;
      display: none;
      z-index: 10;
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
    }
  </style>

  <!-- IMPORTANT: fix OrbitControls importing from 'three' -->
  <script type="importmap">
    {
      "imports": {
        "three": "./libs/three.module.js"
      }
    }
  </script>
</head>

<body>
  <div id="app"></div>

  <div class="topbar">
    <div class="left">
      <select id="preset">
        <option value="ray">Mega Rayquaza</option>
        <option value="blast">Mega Blastoise</option>
      </select>
      <button id="reload">Reload</button>
      <button id="resetView">Reset View</button>
      <button id="toggleLog">Toggle Log</button>
      <span id="status" style="opacity:.75; font-size:13px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;"></span>
    </div>
    <div class="right">
      <span style="opacity:.65; font-size:12px;">Drag to rotate • Pinch/scroll to zoom</span>
    </div>
  </div>

  <div class="panel">
    <h3>IMAGES</h3>
    <div class="row">
      <label>Front (upload) <small>(optional)</small> <input id="frontFile" type="file" accept="image/*"></label>
      <label>Height (grayscale) <small>(optional)</small> <input id="heightFile" type="file" accept="image/*"></label>
      <label>Mask <small>(optional)</small> <input id="maskFile" type="file" accept="image/*"></label>
    </div>

    <h3>EFFECTS</h3>
    <div class="toggles">
      <div class="toggle"><span>Holo (front)</span><input id="holoOn" type="checkbox" checked></div>
      <div class="toggle"><span>Emboss</span><input id="embossOn" type="checkbox" checked></div>
      <div class="toggle"><span>Auto-height</span><input id="autoHeightOn" type="checkbox" checked></div>
      <div class="toggle"><span>Auto-mask Pokémon</span><input id="autoMaskOn" type="checkbox" checked></div>
    </div>

    <h3>TUNING</h3>

    <div class="slider">
      <label for="holoStrength">Holo Strength</label>
      <div class="val" id="holoStrengthVal"></div>
      <input id="holoStrength" type="range" min="0" max="3" step="0.01" value="1.65" style="grid-column:1 / span 2;">
    </div>

    <div class="slider">
      <label for="holoReact">Holo Reactivity (1:1 tilt)</label>
      <div class="val" id="holoReactVal"></div>
      <input id="holoReact" type="range" min="0" max="2.5" step="0.01" value="1.75" style="grid-column:1 / span 2;">
    </div>

    <div class="slider">
      <label for="embossStrength">Emboss Strength (legible)</label>
      <div class="val" id="embossStrengthVal"></div>
      <input id="embossStrength" type="range" min="0" max="4" step="0.01" value="1.35" style="grid-column:1 / span 2;">
    </div>

    <div class="hint">
      This version keeps the holo “wavy” but anchors it to the card surface and drives it by view angle (no time-sweep).
      Emboss affects normals/specular only, so text stays readable.
    </div>
  </div>

  <div class="log" id="log"></div>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from './libs/examples/jsm/controls/OrbitControls.js';

    // ---------- Utilities ----------
    const $ = (id) => document.getElementById(id);
    const logEl = $('log');
    const statusEl = $('status');

    function logLine(msg) {
      logEl.textContent += msg + "\\n";
      logEl.scrollTop = logEl.scrollHeight;
      console.log(msg);
    }

    function setStatus(msg) {
      statusEl.textContent = msg;
    }

    function clamp01(x){ return Math.min(1, Math.max(0, x)); }

    async function loadImageBitmapFromUrl(url) {
      const res = await fetch(url, { cache: 'no-cache' });
      if (!res.ok) throw new Error(`Fetch failed: ${url} (${res.status})`);
      const blob = await res.blob();
      return await createImageBitmap(blob);
    }

    async function loadImageBitmapFromFile(file) {
      const bmp = await createImageBitmap(file);
      return bmp;
    }

    function bitmapToTexture(bmp, { srgb = true } = {}) {
      const tex = new THREE.Texture(bmp);
      tex.needsUpdate = true;
      tex.wrapS = tex.wrapT = THREE.ClampToEdgeWrapping;
      tex.minFilter = THREE.LinearMipmapLinearFilter;
      tex.magFilter = THREE.LinearFilter;
      tex.anisotropy = 8;
      tex.colorSpace = srgb ? THREE.SRGBColorSpace : THREE.NoColorSpace;
      return tex;
    }

    function makeCanvas(w, h) {
      const c = document.createElement('canvas');
      c.width = w; c.height = h;
      return c;
    }

    function getImageDataFromBitmap(bmp) {
      const c = makeCanvas(bmp.width, bmp.height);
      const ctx = c.getContext('2d', { willReadFrequently: true });
      ctx.drawImage(bmp, 0, 0);
      return ctx.getImageData(0, 0, bmp.width, bmp.height);
    }

    function imageDataToTexture(imgData, { srgb = false } = {}) {
      const c = makeCanvas(imgData.width, imgData.height);
      c.getContext('2d').putImageData(imgData, 0, 0);
      const tex = new THREE.CanvasTexture(c);
      tex.needsUpdate = true;
      tex.wrapS = tex.wrapT = THREE.ClampToEdgeWrapping;
      tex.minFilter = THREE.LinearMipmapLinearFilter;
      tex.magFilter = THREE.LinearFilter;
      tex.anisotropy = 8;
      tex.colorSpace = srgb ? THREE.SRGBColorSpace : THREE.NoColorSpace;
      return tex;
    }

    function blurBox(imgData, passes = 2) {
      // Simple (fast-ish) separable-ish box blur on CPU
      const { width:w, height:h, data } = imgData;
      const out = new Uint8ClampedArray(data.length);
      let src = new Uint8ClampedArray(data);
      let dst = out;

      const radius = 2;
      for (let p=0; p<passes; p++) {
        // horizontal
        for (let y=0; y<h; y++) {
          for (let x=0; x<w; x++) {
            let r=0,g=0,b=0,a=0, n=0;
            for (let k=-radius; k<=radius; k++) {
              const xx = Math.min(w-1, Math.max(0, x+k));
              const i = (y*w + xx)*4;
              r += src[i]; g += src[i+1]; b += src[i+2]; a += src[i+3];
              n++;
            }
            const o = (y*w + x)*4;
            dst[o] = r/n; dst[o+1]=g/n; dst[o+2]=b/n; dst[o+3]=a/n;
          }
        }
        // vertical
        const tmp = new Uint8ClampedArray(dst);
        for (let y=0; y<h; y++) {
          for (let x=0; x<w; x++) {
            let r=0,g=0,b=0,a=0, n=0;
            for (let k=-radius; k<=radius; k++) {
              const yy = Math.min(h-1, Math.max(0, y+k));
              const i = (yy*w + x)*4;
              r += tmp[i]; g += tmp[i+1]; b += tmp[i+2]; a += tmp[i+3];
              n++;
            }
            const o = (y*w + x)*4;
            dst[o] = r/n; dst[o+1]=g/n; dst[o+2]=b/n; dst[o+3]=a/n;
          }
        }
        src = new Uint8ClampedArray(dst);
      }
      imgData.data.set(src);
      return imgData;
    }

    function buildAutoHeightFromFront(frontBmp) {
      // Height = soft luminance + a small non-tiling micro emboss.
      const img = getImageDataFromBitmap(frontBmp);
      const d = img.data;
      const w = img.width, h = img.height;

      // luminance (soft)
      for (let i=0; i<d.length; i+=4) {
        const r = d[i]/255, g = d[i+1]/255, b = d[i+2]/255;
        // perceptual-ish
        const y = (0.2126*r + 0.7152*g + 0.0722*b);
        const v = Math.round(clamp01(y) * 255);
        d[i]=d[i+1]=d[i+2]=v;
        d[i+3]=255;
      }
      blurBox(img, 3);

      // add subtle micro structure
      for (let y=0; y<h; y++) {
        for (let x=0; x<w; x++) {
          const i = (y*w + x)*4;
          const u = x/w, v = y/h;
          // micro pattern: non-tiling-ish by mixing frequencies
          const m =
            0.5 +
            0.25*Math.sin((u*173.1 + v*91.7)*Math.PI*2) +
            0.20*Math.sin((u*71.3 - v*131.9)*Math.PI*2) +
            0.10*Math.sin((u*311.7 + v*203.9)*Math.PI*2);
          const base = d[i]/255;
          const mix = clamp01(base*0.88 + m*0.12);
          const vv = Math.round(mix*255);
          d[i]=d[i+1]=d[i+2]=vv;
        }
      }
      return img;
    }

    function heightToNormalMap(heightImgData, strength = 2.0) {
      // Sobel-ish -> normal map
      const { width:w, height:h, data:d } = heightImgData;
      const out = new ImageData(w, h);
      const o = out.data;

      const getH = (x,y) => {
        x = Math.min(w-1, Math.max(0, x));
        y = Math.min(h-1, Math.max(0, y));
        return d[(y*w + x)*4] / 255;
      };

      for (let y=0; y<h; y++) {
        for (let x=0; x<w; x++) {
          const hl = getH(x-1,y), hr = getH(x+1,y);
          const hu = getH(x,y-1), hd = getH(x,y+1);

          // gradient
          let dx = (hr - hl) * strength;
          let dy = (hd - hu) * strength;

          // normal
          let nx = -dx;
          let ny = -dy;
          let nz = 1.0;
          const len = Math.hypot(nx, ny, nz);
          nx/=len; ny/=len; nz/=len;

          const i = (y*w + x)*4;
          o[i]   = Math.round((nx*0.5+0.5)*255);
          o[i+1] = Math.round((ny*0.5+0.5)*255);
          o[i+2] = Math.round((nz*0.5+0.5)*255);
          o[i+3] = 255;
        }
      }
      return out;
    }

    function buildAutoMaskFromFront(frontBmp) {
      // Goal: protect subject (Pokémon) from holo more than background.
      // Heuristic: center bias + saturation/edge/contrast -> foreground-ish.
      const img = getImageDataFromBitmap(frontBmp);
      const d = img.data;
      const w = img.width, h = img.height;

      // compute crude saliency
      const sal = new Float32Array(w*h);

      function rgb2hsv(r,g,b){
        const max = Math.max(r,g,b), min = Math.min(r,g,b);
        const c = max-min;
        const s = max === 0 ? 0 : c/max;
        const v = max;
        return { s, v };
      }

      for (let y=0; y<h; y++) {
        for (let x=0; x<w; x++) {
          const i = (y*w + x)*4;
          const r = d[i]/255, g=d[i+1]/255, b=d[i+2]/255;
          const { s, v } = rgb2hsv(r,g,b);

          // edge-ish (local contrast)
          const r2 = d[Math.min(d.length-4, i+4)]/255;
          const v2 = (0.2126*r2 + 0.7152*(d[Math.min(d.length-3, i+5)]/255) + 0.0722*(d[Math.min(d.length-2, i+6)]/255));
          const v1 = (0.2126*r + 0.7152*g + 0.0722*b);
          const edge = Math.abs(v2 - v1);

          const cx = (x/(w-1) - 0.5), cy = (y/(h-1) - 0.5);
          const center = Math.exp(-(cx*cx + cy*cy) / 0.18); // strong center bias

          // subject tends to have edges + saturation, and often sits central
          const score = 0.55*center + 0.25*s + 0.20*edge;
          sal[y*w + x] = score;
        }
      }

      // normalize + threshold into a soft mask
      let mn = Infinity, mx = -Infinity;
      for (let i=0;i<sal.length;i++){ mn=Math.min(mn,sal[i]); mx=Math.max(mx,sal[i]); }
      const range = Math.max(1e-6, mx-mn);

      const out = new ImageData(w,h);
      const o = out.data;

      for (let y=0; y<h; y++){
        for (let x=0; x<w; x++){
          const s = (sal[y*w + x]-mn)/range;

          // soften and keep *subject* = 1.0 (protected)
          // threshold tuned to be conservative (don’t accidentally protect whole background)
          const m = clamp01((s - 0.42) / (0.78 - 0.42));
          const mm = m*m*(3-2*m); // smoothstep

          const i = (y*w + x)*4;
          const v = Math.round(mm*255);
          o[i]=o[i+1]=o[i+2]=v; o[i+3]=255;
        }
      }

      blurBox(out, 2);
      return out;
    }

    function roundedRectShape(w, h, r) {
      // r in same units as w,h (card units)
      const s = new THREE.Shape();
      const x = -w/2, y = -h/2;
      const rr = Math.min(r, w/2, h/2);
      s.moveTo(x+rr, y);
      s.lineTo(x+w-rr, y);
      s.quadraticCurveTo(x+w, y, x+w, y+rr);
      s.lineTo(x+w, y+h-rr);
      s.quadraticCurveTo(x+w, y+h, x+w-rr, y+h);
      s.lineTo(x+rr, y+h);
      s.quadraticCurveTo(x, y+h, x, y+h-rr);
      s.lineTo(x, y+rr);
      s.quadraticCurveTo(x, y, x+rr, y);
      return s;
    }

    // ---------- Three.js scene ----------
    const container = document.getElementById('app');
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false, otherwise: undefined });
    renderer.setPixelRatio(Math.min(2, window.devicePixelRatio || 1));
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.outputColorSpace = THREE.SRGBColorSpace;

    // Tone mapping to prevent blowout and tame contrast:
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.05;

    container.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x07090d);

    const camera = new THREE.PerspectiveCamera(35, window.innerWidth/window.innerHeight, 0.01, 100);
    camera.position.set(0, 0.08, 3.15); // farther at load-in

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.08;
    controls.rotateSpeed = 0.75;
    controls.zoomSpeed = 0.9;
    controls.enablePan = false;

    // "Studio" lighting: soft key + fill + rim + faint overhead
    const key = new THREE.DirectionalLight(0xffffff, 2.2);
    key.position.set(2.2, 2.8, 2.0);
    scene.add(key);

    const fill = new THREE.DirectionalLight(0xffffff, 0.95);
    fill.position.set(-2.8, 1.2, 1.6);
    scene.add(fill);

    const rim = new THREE.DirectionalLight(0xffffff, 1.15);
    rim.position.set(-1.8, 2.2, -2.4);
    scene.add(rim);

    const amb = new THREE.AmbientLight(0xffffff, 0.18);
    scene.add(amb);

    // ---------- Card mesh ----------
    const CARD_W = 2.5;
    const CARD_H = CARD_W * 3.5/2.5; // tcg aspect-ish
    // Pokémon corners are not super round: keep modest radius
    const CORNER_R = 0.14;

    const shape = roundedRectShape(CARD_W, CARD_H, CORNER_R);
    const geom = new THREE.ShapeGeometry(shape, 24);
    geom.computeVertexNormals();

    // small thickness via second mesh (cheap)
    const backGeom = geom.clone();

    // placeholder textures until loaded
    const dummy = new THREE.DataTexture(new Uint8Array([255,255,255,255]), 1,1);
    dummy.needsUpdate = true;
    dummy.colorSpace = THREE.SRGBColorSpace;

    let frontTex = dummy;
    let backTex  = dummy;
    let heightTex = null;
    let maskTex = null;

    const frontMat = new THREE.MeshPhysicalMaterial({
      map: frontTex,
      roughness: 0.40,
      metalness: 0.05,
      clearcoat: 0.25,
      clearcoatRoughness: 0.20,
      sheen: 0.0
    });

    const backMat = new THREE.MeshPhysicalMaterial({
      map: backTex,
      roughness: 0.55,
      metalness: 0.0,
      clearcoat: 0.10,
      clearcoatRoughness: 0.28
    });

    // Build front and back as two planes separated slightly
    const card = new THREE.Group();
    const frontMesh = new THREE.Mesh(geom, frontMat);
    const backMesh  = new THREE.Mesh(backGeom, backMat);

    frontMesh.position.z = 0.002;
    backMesh.position.z  = -0.002;
    backMesh.rotation.y = Math.PI; // correct orientation of back texture

    card.add(frontMesh);
    card.add(backMesh);

    // slight tilt at load so it looks real
    card.rotation.x = -0.08;
    card.rotation.y = 0.28;
    scene.add(card);

    // ---------- Holo shader injection (reactive, not gliding) ----------
    function applyHoloShader(material) {
      material.onBeforeCompile = (shader) => {
        shader.uniforms.uHoloOn = { value: 1.0 };
        shader.uniforms.uHoloStrength = { value: parseFloat($('holoStrength').value) };
        shader.uniforms.uHoloReact = { value: parseFloat($('holoReact').value) };
        shader.uniforms.uMaskTex = { value: maskTex };
        shader.uniforms.uHasMask = { value: maskTex ? 1.0 : 0.0 };

        // Anchor a wavy foil pattern to UVs. Make it view-reactive via (N·V) not time.
        shader.fragmentShader = shader.fragmentShader.replace(
          '#include <common>',
          `#include <common>
           uniform float uHoloOn;
           uniform float uHoloStrength;
           uniform float uHoloReact;
           uniform sampler2D uMaskTex;
           uniform float uHasMask;

           float hash21(vec2 p){
             p = fract(p*vec2(123.34, 456.21));
             p += dot(p, p+45.32);
             return fract(p.x*p.y);
           }

           // spectral-ish rainbow from scalar
           vec3 spectral(float t){
             t = fract(t);
             vec3 c = clamp(abs(fract(t + vec3(0.0, 0.33, 0.67))*2.0 - 1.0), 0.0, 1.0);
             // soften to look less "neon"
             c = pow(c, vec3(1.35));
             return c;
           }
          `
        );

        shader.fragmentShader = shader.fragmentShader.replace(
          '#include <lights_fragment_begin>',
          `
          #include <lights_fragment_begin>

          // ---- Holofoil (front only) ----
          // We ADD a controlled iridescent component to specular, not multiply base color.
          if (uHoloOn > 0.5) {
            // View direction and normal are available in physical shader via geometryNormal/normal
            // "dotNV" changes 1:1 with tilt; multiply by reactivity.
            float dotNV = clamp(dot(geometryNormal, geometryViewDir), 0.0, 1.0);

            // Wavy pattern anchored to UVs (no time sweep):
            vec2 uv = vUv;
            float wave =
              sin((uv.y*9.0 + sin(uv.x*7.0))*6.2831) * 0.35 +
              sin((uv.x*5.0 - uv.y*3.0)*6.2831) * 0.20 +
              sin((uv.x*21.0 + uv.y*13.0)*6.2831) * 0.10;

            // Fine grain: stable noise
            float grain = (hash21(uv*vec2(1200.0, 900.0)) - 0.5) * 0.08;

            // Angle drives color shift; wave makes it "foil wavy"
            float t = (1.0 - dotNV) * uHoloReact + wave + grain;

            // Holo color (spectral-ish), softened
            vec3 holo = spectral(t);

            // Mask: 1 = protect subject (less holo), 0 = background (more holo)
            float protect = 0.0;
            if (uHasMask > 0.5) {
              protect = texture2D(uMaskTex, uv).r; // grayscale
            }

            // Fresnel-ish: stronger at grazing, weaker head-on
            float fres = pow(1.0 - dotNV, 2.2);

            // Control contrast: keep holo from blowing highlights by clamping energy
            // Also reduce holo on protected subject
            float holoAmt = uHoloStrength * fres * (1.0 - 0.85*protect);
            holoAmt = clamp(holoAmt, 0.0, 1.15);

            // Apply holo primarily to specular-like contribution:
            // We add to outgoingLight with a gentle gain, not destroying albedo.
            outgoingLight += holo * holoAmt * 0.55;
          }
          `
        );

        material.userData.shader = shader;
      };

      material.needsUpdate = true;
    }

    applyHoloShader(frontMat);

    // ---------- Emboss (legible) ----------
    // Emboss should be mostly normal/roughness variation, not color distortion.
    function applyEmboss(normalTex, strength) {
      frontMat.normalMap = normalTex;
      frontMat.normalScale = new THREE.Vector2(0.55, 0.55).multiplyScalar(strength * 0.55);
      // keep readable: don’t over-sharpen highlights
      frontMat.roughness = 0.42;
      frontMat.clearcoat = 0.28;
      frontMat.clearcoatRoughness = 0.22;
      frontMat.needsUpdate = true;
    }

    function clearEmboss() {
      frontMat.normalMap = null;
      frontMat.needsUpdate = true;
    }

    // ---------- Load preset assets ----------
    const PRESETS = {
      ray: {
        name: "Mega Rayquaza",
        front: "./assets/presets/mega-rayquaza-front.JPG"
      },
      blast: {
        name: "Mega Blastoise",
        front: "./assets/presets/mega-blastoise-front.JPG"
      }
    };

    const BACK_PATH = "./assets/pokemon-back.jpg";

    async function loadAllFromPreset(presetKey) {
      setStatus("Loading…");
      logLine(`Preset: ${presetKey}`);

      // Always load back from assets root
      const backBmp = await loadImageBitmapFromUrl(BACK_PATH);
      backTex.dispose?.();
      backTex = bitmapToTexture(backBmp, { srgb: true });
      backMat.map = backTex;
      backMat.needsUpdate = true;
      logLine(`✓ Loaded: ${BACK_PATH}`);

      // Front
      const frontUrl = PRESETS[presetKey].front;
      const frontBmp = await loadImageBitmapFromUrl(frontUrl);
      frontTex.dispose?.();
      frontTex = bitmapToTexture(frontBmp, { srgb: true });
      frontMat.map = frontTex;
      frontMat.needsUpdate = true;
      logLine(`✓ Loaded: ${frontUrl}`);

      // Height
      let heightImg;
      if ($('autoHeightOn').checked) {
        heightImg = buildAutoHeightFromFront(frontBmp);
        logLine(`✓ Auto-height generated`);
      } else {
        heightImg = null;
      }

      // Mask
      let maskImg = null;
      if ($('autoMaskOn').checked) {
        maskImg = buildAutoMaskFromFront(frontBmp);
        logLine(`✓ Auto-mask generated`);
      }

      // push to textures
      if (maskImg) {
        maskTex?.dispose?.();
        maskTex = imageDataToTexture(maskImg, { srgb: false });
      } else {
        maskTex?.dispose?.();
        maskTex = null;
      }

      // Update shader uniforms (if compiled)
      if (frontMat.userData.shader) {
        frontMat.userData.shader.uniforms.uMaskTex.value = maskTex;
        frontMat.userData.shader.uniforms.uHasMask.value = maskTex ? 1.0 : 0.0;
      }

      // Emboss normal map
      if ($('embossOn').checked && heightImg) {
        const strength = parseFloat($('embossStrength').value);
        const normalImg = heightToNormalMap(heightImg, 1.15 + strength * 0.75);
        const normalTex = imageDataToTexture(normalImg, { srgb: false });
        applyEmboss(normalTex, strength);
      } else {
        clearEmboss();
      }

      // Ensure holo toggle is reflected
      if (frontMat.userData.shader) {
        frontMat.userData.shader.uniforms.uHoloOn.value = $('holoOn').checked ? 1.0 : 0.0;
        frontMat.userData.shader.uniforms.uHoloStrength.value = parseFloat($('holoStrength').value);
        frontMat.userData.shader.uniforms.uHoloReact.value = parseFloat($('holoReact').value);
      }

      setStatus("Ready");
    }

    // ---------- Upload handlers ----------
    async function loadFrontFromUpload(file) {
      const bmp = await loadImageBitmapFromFile(file);
      frontTex.dispose?.();
      frontTex = bitmapToTexture(bmp, { srgb: true });
      frontMat.map = frontTex;
      frontMat.needsUpdate = true;
      logLine(`✓ Loaded front upload: ${file.name}`);

      // regenerate height/mask if toggles enabled (unless user supplies them)
      if ($('autoHeightOn').checked) {
        const h = buildAutoHeightFromFront(bmp);
        const strength = parseFloat($('embossStrength').value);
        if ($('embossOn').checked) {
          const n = heightToNormalMap(h, 1.15 + strength * 0.75);
          const nt = imageDataToTexture(n, { srgb: false });
          applyEmboss(nt, strength);
        }
        logLine(`✓ Auto-height generated (upload)`);
      }

      if ($('autoMaskOn').checked) {
        const m = buildAutoMaskFromFront(bmp);
        maskTex?.dispose?.();
        maskTex = imageDataToTexture(m, { srgb: false });
        if (frontMat.userData.shader) {
          frontMat.userData.shader.uniforms.uMaskTex.value = maskTex;
          frontMat.userData.shader.uniforms.uHasMask.value = 1.0;
        }
        logLine(`✓ Auto-mask generated (upload)`);
      }
    }

    async function loadHeightFromUpload(file) {
      const bmp = await loadImageBitmapFromFile(file);
      const img = getImageDataFromBitmap(bmp);

      if ($('embossOn').checked) {
        const strength = parseFloat($('embossStrength').value);
        const normalImg = heightToNormalMap(img, 1.15 + strength * 0.75);
        const normalTex = imageDataToTexture(normalImg, { srgb: false });
        applyEmboss(normalTex, strength);
        logLine(`✓ Loaded height map: ${file.name} (emboss applied)`);
      } else {
        logLine(`✓ Loaded height map: ${file.name} (emboss currently off)`);
      }
    }

    async function loadMaskFromUpload(file) {
      const bmp = await loadImageBitmapFromFile(file);
      const img = getImageDataFromBitmap(bmp);
      // assume user provides grayscale where white = subject (protected)
      maskTex?.dispose?.();
      maskTex = imageDataToTexture(img, { srgb: false });

      if (frontMat.userData.shader) {
        frontMat.userData.shader.uniforms.uMaskTex.value = maskTex;
        frontMat.userData.shader.uniforms.uHasMask.value = 1.0;
      }
      logLine(`✓ Loaded mask: ${file.name}`);
    }

    // ---------- UI wiring ----------
    $('toggleLog').onclick = () => {
      logEl.style.display = (logEl.style.display === 'none' || !logEl.style.display) ? 'block' : 'none';
    };

    $('resetView').onclick = () => {
      camera.position.set(0, 0.08, 3.15);
      controls.target.set(0, 0, 0);
      card.rotation.set(-0.08, 0.28, 0);
      controls.update();
      logLine("✓ Reset view");
    };

    $('reload').onclick = async () => {
      logLine("--- Reload ---");
      await loadAllFromPreset($('preset').value);
    };

    $('preset').onchange = async () => loadAllFromPreset($('preset').value);

    $('frontFile').onchange = async (e) => {
      const f = e.target.files?.[0];
      if (!f) return;
      await loadFrontFromUpload(f);
    };

    $('heightFile').onchange = async (e) => {
      const f = e.target.files?.[0];
      if (!f) return;
      await loadHeightFromUpload(f);
    };

    $('maskFile').onchange = async (e) => {
      const f = e.target.files?.[0];
      if (!f) return;
      await loadMaskFromUpload(f);
    };

    function syncVals(){
      $('holoStrengthVal').textContent = parseFloat($('holoStrength').value).toFixed(2);
      $('holoReactVal').textContent = parseFloat($('holoReact').value).toFixed(2);
      $('embossStrengthVal').textContent = parseFloat($('embossStrength').value).toFixed(2);
    }
    syncVals();

    $('holoOn').onchange = () => {
      if (frontMat.userData.shader) frontMat.userData.shader.uniforms.uHoloOn.value = $('holoOn').checked ? 1.0 : 0.0;
    };

    $('embossOn').onchange = async () => {
      // easiest: just reload preset to re-derive height/normal cleanly
      await loadAllFromPreset($('preset').value);
    };

    $('autoHeightOn').onchange = async () => {
      await loadAllFromPreset($('preset').value);
    };

    $('autoMaskOn').onchange = async () => {
      await loadAllFromPreset($('preset').value);
    };

    $('holoStrength').oninput = () => {
      syncVals();
      if (frontMat.userData.shader) frontMat.userData.shader.uniforms.uHoloStrength.value = parseFloat($('holoStrength').value);
    };

    $('holoReact').oninput = () => {
      syncVals();
      if (frontMat.userData.shader) frontMat.userData.shader.uniforms.uHoloReact.value = parseFloat($('holoReact').value);
    };

    $('embossStrength').oninput = async () => {
      syncVals();
      // reload to rebuild normal map with updated strength
      await loadAllFromPreset($('preset').value);
    };

    // ---------- Resize ----------
    window.addEventListener('resize', () => {
      renderer.setSize(window.innerWidth, window.innerHeight);
      camera.aspect = window.innerWidth/window.innerHeight;
      camera.updateProjectionMatrix();
    });

    // ---------- Boot ----------
    (async function boot(){
      setStatus("Booting…");
      logLine("Boot…");

      try {
        await loadAllFromPreset($('preset').value);
        setStatus("Ready");
      } catch (err) {
        setStatus("Error");
        logLine("❌ " + (err?.message || err));
      }
    })();

    // ---------- Render loop ----------
    function animate() {
      requestAnimationFrame(animate);
      controls.update();

      // Keep shader uniforms fresh even if compilation happens later
      if (frontMat.userData.shader) {
        frontMat.userData.shader.uniforms.uHoloOn.value = $('holoOn').checked ? 1.0 : 0.0;
        frontMat.userData.shader.uniforms.uHoloStrength.value = parseFloat($('holoStrength').value);
        frontMat.userData.shader.uniforms.uHoloReact.value = parseFloat($('holoReact').value);
        frontMat.userData.shader.uniforms.uMaskTex.value = maskTex;
        frontMat.userData.shader.uniforms.uHasMask.value = maskTex ? 1.0 : 0.0;
      }

      renderer.render(scene, camera);
    }
    animate();
  </script>
</body>
</html>
